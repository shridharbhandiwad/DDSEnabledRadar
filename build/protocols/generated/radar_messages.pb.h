// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: radar_messages.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_radar_5fmessages_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_radar_5fmessages_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include <google/protobuf/timestamp.pb.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_radar_5fmessages_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_radar_5fmessages_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_radar_5fmessages_2eproto;
namespace radar {
namespace messages {
class Detection;
struct DetectionDefaultTypeInternal;
extern DetectionDefaultTypeInternal _Detection_default_instance_;
class DetectionBatch;
struct DetectionBatchDefaultTypeInternal;
extern DetectionBatchDefaultTypeInternal _DetectionBatch_default_instance_;
class Detection_AttributesEntry_DoNotUse;
struct Detection_AttributesEntry_DoNotUseDefaultTypeInternal;
extern Detection_AttributesEntry_DoNotUseDefaultTypeInternal _Detection_AttributesEntry_DoNotUse_default_instance_;
class Matrix3D;
struct Matrix3DDefaultTypeInternal;
extern Matrix3DDefaultTypeInternal _Matrix3D_default_instance_;
class PerformanceMetrics;
struct PerformanceMetricsDefaultTypeInternal;
extern PerformanceMetricsDefaultTypeInternal _PerformanceMetrics_default_instance_;
class Point3D;
struct Point3DDefaultTypeInternal;
extern Point3DDefaultTypeInternal _Point3D_default_instance_;
class RadarCommand;
struct RadarCommandDefaultTypeInternal;
extern RadarCommandDefaultTypeInternal _RadarCommand_default_instance_;
class RadarCommandResponse;
struct RadarCommandResponseDefaultTypeInternal;
extern RadarCommandResponseDefaultTypeInternal _RadarCommandResponse_default_instance_;
class RadarCommandResponse_ResultDataEntry_DoNotUse;
struct RadarCommandResponse_ResultDataEntry_DoNotUseDefaultTypeInternal;
extern RadarCommandResponse_ResultDataEntry_DoNotUseDefaultTypeInternal _RadarCommandResponse_ResultDataEntry_DoNotUse_default_instance_;
class RadarCommand_ParametersEntry_DoNotUse;
struct RadarCommand_ParametersEntry_DoNotUseDefaultTypeInternal;
extern RadarCommand_ParametersEntry_DoNotUseDefaultTypeInternal _RadarCommand_ParametersEntry_DoNotUse_default_instance_;
class RadarStatus;
struct RadarStatusDefaultTypeInternal;
extern RadarStatusDefaultTypeInternal _RadarStatus_default_instance_;
class SignalProcessingConfig;
struct SignalProcessingConfigDefaultTypeInternal;
extern SignalProcessingConfigDefaultTypeInternal _SignalProcessingConfig_default_instance_;
class SystemHealth;
struct SystemHealthDefaultTypeInternal;
extern SystemHealthDefaultTypeInternal _SystemHealth_default_instance_;
class SystemHealth_ComponentHealthEntry_DoNotUse;
struct SystemHealth_ComponentHealthEntry_DoNotUseDefaultTypeInternal;
extern SystemHealth_ComponentHealthEntry_DoNotUseDefaultTypeInternal _SystemHealth_ComponentHealthEntry_DoNotUse_default_instance_;
class Vector3D;
struct Vector3DDefaultTypeInternal;
extern Vector3DDefaultTypeInternal _Vector3D_default_instance_;
}  // namespace messages
}  // namespace radar
PROTOBUF_NAMESPACE_OPEN
template<> ::radar::messages::Detection* Arena::CreateMaybeMessage<::radar::messages::Detection>(Arena*);
template<> ::radar::messages::DetectionBatch* Arena::CreateMaybeMessage<::radar::messages::DetectionBatch>(Arena*);
template<> ::radar::messages::Detection_AttributesEntry_DoNotUse* Arena::CreateMaybeMessage<::radar::messages::Detection_AttributesEntry_DoNotUse>(Arena*);
template<> ::radar::messages::Matrix3D* Arena::CreateMaybeMessage<::radar::messages::Matrix3D>(Arena*);
template<> ::radar::messages::PerformanceMetrics* Arena::CreateMaybeMessage<::radar::messages::PerformanceMetrics>(Arena*);
template<> ::radar::messages::Point3D* Arena::CreateMaybeMessage<::radar::messages::Point3D>(Arena*);
template<> ::radar::messages::RadarCommand* Arena::CreateMaybeMessage<::radar::messages::RadarCommand>(Arena*);
template<> ::radar::messages::RadarCommandResponse* Arena::CreateMaybeMessage<::radar::messages::RadarCommandResponse>(Arena*);
template<> ::radar::messages::RadarCommandResponse_ResultDataEntry_DoNotUse* Arena::CreateMaybeMessage<::radar::messages::RadarCommandResponse_ResultDataEntry_DoNotUse>(Arena*);
template<> ::radar::messages::RadarCommand_ParametersEntry_DoNotUse* Arena::CreateMaybeMessage<::radar::messages::RadarCommand_ParametersEntry_DoNotUse>(Arena*);
template<> ::radar::messages::RadarStatus* Arena::CreateMaybeMessage<::radar::messages::RadarStatus>(Arena*);
template<> ::radar::messages::SignalProcessingConfig* Arena::CreateMaybeMessage<::radar::messages::SignalProcessingConfig>(Arena*);
template<> ::radar::messages::SystemHealth* Arena::CreateMaybeMessage<::radar::messages::SystemHealth>(Arena*);
template<> ::radar::messages::SystemHealth_ComponentHealthEntry_DoNotUse* Arena::CreateMaybeMessage<::radar::messages::SystemHealth_ComponentHealthEntry_DoNotUse>(Arena*);
template<> ::radar::messages::Vector3D* Arena::CreateMaybeMessage<::radar::messages::Vector3D>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace radar {
namespace messages {

enum RadarCommand_CommandType : int {
  RadarCommand_CommandType_COMMAND_TYPE_UNSPECIFIED = 0,
  RadarCommand_CommandType_START_SCAN = 1,
  RadarCommand_CommandType_STOP_SCAN = 2,
  RadarCommand_CommandType_CHANGE_MODE = 3,
  RadarCommand_CommandType_UPDATE_CONFIG = 4,
  RadarCommand_CommandType_BEAM_REQUEST = 5,
  RadarCommand_CommandType_RESET = 6,
  RadarCommand_CommandType_SHUTDOWN = 7,
  RadarCommand_CommandType_RadarCommand_CommandType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  RadarCommand_CommandType_RadarCommand_CommandType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool RadarCommand_CommandType_IsValid(int value);
constexpr RadarCommand_CommandType RadarCommand_CommandType_CommandType_MIN = RadarCommand_CommandType_COMMAND_TYPE_UNSPECIFIED;
constexpr RadarCommand_CommandType RadarCommand_CommandType_CommandType_MAX = RadarCommand_CommandType_SHUTDOWN;
constexpr int RadarCommand_CommandType_CommandType_ARRAYSIZE = RadarCommand_CommandType_CommandType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* RadarCommand_CommandType_descriptor();
template<typename T>
inline const std::string& RadarCommand_CommandType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, RadarCommand_CommandType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function RadarCommand_CommandType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    RadarCommand_CommandType_descriptor(), enum_t_value);
}
inline bool RadarCommand_CommandType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, RadarCommand_CommandType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<RadarCommand_CommandType>(
    RadarCommand_CommandType_descriptor(), name, value);
}
enum RadarCommandResponse_ResponseStatus : int {
  RadarCommandResponse_ResponseStatus_RESPONSE_STATUS_UNSPECIFIED = 0,
  RadarCommandResponse_ResponseStatus_SUCCESS = 1,
  RadarCommandResponse_ResponseStatus_FAILURE = 2,
  RadarCommandResponse_ResponseStatus_PARTIAL_SUCCESS = 3,
  RadarCommandResponse_ResponseStatus_IN_PROGRESS = 4,
  RadarCommandResponse_ResponseStatus_RadarCommandResponse_ResponseStatus_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  RadarCommandResponse_ResponseStatus_RadarCommandResponse_ResponseStatus_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool RadarCommandResponse_ResponseStatus_IsValid(int value);
constexpr RadarCommandResponse_ResponseStatus RadarCommandResponse_ResponseStatus_ResponseStatus_MIN = RadarCommandResponse_ResponseStatus_RESPONSE_STATUS_UNSPECIFIED;
constexpr RadarCommandResponse_ResponseStatus RadarCommandResponse_ResponseStatus_ResponseStatus_MAX = RadarCommandResponse_ResponseStatus_IN_PROGRESS;
constexpr int RadarCommandResponse_ResponseStatus_ResponseStatus_ARRAYSIZE = RadarCommandResponse_ResponseStatus_ResponseStatus_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* RadarCommandResponse_ResponseStatus_descriptor();
template<typename T>
inline const std::string& RadarCommandResponse_ResponseStatus_Name(T enum_t_value) {
  static_assert(::std::is_same<T, RadarCommandResponse_ResponseStatus>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function RadarCommandResponse_ResponseStatus_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    RadarCommandResponse_ResponseStatus_descriptor(), enum_t_value);
}
inline bool RadarCommandResponse_ResponseStatus_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, RadarCommandResponse_ResponseStatus* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<RadarCommandResponse_ResponseStatus>(
    RadarCommandResponse_ResponseStatus_descriptor(), name, value);
}
enum SystemHealth_HealthStatus : int {
  SystemHealth_HealthStatus_HEALTH_STATUS_UNSPECIFIED = 0,
  SystemHealth_HealthStatus_HEALTHY = 1,
  SystemHealth_HealthStatus_WARNING = 2,
  SystemHealth_HealthStatus_ERROR = 3,
  SystemHealth_HealthStatus_CRITICAL = 4,
  SystemHealth_HealthStatus_SystemHealth_HealthStatus_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  SystemHealth_HealthStatus_SystemHealth_HealthStatus_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool SystemHealth_HealthStatus_IsValid(int value);
constexpr SystemHealth_HealthStatus SystemHealth_HealthStatus_HealthStatus_MIN = SystemHealth_HealthStatus_HEALTH_STATUS_UNSPECIFIED;
constexpr SystemHealth_HealthStatus SystemHealth_HealthStatus_HealthStatus_MAX = SystemHealth_HealthStatus_CRITICAL;
constexpr int SystemHealth_HealthStatus_HealthStatus_ARRAYSIZE = SystemHealth_HealthStatus_HealthStatus_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SystemHealth_HealthStatus_descriptor();
template<typename T>
inline const std::string& SystemHealth_HealthStatus_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SystemHealth_HealthStatus>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SystemHealth_HealthStatus_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    SystemHealth_HealthStatus_descriptor(), enum_t_value);
}
inline bool SystemHealth_HealthStatus_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SystemHealth_HealthStatus* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<SystemHealth_HealthStatus>(
    SystemHealth_HealthStatus_descriptor(), name, value);
}
enum CoordinateSystem : int {
  COORDINATE_SYSTEM_UNSPECIFIED = 0,
  CARTESIAN = 1,
  POLAR = 2,
  SPHERICAL = 3,
  WGS84 = 4,
  CoordinateSystem_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  CoordinateSystem_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool CoordinateSystem_IsValid(int value);
constexpr CoordinateSystem CoordinateSystem_MIN = COORDINATE_SYSTEM_UNSPECIFIED;
constexpr CoordinateSystem CoordinateSystem_MAX = WGS84;
constexpr int CoordinateSystem_ARRAYSIZE = CoordinateSystem_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CoordinateSystem_descriptor();
template<typename T>
inline const std::string& CoordinateSystem_Name(T enum_t_value) {
  static_assert(::std::is_same<T, CoordinateSystem>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function CoordinateSystem_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    CoordinateSystem_descriptor(), enum_t_value);
}
inline bool CoordinateSystem_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, CoordinateSystem* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<CoordinateSystem>(
    CoordinateSystem_descriptor(), name, value);
}
enum DetectionType : int {
  DETECTION_TYPE_UNSPECIFIED = 0,
  POINT_TARGET = 1,
  EXTENDED_TARGET = 2,
  CLUTTER = 3,
  UNKNOWN = 4,
  DetectionType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  DetectionType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool DetectionType_IsValid(int value);
constexpr DetectionType DetectionType_MIN = DETECTION_TYPE_UNSPECIFIED;
constexpr DetectionType DetectionType_MAX = UNKNOWN;
constexpr int DetectionType_ARRAYSIZE = DetectionType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* DetectionType_descriptor();
template<typename T>
inline const std::string& DetectionType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, DetectionType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function DetectionType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    DetectionType_descriptor(), enum_t_value);
}
inline bool DetectionType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, DetectionType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<DetectionType>(
    DetectionType_descriptor(), name, value);
}
enum MotionModel : int {
  MOTION_MODEL_UNSPECIFIED = 0,
  CONSTANT_VELOCITY = 1,
  CONSTANT_ACCELERATION = 2,
  COORDINATED_TURN_RATE = 3,
  SINGER = 4,
  CUSTOM = 5,
  MotionModel_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  MotionModel_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool MotionModel_IsValid(int value);
constexpr MotionModel MotionModel_MIN = MOTION_MODEL_UNSPECIFIED;
constexpr MotionModel MotionModel_MAX = CUSTOM;
constexpr int MotionModel_ARRAYSIZE = MotionModel_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* MotionModel_descriptor();
template<typename T>
inline const std::string& MotionModel_Name(T enum_t_value) {
  static_assert(::std::is_same<T, MotionModel>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function MotionModel_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    MotionModel_descriptor(), enum_t_value);
}
inline bool MotionModel_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, MotionModel* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<MotionModel>(
    MotionModel_descriptor(), name, value);
}
enum TrackState : int {
  TRACK_STATE_UNSPECIFIED = 0,
  TENTATIVE = 1,
  CONFIRMED = 2,
  COASTING = 3,
  DELETED = 4,
  TrackState_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  TrackState_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool TrackState_IsValid(int value);
constexpr TrackState TrackState_MIN = TRACK_STATE_UNSPECIFIED;
constexpr TrackState TrackState_MAX = DELETED;
constexpr int TrackState_ARRAYSIZE = TrackState_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TrackState_descriptor();
template<typename T>
inline const std::string& TrackState_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TrackState>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TrackState_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    TrackState_descriptor(), enum_t_value);
}
inline bool TrackState_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TrackState* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<TrackState>(
    TrackState_descriptor(), name, value);
}
// ===================================================================

class Point3D final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:radar.messages.Point3D) */ {
 public:
  inline Point3D() : Point3D(nullptr) {}
  ~Point3D() override;
  explicit PROTOBUF_CONSTEXPR Point3D(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Point3D(const Point3D& from);
  Point3D(Point3D&& from) noexcept
    : Point3D() {
    *this = ::std::move(from);
  }

  inline Point3D& operator=(const Point3D& from) {
    CopyFrom(from);
    return *this;
  }
  inline Point3D& operator=(Point3D&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Point3D& default_instance() {
    return *internal_default_instance();
  }
  static inline const Point3D* internal_default_instance() {
    return reinterpret_cast<const Point3D*>(
               &_Point3D_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Point3D& a, Point3D& b) {
    a.Swap(&b);
  }
  inline void Swap(Point3D* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Point3D* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Point3D* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Point3D>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Point3D& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Point3D& from) {
    Point3D::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Point3D* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "radar.messages.Point3D";
  }
  protected:
  explicit Point3D(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
    kZFieldNumber = 3,
  };
  // double x = 1;
  void clear_x();
  double x() const;
  void set_x(double value);
  private:
  double _internal_x() const;
  void _internal_set_x(double value);
  public:

  // double y = 2;
  void clear_y();
  double y() const;
  void set_y(double value);
  private:
  double _internal_y() const;
  void _internal_set_y(double value);
  public:

  // double z = 3;
  void clear_z();
  double z() const;
  void set_z(double value);
  private:
  double _internal_z() const;
  void _internal_set_z(double value);
  public:

  // @@protoc_insertion_point(class_scope:radar.messages.Point3D)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    double x_;
    double y_;
    double z_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_radar_5fmessages_2eproto;
};
// -------------------------------------------------------------------

class Vector3D final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:radar.messages.Vector3D) */ {
 public:
  inline Vector3D() : Vector3D(nullptr) {}
  ~Vector3D() override;
  explicit PROTOBUF_CONSTEXPR Vector3D(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Vector3D(const Vector3D& from);
  Vector3D(Vector3D&& from) noexcept
    : Vector3D() {
    *this = ::std::move(from);
  }

  inline Vector3D& operator=(const Vector3D& from) {
    CopyFrom(from);
    return *this;
  }
  inline Vector3D& operator=(Vector3D&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Vector3D& default_instance() {
    return *internal_default_instance();
  }
  static inline const Vector3D* internal_default_instance() {
    return reinterpret_cast<const Vector3D*>(
               &_Vector3D_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Vector3D& a, Vector3D& b) {
    a.Swap(&b);
  }
  inline void Swap(Vector3D* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Vector3D* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Vector3D* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Vector3D>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Vector3D& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Vector3D& from) {
    Vector3D::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Vector3D* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "radar.messages.Vector3D";
  }
  protected:
  explicit Vector3D(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
    kZFieldNumber = 3,
  };
  // double x = 1;
  void clear_x();
  double x() const;
  void set_x(double value);
  private:
  double _internal_x() const;
  void _internal_set_x(double value);
  public:

  // double y = 2;
  void clear_y();
  double y() const;
  void set_y(double value);
  private:
  double _internal_y() const;
  void _internal_set_y(double value);
  public:

  // double z = 3;
  void clear_z();
  double z() const;
  void set_z(double value);
  private:
  double _internal_z() const;
  void _internal_set_z(double value);
  public:

  // @@protoc_insertion_point(class_scope:radar.messages.Vector3D)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    double x_;
    double y_;
    double z_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_radar_5fmessages_2eproto;
};
// -------------------------------------------------------------------

class Matrix3D final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:radar.messages.Matrix3D) */ {
 public:
  inline Matrix3D() : Matrix3D(nullptr) {}
  ~Matrix3D() override;
  explicit PROTOBUF_CONSTEXPR Matrix3D(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Matrix3D(const Matrix3D& from);
  Matrix3D(Matrix3D&& from) noexcept
    : Matrix3D() {
    *this = ::std::move(from);
  }

  inline Matrix3D& operator=(const Matrix3D& from) {
    CopyFrom(from);
    return *this;
  }
  inline Matrix3D& operator=(Matrix3D&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Matrix3D& default_instance() {
    return *internal_default_instance();
  }
  static inline const Matrix3D* internal_default_instance() {
    return reinterpret_cast<const Matrix3D*>(
               &_Matrix3D_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Matrix3D& a, Matrix3D& b) {
    a.Swap(&b);
  }
  inline void Swap(Matrix3D* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Matrix3D* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Matrix3D* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Matrix3D>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Matrix3D& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Matrix3D& from) {
    Matrix3D::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Matrix3D* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "radar.messages.Matrix3D";
  }
  protected:
  explicit Matrix3D(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 1,
  };
  // repeated double data = 1;
  int data_size() const;
  private:
  int _internal_data_size() const;
  public:
  void clear_data();
  private:
  double _internal_data(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
      _internal_data() const;
  void _internal_add_data(double value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
      _internal_mutable_data();
  public:
  double data(int index) const;
  void set_data(int index, double value);
  void add_data(double value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
      data() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
      mutable_data();

  // @@protoc_insertion_point(class_scope:radar.messages.Matrix3D)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< double > data_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_radar_5fmessages_2eproto;
};
// -------------------------------------------------------------------

class Detection_AttributesEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Detection_AttributesEntry_DoNotUse, 
    std::string, double,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_DOUBLE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Detection_AttributesEntry_DoNotUse, 
    std::string, double,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_DOUBLE> SuperType;
  Detection_AttributesEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR Detection_AttributesEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit Detection_AttributesEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const Detection_AttributesEntry_DoNotUse& other);
  static const Detection_AttributesEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const Detection_AttributesEntry_DoNotUse*>(&_Detection_AttributesEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "radar.messages.Detection.AttributesEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_radar_5fmessages_2eproto;
};

// -------------------------------------------------------------------

class Detection final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:radar.messages.Detection) */ {
 public:
  inline Detection() : Detection(nullptr) {}
  ~Detection() override;
  explicit PROTOBUF_CONSTEXPR Detection(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Detection(const Detection& from);
  Detection(Detection&& from) noexcept
    : Detection() {
    *this = ::std::move(from);
  }

  inline Detection& operator=(const Detection& from) {
    CopyFrom(from);
    return *this;
  }
  inline Detection& operator=(Detection&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Detection& default_instance() {
    return *internal_default_instance();
  }
  static inline const Detection* internal_default_instance() {
    return reinterpret_cast<const Detection*>(
               &_Detection_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(Detection& a, Detection& b) {
    a.Swap(&b);
  }
  inline void Swap(Detection* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Detection* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Detection* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Detection>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Detection& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Detection& from) {
    Detection::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Detection* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "radar.messages.Detection";
  }
  protected:
  explicit Detection(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kAttributesFieldNumber = 13,
    kTimestampFieldNumber = 3,
    kPositionFieldNumber = 4,
    kPositionCovarianceFieldNumber = 5,
    kVelocityFieldNumber = 6,
    kVelocityCovarianceFieldNumber = 7,
    kIdFieldNumber = 1,
    kSensorIdFieldNumber = 2,
    kSnrFieldNumber = 8,
    kAmplitudeFieldNumber = 9,
    kDopplerFieldNumber = 10,
    kTypeFieldNumber = 11,
    kCoordSystemFieldNumber = 12,
  };
  // map<string, double> attributes = 13;
  int attributes_size() const;
  private:
  int _internal_attributes_size() const;
  public:
  void clear_attributes();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >&
      _internal_attributes() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >*
      _internal_mutable_attributes();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >&
      attributes() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >*
      mutable_attributes();

  // .google.protobuf.Timestamp timestamp = 3;
  bool has_timestamp() const;
  private:
  bool _internal_has_timestamp() const;
  public:
  void clear_timestamp();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& timestamp() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_timestamp();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_timestamp();
  void set_allocated_timestamp(::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_timestamp() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_timestamp();
  public:
  void unsafe_arena_set_allocated_timestamp(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_timestamp();

  // .radar.messages.Point3D position = 4;
  bool has_position() const;
  private:
  bool _internal_has_position() const;
  public:
  void clear_position();
  const ::radar::messages::Point3D& position() const;
  PROTOBUF_NODISCARD ::radar::messages::Point3D* release_position();
  ::radar::messages::Point3D* mutable_position();
  void set_allocated_position(::radar::messages::Point3D* position);
  private:
  const ::radar::messages::Point3D& _internal_position() const;
  ::radar::messages::Point3D* _internal_mutable_position();
  public:
  void unsafe_arena_set_allocated_position(
      ::radar::messages::Point3D* position);
  ::radar::messages::Point3D* unsafe_arena_release_position();

  // .radar.messages.Matrix3D position_covariance = 5;
  bool has_position_covariance() const;
  private:
  bool _internal_has_position_covariance() const;
  public:
  void clear_position_covariance();
  const ::radar::messages::Matrix3D& position_covariance() const;
  PROTOBUF_NODISCARD ::radar::messages::Matrix3D* release_position_covariance();
  ::radar::messages::Matrix3D* mutable_position_covariance();
  void set_allocated_position_covariance(::radar::messages::Matrix3D* position_covariance);
  private:
  const ::radar::messages::Matrix3D& _internal_position_covariance() const;
  ::radar::messages::Matrix3D* _internal_mutable_position_covariance();
  public:
  void unsafe_arena_set_allocated_position_covariance(
      ::radar::messages::Matrix3D* position_covariance);
  ::radar::messages::Matrix3D* unsafe_arena_release_position_covariance();

  // .radar.messages.Vector3D velocity = 6;
  bool has_velocity() const;
  private:
  bool _internal_has_velocity() const;
  public:
  void clear_velocity();
  const ::radar::messages::Vector3D& velocity() const;
  PROTOBUF_NODISCARD ::radar::messages::Vector3D* release_velocity();
  ::radar::messages::Vector3D* mutable_velocity();
  void set_allocated_velocity(::radar::messages::Vector3D* velocity);
  private:
  const ::radar::messages::Vector3D& _internal_velocity() const;
  ::radar::messages::Vector3D* _internal_mutable_velocity();
  public:
  void unsafe_arena_set_allocated_velocity(
      ::radar::messages::Vector3D* velocity);
  ::radar::messages::Vector3D* unsafe_arena_release_velocity();

  // .radar.messages.Matrix3D velocity_covariance = 7;
  bool has_velocity_covariance() const;
  private:
  bool _internal_has_velocity_covariance() const;
  public:
  void clear_velocity_covariance();
  const ::radar::messages::Matrix3D& velocity_covariance() const;
  PROTOBUF_NODISCARD ::radar::messages::Matrix3D* release_velocity_covariance();
  ::radar::messages::Matrix3D* mutable_velocity_covariance();
  void set_allocated_velocity_covariance(::radar::messages::Matrix3D* velocity_covariance);
  private:
  const ::radar::messages::Matrix3D& _internal_velocity_covariance() const;
  ::radar::messages::Matrix3D* _internal_mutable_velocity_covariance();
  public:
  void unsafe_arena_set_allocated_velocity_covariance(
      ::radar::messages::Matrix3D* velocity_covariance);
  ::radar::messages::Matrix3D* unsafe_arena_release_velocity_covariance();

  // uint32 id = 1;
  void clear_id();
  uint32_t id() const;
  void set_id(uint32_t value);
  private:
  uint32_t _internal_id() const;
  void _internal_set_id(uint32_t value);
  public:

  // uint32 sensor_id = 2;
  void clear_sensor_id();
  uint32_t sensor_id() const;
  void set_sensor_id(uint32_t value);
  private:
  uint32_t _internal_sensor_id() const;
  void _internal_set_sensor_id(uint32_t value);
  public:

  // double snr = 8;
  void clear_snr();
  double snr() const;
  void set_snr(double value);
  private:
  double _internal_snr() const;
  void _internal_set_snr(double value);
  public:

  // double amplitude = 9;
  void clear_amplitude();
  double amplitude() const;
  void set_amplitude(double value);
  private:
  double _internal_amplitude() const;
  void _internal_set_amplitude(double value);
  public:

  // double doppler = 10;
  void clear_doppler();
  double doppler() const;
  void set_doppler(double value);
  private:
  double _internal_doppler() const;
  void _internal_set_doppler(double value);
  public:

  // .radar.messages.DetectionType type = 11;
  void clear_type();
  ::radar::messages::DetectionType type() const;
  void set_type(::radar::messages::DetectionType value);
  private:
  ::radar::messages::DetectionType _internal_type() const;
  void _internal_set_type(::radar::messages::DetectionType value);
  public:

  // .radar.messages.CoordinateSystem coord_system = 12;
  void clear_coord_system();
  ::radar::messages::CoordinateSystem coord_system() const;
  void set_coord_system(::radar::messages::CoordinateSystem value);
  private:
  ::radar::messages::CoordinateSystem _internal_coord_system() const;
  void _internal_set_coord_system(::radar::messages::CoordinateSystem value);
  public:

  // @@protoc_insertion_point(class_scope:radar.messages.Detection)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        Detection_AttributesEntry_DoNotUse,
        std::string, double,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_DOUBLE> attributes_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp_;
    ::radar::messages::Point3D* position_;
    ::radar::messages::Matrix3D* position_covariance_;
    ::radar::messages::Vector3D* velocity_;
    ::radar::messages::Matrix3D* velocity_covariance_;
    uint32_t id_;
    uint32_t sensor_id_;
    double snr_;
    double amplitude_;
    double doppler_;
    int type_;
    int coord_system_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_radar_5fmessages_2eproto;
};
// -------------------------------------------------------------------

class DetectionBatch final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:radar.messages.DetectionBatch) */ {
 public:
  inline DetectionBatch() : DetectionBatch(nullptr) {}
  ~DetectionBatch() override;
  explicit PROTOBUF_CONSTEXPR DetectionBatch(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DetectionBatch(const DetectionBatch& from);
  DetectionBatch(DetectionBatch&& from) noexcept
    : DetectionBatch() {
    *this = ::std::move(from);
  }

  inline DetectionBatch& operator=(const DetectionBatch& from) {
    CopyFrom(from);
    return *this;
  }
  inline DetectionBatch& operator=(DetectionBatch&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DetectionBatch& default_instance() {
    return *internal_default_instance();
  }
  static inline const DetectionBatch* internal_default_instance() {
    return reinterpret_cast<const DetectionBatch*>(
               &_DetectionBatch_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(DetectionBatch& a, DetectionBatch& b) {
    a.Swap(&b);
  }
  inline void Swap(DetectionBatch* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DetectionBatch* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DetectionBatch* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DetectionBatch>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DetectionBatch& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DetectionBatch& from) {
    DetectionBatch::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DetectionBatch* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "radar.messages.DetectionBatch";
  }
  protected:
  explicit DetectionBatch(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDetectionsFieldNumber = 1,
    kProcessingModeFieldNumber = 10,
    kBatchTimestampFieldNumber = 2,
    kSensorIdFieldNumber = 3,
    kSequenceNumberFieldNumber = 4,
    kScanPeriodFieldNumber = 5,
    kAzimuthStartFieldNumber = 6,
    kAzimuthEndFieldNumber = 7,
    kElevationStartFieldNumber = 8,
    kElevationEndFieldNumber = 9,
    kProcessingTimeMsFieldNumber = 11,
    kTotalDetectionsFieldNumber = 12,
    kFilteredDetectionsFieldNumber = 13,
  };
  // repeated .radar.messages.Detection detections = 1;
  int detections_size() const;
  private:
  int _internal_detections_size() const;
  public:
  void clear_detections();
  ::radar::messages::Detection* mutable_detections(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::radar::messages::Detection >*
      mutable_detections();
  private:
  const ::radar::messages::Detection& _internal_detections(int index) const;
  ::radar::messages::Detection* _internal_add_detections();
  public:
  const ::radar::messages::Detection& detections(int index) const;
  ::radar::messages::Detection* add_detections();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::radar::messages::Detection >&
      detections() const;

  // string processing_mode = 10;
  void clear_processing_mode();
  const std::string& processing_mode() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_processing_mode(ArgT0&& arg0, ArgT... args);
  std::string* mutable_processing_mode();
  PROTOBUF_NODISCARD std::string* release_processing_mode();
  void set_allocated_processing_mode(std::string* processing_mode);
  private:
  const std::string& _internal_processing_mode() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_processing_mode(const std::string& value);
  std::string* _internal_mutable_processing_mode();
  public:

  // .google.protobuf.Timestamp batch_timestamp = 2;
  bool has_batch_timestamp() const;
  private:
  bool _internal_has_batch_timestamp() const;
  public:
  void clear_batch_timestamp();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& batch_timestamp() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_batch_timestamp();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_batch_timestamp();
  void set_allocated_batch_timestamp(::PROTOBUF_NAMESPACE_ID::Timestamp* batch_timestamp);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_batch_timestamp() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_batch_timestamp();
  public:
  void unsafe_arena_set_allocated_batch_timestamp(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* batch_timestamp);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_batch_timestamp();

  // uint32 sensor_id = 3;
  void clear_sensor_id();
  uint32_t sensor_id() const;
  void set_sensor_id(uint32_t value);
  private:
  uint32_t _internal_sensor_id() const;
  void _internal_set_sensor_id(uint32_t value);
  public:

  // uint32 sequence_number = 4;
  void clear_sequence_number();
  uint32_t sequence_number() const;
  void set_sequence_number(uint32_t value);
  private:
  uint32_t _internal_sequence_number() const;
  void _internal_set_sequence_number(uint32_t value);
  public:

  // double scan_period = 5;
  void clear_scan_period();
  double scan_period() const;
  void set_scan_period(double value);
  private:
  double _internal_scan_period() const;
  void _internal_set_scan_period(double value);
  public:

  // double azimuth_start = 6;
  void clear_azimuth_start();
  double azimuth_start() const;
  void set_azimuth_start(double value);
  private:
  double _internal_azimuth_start() const;
  void _internal_set_azimuth_start(double value);
  public:

  // double azimuth_end = 7;
  void clear_azimuth_end();
  double azimuth_end() const;
  void set_azimuth_end(double value);
  private:
  double _internal_azimuth_end() const;
  void _internal_set_azimuth_end(double value);
  public:

  // double elevation_start = 8;
  void clear_elevation_start();
  double elevation_start() const;
  void set_elevation_start(double value);
  private:
  double _internal_elevation_start() const;
  void _internal_set_elevation_start(double value);
  public:

  // double elevation_end = 9;
  void clear_elevation_end();
  double elevation_end() const;
  void set_elevation_end(double value);
  private:
  double _internal_elevation_end() const;
  void _internal_set_elevation_end(double value);
  public:

  // double processing_time_ms = 11;
  void clear_processing_time_ms();
  double processing_time_ms() const;
  void set_processing_time_ms(double value);
  private:
  double _internal_processing_time_ms() const;
  void _internal_set_processing_time_ms(double value);
  public:

  // uint32 total_detections = 12;
  void clear_total_detections();
  uint32_t total_detections() const;
  void set_total_detections(uint32_t value);
  private:
  uint32_t _internal_total_detections() const;
  void _internal_set_total_detections(uint32_t value);
  public:

  // uint32 filtered_detections = 13;
  void clear_filtered_detections();
  uint32_t filtered_detections() const;
  void set_filtered_detections(uint32_t value);
  private:
  uint32_t _internal_filtered_detections() const;
  void _internal_set_filtered_detections(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:radar.messages.DetectionBatch)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::radar::messages::Detection > detections_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr processing_mode_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* batch_timestamp_;
    uint32_t sensor_id_;
    uint32_t sequence_number_;
    double scan_period_;
    double azimuth_start_;
    double azimuth_end_;
    double elevation_start_;
    double elevation_end_;
    double processing_time_ms_;
    uint32_t total_detections_;
    uint32_t filtered_detections_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_radar_5fmessages_2eproto;
};
// -------------------------------------------------------------------

class RadarStatus final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:radar.messages.RadarStatus) */ {
 public:
  inline RadarStatus() : RadarStatus(nullptr) {}
  ~RadarStatus() override;
  explicit PROTOBUF_CONSTEXPR RadarStatus(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RadarStatus(const RadarStatus& from);
  RadarStatus(RadarStatus&& from) noexcept
    : RadarStatus() {
    *this = ::std::move(from);
  }

  inline RadarStatus& operator=(const RadarStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline RadarStatus& operator=(RadarStatus&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RadarStatus& default_instance() {
    return *internal_default_instance();
  }
  static inline const RadarStatus* internal_default_instance() {
    return reinterpret_cast<const RadarStatus*>(
               &_RadarStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(RadarStatus& a, RadarStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(RadarStatus* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RadarStatus* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RadarStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RadarStatus>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RadarStatus& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RadarStatus& from) {
    RadarStatus::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RadarStatus* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "radar.messages.RadarStatus";
  }
  protected:
  explicit RadarStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kErrorsFieldNumber = 13,
    kWarningsFieldNumber = 14,
    kModeFieldNumber = 4,
    kTimestampFieldNumber = 2,
    kSensorIdFieldNumber = 1,
    kIsActiveFieldNumber = 3,
    kAntennaRotatingFieldNumber = 10,
    kCpuUsageFieldNumber = 5,
    kMemoryUsageMbFieldNumber = 6,
    kTemperatureCelsiusFieldNumber = 7,
    kTransmitPowerWattsFieldNumber = 8,
    kReceiverGainDbFieldNumber = 9,
    kCurrentAzimuthFieldNumber = 11,
    kCurrentElevationFieldNumber = 12,
  };
  // repeated string errors = 13;
  int errors_size() const;
  private:
  int _internal_errors_size() const;
  public:
  void clear_errors();
  const std::string& errors(int index) const;
  std::string* mutable_errors(int index);
  void set_errors(int index, const std::string& value);
  void set_errors(int index, std::string&& value);
  void set_errors(int index, const char* value);
  void set_errors(int index, const char* value, size_t size);
  std::string* add_errors();
  void add_errors(const std::string& value);
  void add_errors(std::string&& value);
  void add_errors(const char* value);
  void add_errors(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& errors() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_errors();
  private:
  const std::string& _internal_errors(int index) const;
  std::string* _internal_add_errors();
  public:

  // repeated string warnings = 14;
  int warnings_size() const;
  private:
  int _internal_warnings_size() const;
  public:
  void clear_warnings();
  const std::string& warnings(int index) const;
  std::string* mutable_warnings(int index);
  void set_warnings(int index, const std::string& value);
  void set_warnings(int index, std::string&& value);
  void set_warnings(int index, const char* value);
  void set_warnings(int index, const char* value, size_t size);
  std::string* add_warnings();
  void add_warnings(const std::string& value);
  void add_warnings(std::string&& value);
  void add_warnings(const char* value);
  void add_warnings(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& warnings() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_warnings();
  private:
  const std::string& _internal_warnings(int index) const;
  std::string* _internal_add_warnings();
  public:

  // string mode = 4;
  void clear_mode();
  const std::string& mode() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_mode(ArgT0&& arg0, ArgT... args);
  std::string* mutable_mode();
  PROTOBUF_NODISCARD std::string* release_mode();
  void set_allocated_mode(std::string* mode);
  private:
  const std::string& _internal_mode() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_mode(const std::string& value);
  std::string* _internal_mutable_mode();
  public:

  // .google.protobuf.Timestamp timestamp = 2;
  bool has_timestamp() const;
  private:
  bool _internal_has_timestamp() const;
  public:
  void clear_timestamp();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& timestamp() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_timestamp();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_timestamp();
  void set_allocated_timestamp(::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_timestamp() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_timestamp();
  public:
  void unsafe_arena_set_allocated_timestamp(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_timestamp();

  // uint32 sensor_id = 1;
  void clear_sensor_id();
  uint32_t sensor_id() const;
  void set_sensor_id(uint32_t value);
  private:
  uint32_t _internal_sensor_id() const;
  void _internal_set_sensor_id(uint32_t value);
  public:

  // bool is_active = 3;
  void clear_is_active();
  bool is_active() const;
  void set_is_active(bool value);
  private:
  bool _internal_is_active() const;
  void _internal_set_is_active(bool value);
  public:

  // bool antenna_rotating = 10;
  void clear_antenna_rotating();
  bool antenna_rotating() const;
  void set_antenna_rotating(bool value);
  private:
  bool _internal_antenna_rotating() const;
  void _internal_set_antenna_rotating(bool value);
  public:

  // double cpu_usage = 5;
  void clear_cpu_usage();
  double cpu_usage() const;
  void set_cpu_usage(double value);
  private:
  double _internal_cpu_usage() const;
  void _internal_set_cpu_usage(double value);
  public:

  // double memory_usage_mb = 6;
  void clear_memory_usage_mb();
  double memory_usage_mb() const;
  void set_memory_usage_mb(double value);
  private:
  double _internal_memory_usage_mb() const;
  void _internal_set_memory_usage_mb(double value);
  public:

  // double temperature_celsius = 7;
  void clear_temperature_celsius();
  double temperature_celsius() const;
  void set_temperature_celsius(double value);
  private:
  double _internal_temperature_celsius() const;
  void _internal_set_temperature_celsius(double value);
  public:

  // double transmit_power_watts = 8;
  void clear_transmit_power_watts();
  double transmit_power_watts() const;
  void set_transmit_power_watts(double value);
  private:
  double _internal_transmit_power_watts() const;
  void _internal_set_transmit_power_watts(double value);
  public:

  // double receiver_gain_db = 9;
  void clear_receiver_gain_db();
  double receiver_gain_db() const;
  void set_receiver_gain_db(double value);
  private:
  double _internal_receiver_gain_db() const;
  void _internal_set_receiver_gain_db(double value);
  public:

  // double current_azimuth = 11;
  void clear_current_azimuth();
  double current_azimuth() const;
  void set_current_azimuth(double value);
  private:
  double _internal_current_azimuth() const;
  void _internal_set_current_azimuth(double value);
  public:

  // double current_elevation = 12;
  void clear_current_elevation();
  double current_elevation() const;
  void set_current_elevation(double value);
  private:
  double _internal_current_elevation() const;
  void _internal_set_current_elevation(double value);
  public:

  // @@protoc_insertion_point(class_scope:radar.messages.RadarStatus)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> errors_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> warnings_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr mode_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp_;
    uint32_t sensor_id_;
    bool is_active_;
    bool antenna_rotating_;
    double cpu_usage_;
    double memory_usage_mb_;
    double temperature_celsius_;
    double transmit_power_watts_;
    double receiver_gain_db_;
    double current_azimuth_;
    double current_elevation_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_radar_5fmessages_2eproto;
};
// -------------------------------------------------------------------

class SignalProcessingConfig final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:radar.messages.SignalProcessingConfig) */ {
 public:
  inline SignalProcessingConfig() : SignalProcessingConfig(nullptr) {}
  ~SignalProcessingConfig() override;
  explicit PROTOBUF_CONSTEXPR SignalProcessingConfig(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SignalProcessingConfig(const SignalProcessingConfig& from);
  SignalProcessingConfig(SignalProcessingConfig&& from) noexcept
    : SignalProcessingConfig() {
    *this = ::std::move(from);
  }

  inline SignalProcessingConfig& operator=(const SignalProcessingConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline SignalProcessingConfig& operator=(SignalProcessingConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SignalProcessingConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const SignalProcessingConfig* internal_default_instance() {
    return reinterpret_cast<const SignalProcessingConfig*>(
               &_SignalProcessingConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(SignalProcessingConfig& a, SignalProcessingConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(SignalProcessingConfig* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SignalProcessingConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SignalProcessingConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SignalProcessingConfig>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SignalProcessingConfig& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SignalProcessingConfig& from) {
    SignalProcessingConfig::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SignalProcessingConfig* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "radar.messages.SignalProcessingConfig";
  }
  protected:
  explicit SignalProcessingConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDetectionThresholdDbFieldNumber = 2,
    kSensorIdFieldNumber = 1,
    kRangeGatesFieldNumber = 4,
    kFalseAlarmRateFieldNumber = 3,
    kRangeResolutionMFieldNumber = 6,
    kDopplerResolutionHzFieldNumber = 7,
    kDopplerBinsFieldNumber = 5,
    kCfarGuardCellsFieldNumber = 9,
    kCfarReferenceCellsFieldNumber = 10,
    kEnableCfarFieldNumber = 8,
    kOutputRawDetectionsFieldNumber = 11,
    kOutputClusteredDetectionsFieldNumber = 12,
    kMaxOutputRateHzFieldNumber = 13,
  };
  // double detection_threshold_db = 2;
  void clear_detection_threshold_db();
  double detection_threshold_db() const;
  void set_detection_threshold_db(double value);
  private:
  double _internal_detection_threshold_db() const;
  void _internal_set_detection_threshold_db(double value);
  public:

  // uint32 sensor_id = 1;
  void clear_sensor_id();
  uint32_t sensor_id() const;
  void set_sensor_id(uint32_t value);
  private:
  uint32_t _internal_sensor_id() const;
  void _internal_set_sensor_id(uint32_t value);
  public:

  // uint32 range_gates = 4;
  void clear_range_gates();
  uint32_t range_gates() const;
  void set_range_gates(uint32_t value);
  private:
  uint32_t _internal_range_gates() const;
  void _internal_set_range_gates(uint32_t value);
  public:

  // double false_alarm_rate = 3;
  void clear_false_alarm_rate();
  double false_alarm_rate() const;
  void set_false_alarm_rate(double value);
  private:
  double _internal_false_alarm_rate() const;
  void _internal_set_false_alarm_rate(double value);
  public:

  // double range_resolution_m = 6;
  void clear_range_resolution_m();
  double range_resolution_m() const;
  void set_range_resolution_m(double value);
  private:
  double _internal_range_resolution_m() const;
  void _internal_set_range_resolution_m(double value);
  public:

  // double doppler_resolution_hz = 7;
  void clear_doppler_resolution_hz();
  double doppler_resolution_hz() const;
  void set_doppler_resolution_hz(double value);
  private:
  double _internal_doppler_resolution_hz() const;
  void _internal_set_doppler_resolution_hz(double value);
  public:

  // uint32 doppler_bins = 5;
  void clear_doppler_bins();
  uint32_t doppler_bins() const;
  void set_doppler_bins(uint32_t value);
  private:
  uint32_t _internal_doppler_bins() const;
  void _internal_set_doppler_bins(uint32_t value);
  public:

  // uint32 cfar_guard_cells = 9;
  void clear_cfar_guard_cells();
  uint32_t cfar_guard_cells() const;
  void set_cfar_guard_cells(uint32_t value);
  private:
  uint32_t _internal_cfar_guard_cells() const;
  void _internal_set_cfar_guard_cells(uint32_t value);
  public:

  // uint32 cfar_reference_cells = 10;
  void clear_cfar_reference_cells();
  uint32_t cfar_reference_cells() const;
  void set_cfar_reference_cells(uint32_t value);
  private:
  uint32_t _internal_cfar_reference_cells() const;
  void _internal_set_cfar_reference_cells(uint32_t value);
  public:

  // bool enable_cfar = 8;
  void clear_enable_cfar();
  bool enable_cfar() const;
  void set_enable_cfar(bool value);
  private:
  bool _internal_enable_cfar() const;
  void _internal_set_enable_cfar(bool value);
  public:

  // bool output_raw_detections = 11;
  void clear_output_raw_detections();
  bool output_raw_detections() const;
  void set_output_raw_detections(bool value);
  private:
  bool _internal_output_raw_detections() const;
  void _internal_set_output_raw_detections(bool value);
  public:

  // bool output_clustered_detections = 12;
  void clear_output_clustered_detections();
  bool output_clustered_detections() const;
  void set_output_clustered_detections(bool value);
  private:
  bool _internal_output_clustered_detections() const;
  void _internal_set_output_clustered_detections(bool value);
  public:

  // double max_output_rate_hz = 13;
  void clear_max_output_rate_hz();
  double max_output_rate_hz() const;
  void set_max_output_rate_hz(double value);
  private:
  double _internal_max_output_rate_hz() const;
  void _internal_set_max_output_rate_hz(double value);
  public:

  // @@protoc_insertion_point(class_scope:radar.messages.SignalProcessingConfig)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    double detection_threshold_db_;
    uint32_t sensor_id_;
    uint32_t range_gates_;
    double false_alarm_rate_;
    double range_resolution_m_;
    double doppler_resolution_hz_;
    uint32_t doppler_bins_;
    uint32_t cfar_guard_cells_;
    uint32_t cfar_reference_cells_;
    bool enable_cfar_;
    bool output_raw_detections_;
    bool output_clustered_detections_;
    double max_output_rate_hz_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_radar_5fmessages_2eproto;
};
// -------------------------------------------------------------------

class RadarCommand_ParametersEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<RadarCommand_ParametersEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<RadarCommand_ParametersEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  RadarCommand_ParametersEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR RadarCommand_ParametersEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit RadarCommand_ParametersEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const RadarCommand_ParametersEntry_DoNotUse& other);
  static const RadarCommand_ParametersEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const RadarCommand_ParametersEntry_DoNotUse*>(&_RadarCommand_ParametersEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "radar.messages.RadarCommand.ParametersEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "radar.messages.RadarCommand.ParametersEntry.value");
 }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_radar_5fmessages_2eproto;
};

// -------------------------------------------------------------------

class RadarCommand final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:radar.messages.RadarCommand) */ {
 public:
  inline RadarCommand() : RadarCommand(nullptr) {}
  ~RadarCommand() override;
  explicit PROTOBUF_CONSTEXPR RadarCommand(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RadarCommand(const RadarCommand& from);
  RadarCommand(RadarCommand&& from) noexcept
    : RadarCommand() {
    *this = ::std::move(from);
  }

  inline RadarCommand& operator=(const RadarCommand& from) {
    CopyFrom(from);
    return *this;
  }
  inline RadarCommand& operator=(RadarCommand&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RadarCommand& default_instance() {
    return *internal_default_instance();
  }
  static inline const RadarCommand* internal_default_instance() {
    return reinterpret_cast<const RadarCommand*>(
               &_RadarCommand_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(RadarCommand& a, RadarCommand& b) {
    a.Swap(&b);
  }
  inline void Swap(RadarCommand* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RadarCommand* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RadarCommand* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RadarCommand>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RadarCommand& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RadarCommand& from) {
    RadarCommand::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RadarCommand* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "radar.messages.RadarCommand";
  }
  protected:
  explicit RadarCommand(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  typedef RadarCommand_CommandType CommandType;
  static constexpr CommandType COMMAND_TYPE_UNSPECIFIED =
    RadarCommand_CommandType_COMMAND_TYPE_UNSPECIFIED;
  static constexpr CommandType START_SCAN =
    RadarCommand_CommandType_START_SCAN;
  static constexpr CommandType STOP_SCAN =
    RadarCommand_CommandType_STOP_SCAN;
  static constexpr CommandType CHANGE_MODE =
    RadarCommand_CommandType_CHANGE_MODE;
  static constexpr CommandType UPDATE_CONFIG =
    RadarCommand_CommandType_UPDATE_CONFIG;
  static constexpr CommandType BEAM_REQUEST =
    RadarCommand_CommandType_BEAM_REQUEST;
  static constexpr CommandType RESET =
    RadarCommand_CommandType_RESET;
  static constexpr CommandType SHUTDOWN =
    RadarCommand_CommandType_SHUTDOWN;
  static inline bool CommandType_IsValid(int value) {
    return RadarCommand_CommandType_IsValid(value);
  }
  static constexpr CommandType CommandType_MIN =
    RadarCommand_CommandType_CommandType_MIN;
  static constexpr CommandType CommandType_MAX =
    RadarCommand_CommandType_CommandType_MAX;
  static constexpr int CommandType_ARRAYSIZE =
    RadarCommand_CommandType_CommandType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  CommandType_descriptor() {
    return RadarCommand_CommandType_descriptor();
  }
  template<typename T>
  static inline const std::string& CommandType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, CommandType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function CommandType_Name.");
    return RadarCommand_CommandType_Name(enum_t_value);
  }
  static inline bool CommandType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      CommandType* value) {
    return RadarCommand_CommandType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kParametersFieldNumber = 10,
    kTargetModeFieldNumber = 5,
    kTimestampFieldNumber = 2,
    kConfigUpdateFieldNumber = 9,
    kSensorIdFieldNumber = 1,
    kCommandIdFieldNumber = 3,
    kBeamAzimuthFieldNumber = 6,
    kBeamElevationFieldNumber = 7,
    kBeamDurationMsFieldNumber = 8,
    kCommandTypeFieldNumber = 4,
  };
  // map<string, string> parameters = 10;
  int parameters_size() const;
  private:
  int _internal_parameters_size() const;
  public:
  void clear_parameters();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_parameters() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_parameters();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      parameters() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_parameters();

  // string target_mode = 5;
  void clear_target_mode();
  const std::string& target_mode() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_target_mode(ArgT0&& arg0, ArgT... args);
  std::string* mutable_target_mode();
  PROTOBUF_NODISCARD std::string* release_target_mode();
  void set_allocated_target_mode(std::string* target_mode);
  private:
  const std::string& _internal_target_mode() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_target_mode(const std::string& value);
  std::string* _internal_mutable_target_mode();
  public:

  // .google.protobuf.Timestamp timestamp = 2;
  bool has_timestamp() const;
  private:
  bool _internal_has_timestamp() const;
  public:
  void clear_timestamp();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& timestamp() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_timestamp();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_timestamp();
  void set_allocated_timestamp(::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_timestamp() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_timestamp();
  public:
  void unsafe_arena_set_allocated_timestamp(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_timestamp();

  // .radar.messages.SignalProcessingConfig config_update = 9;
  bool has_config_update() const;
  private:
  bool _internal_has_config_update() const;
  public:
  void clear_config_update();
  const ::radar::messages::SignalProcessingConfig& config_update() const;
  PROTOBUF_NODISCARD ::radar::messages::SignalProcessingConfig* release_config_update();
  ::radar::messages::SignalProcessingConfig* mutable_config_update();
  void set_allocated_config_update(::radar::messages::SignalProcessingConfig* config_update);
  private:
  const ::radar::messages::SignalProcessingConfig& _internal_config_update() const;
  ::radar::messages::SignalProcessingConfig* _internal_mutable_config_update();
  public:
  void unsafe_arena_set_allocated_config_update(
      ::radar::messages::SignalProcessingConfig* config_update);
  ::radar::messages::SignalProcessingConfig* unsafe_arena_release_config_update();

  // uint32 sensor_id = 1;
  void clear_sensor_id();
  uint32_t sensor_id() const;
  void set_sensor_id(uint32_t value);
  private:
  uint32_t _internal_sensor_id() const;
  void _internal_set_sensor_id(uint32_t value);
  public:

  // uint32 command_id = 3;
  void clear_command_id();
  uint32_t command_id() const;
  void set_command_id(uint32_t value);
  private:
  uint32_t _internal_command_id() const;
  void _internal_set_command_id(uint32_t value);
  public:

  // double beam_azimuth = 6;
  void clear_beam_azimuth();
  double beam_azimuth() const;
  void set_beam_azimuth(double value);
  private:
  double _internal_beam_azimuth() const;
  void _internal_set_beam_azimuth(double value);
  public:

  // double beam_elevation = 7;
  void clear_beam_elevation();
  double beam_elevation() const;
  void set_beam_elevation(double value);
  private:
  double _internal_beam_elevation() const;
  void _internal_set_beam_elevation(double value);
  public:

  // double beam_duration_ms = 8;
  void clear_beam_duration_ms();
  double beam_duration_ms() const;
  void set_beam_duration_ms(double value);
  private:
  double _internal_beam_duration_ms() const;
  void _internal_set_beam_duration_ms(double value);
  public:

  // .radar.messages.RadarCommand.CommandType command_type = 4;
  void clear_command_type();
  ::radar::messages::RadarCommand_CommandType command_type() const;
  void set_command_type(::radar::messages::RadarCommand_CommandType value);
  private:
  ::radar::messages::RadarCommand_CommandType _internal_command_type() const;
  void _internal_set_command_type(::radar::messages::RadarCommand_CommandType value);
  public:

  // @@protoc_insertion_point(class_scope:radar.messages.RadarCommand)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        RadarCommand_ParametersEntry_DoNotUse,
        std::string, std::string,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> parameters_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr target_mode_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp_;
    ::radar::messages::SignalProcessingConfig* config_update_;
    uint32_t sensor_id_;
    uint32_t command_id_;
    double beam_azimuth_;
    double beam_elevation_;
    double beam_duration_ms_;
    int command_type_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_radar_5fmessages_2eproto;
};
// -------------------------------------------------------------------

class RadarCommandResponse_ResultDataEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<RadarCommandResponse_ResultDataEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<RadarCommandResponse_ResultDataEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  RadarCommandResponse_ResultDataEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR RadarCommandResponse_ResultDataEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit RadarCommandResponse_ResultDataEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const RadarCommandResponse_ResultDataEntry_DoNotUse& other);
  static const RadarCommandResponse_ResultDataEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const RadarCommandResponse_ResultDataEntry_DoNotUse*>(&_RadarCommandResponse_ResultDataEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "radar.messages.RadarCommandResponse.ResultDataEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "radar.messages.RadarCommandResponse.ResultDataEntry.value");
 }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_radar_5fmessages_2eproto;
};

// -------------------------------------------------------------------

class RadarCommandResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:radar.messages.RadarCommandResponse) */ {
 public:
  inline RadarCommandResponse() : RadarCommandResponse(nullptr) {}
  ~RadarCommandResponse() override;
  explicit PROTOBUF_CONSTEXPR RadarCommandResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RadarCommandResponse(const RadarCommandResponse& from);
  RadarCommandResponse(RadarCommandResponse&& from) noexcept
    : RadarCommandResponse() {
    *this = ::std::move(from);
  }

  inline RadarCommandResponse& operator=(const RadarCommandResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline RadarCommandResponse& operator=(RadarCommandResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RadarCommandResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const RadarCommandResponse* internal_default_instance() {
    return reinterpret_cast<const RadarCommandResponse*>(
               &_RadarCommandResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(RadarCommandResponse& a, RadarCommandResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(RadarCommandResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RadarCommandResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RadarCommandResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RadarCommandResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RadarCommandResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RadarCommandResponse& from) {
    RadarCommandResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RadarCommandResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "radar.messages.RadarCommandResponse";
  }
  protected:
  explicit RadarCommandResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  typedef RadarCommandResponse_ResponseStatus ResponseStatus;
  static constexpr ResponseStatus RESPONSE_STATUS_UNSPECIFIED =
    RadarCommandResponse_ResponseStatus_RESPONSE_STATUS_UNSPECIFIED;
  static constexpr ResponseStatus SUCCESS =
    RadarCommandResponse_ResponseStatus_SUCCESS;
  static constexpr ResponseStatus FAILURE =
    RadarCommandResponse_ResponseStatus_FAILURE;
  static constexpr ResponseStatus PARTIAL_SUCCESS =
    RadarCommandResponse_ResponseStatus_PARTIAL_SUCCESS;
  static constexpr ResponseStatus IN_PROGRESS =
    RadarCommandResponse_ResponseStatus_IN_PROGRESS;
  static inline bool ResponseStatus_IsValid(int value) {
    return RadarCommandResponse_ResponseStatus_IsValid(value);
  }
  static constexpr ResponseStatus ResponseStatus_MIN =
    RadarCommandResponse_ResponseStatus_ResponseStatus_MIN;
  static constexpr ResponseStatus ResponseStatus_MAX =
    RadarCommandResponse_ResponseStatus_ResponseStatus_MAX;
  static constexpr int ResponseStatus_ARRAYSIZE =
    RadarCommandResponse_ResponseStatus_ResponseStatus_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  ResponseStatus_descriptor() {
    return RadarCommandResponse_ResponseStatus_descriptor();
  }
  template<typename T>
  static inline const std::string& ResponseStatus_Name(T enum_t_value) {
    static_assert(::std::is_same<T, ResponseStatus>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function ResponseStatus_Name.");
    return RadarCommandResponse_ResponseStatus_Name(enum_t_value);
  }
  static inline bool ResponseStatus_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      ResponseStatus* value) {
    return RadarCommandResponse_ResponseStatus_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kResultDataFieldNumber = 7,
    kMessageFieldNumber = 5,
    kTimestampFieldNumber = 3,
    kSensorIdFieldNumber = 1,
    kCommandIdFieldNumber = 2,
    kExecutionTimeMsFieldNumber = 6,
    kStatusFieldNumber = 4,
  };
  // map<string, string> result_data = 7;
  int result_data_size() const;
  private:
  int _internal_result_data_size() const;
  public:
  void clear_result_data();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_result_data() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_result_data();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      result_data() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_result_data();

  // string message = 5;
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // .google.protobuf.Timestamp timestamp = 3;
  bool has_timestamp() const;
  private:
  bool _internal_has_timestamp() const;
  public:
  void clear_timestamp();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& timestamp() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_timestamp();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_timestamp();
  void set_allocated_timestamp(::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_timestamp() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_timestamp();
  public:
  void unsafe_arena_set_allocated_timestamp(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_timestamp();

  // uint32 sensor_id = 1;
  void clear_sensor_id();
  uint32_t sensor_id() const;
  void set_sensor_id(uint32_t value);
  private:
  uint32_t _internal_sensor_id() const;
  void _internal_set_sensor_id(uint32_t value);
  public:

  // uint32 command_id = 2;
  void clear_command_id();
  uint32_t command_id() const;
  void set_command_id(uint32_t value);
  private:
  uint32_t _internal_command_id() const;
  void _internal_set_command_id(uint32_t value);
  public:

  // double execution_time_ms = 6;
  void clear_execution_time_ms();
  double execution_time_ms() const;
  void set_execution_time_ms(double value);
  private:
  double _internal_execution_time_ms() const;
  void _internal_set_execution_time_ms(double value);
  public:

  // .radar.messages.RadarCommandResponse.ResponseStatus status = 4;
  void clear_status();
  ::radar::messages::RadarCommandResponse_ResponseStatus status() const;
  void set_status(::radar::messages::RadarCommandResponse_ResponseStatus value);
  private:
  ::radar::messages::RadarCommandResponse_ResponseStatus _internal_status() const;
  void _internal_set_status(::radar::messages::RadarCommandResponse_ResponseStatus value);
  public:

  // @@protoc_insertion_point(class_scope:radar.messages.RadarCommandResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        RadarCommandResponse_ResultDataEntry_DoNotUse,
        std::string, std::string,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> result_data_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp_;
    uint32_t sensor_id_;
    uint32_t command_id_;
    double execution_time_ms_;
    int status_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_radar_5fmessages_2eproto;
};
// -------------------------------------------------------------------

class PerformanceMetrics final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:radar.messages.PerformanceMetrics) */ {
 public:
  inline PerformanceMetrics() : PerformanceMetrics(nullptr) {}
  ~PerformanceMetrics() override;
  explicit PROTOBUF_CONSTEXPR PerformanceMetrics(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PerformanceMetrics(const PerformanceMetrics& from);
  PerformanceMetrics(PerformanceMetrics&& from) noexcept
    : PerformanceMetrics() {
    *this = ::std::move(from);
  }

  inline PerformanceMetrics& operator=(const PerformanceMetrics& from) {
    CopyFrom(from);
    return *this;
  }
  inline PerformanceMetrics& operator=(PerformanceMetrics&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PerformanceMetrics& default_instance() {
    return *internal_default_instance();
  }
  static inline const PerformanceMetrics* internal_default_instance() {
    return reinterpret_cast<const PerformanceMetrics*>(
               &_PerformanceMetrics_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(PerformanceMetrics& a, PerformanceMetrics& b) {
    a.Swap(&b);
  }
  inline void Swap(PerformanceMetrics* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PerformanceMetrics* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PerformanceMetrics* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PerformanceMetrics>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PerformanceMetrics& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PerformanceMetrics& from) {
    PerformanceMetrics::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PerformanceMetrics* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "radar.messages.PerformanceMetrics";
  }
  protected:
  explicit PerformanceMetrics(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTimestampFieldNumber = 1,
    kProcessingTimeMsFieldNumber = 3,
    kDetectionRateFieldNumber = 4,
    kSensorIdFieldNumber = 2,
    kActiveTracksFieldNumber = 6,
    kFalseAlarmRateFieldNumber = 5,
    kCpuUsageFieldNumber = 8,
    kMemoryUsageMbFieldNumber = 9,
    kInputLatencyMsFieldNumber = 10,
    kProcessingLatencyMsFieldNumber = 11,
    kOutputLatencyMsFieldNumber = 12,
    kTotalLatencyMsFieldNumber = 13,
    kTotalDetectionsFieldNumber = 7,
  };
  // .google.protobuf.Timestamp timestamp = 1;
  bool has_timestamp() const;
  private:
  bool _internal_has_timestamp() const;
  public:
  void clear_timestamp();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& timestamp() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_timestamp();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_timestamp();
  void set_allocated_timestamp(::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_timestamp() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_timestamp();
  public:
  void unsafe_arena_set_allocated_timestamp(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_timestamp();

  // double processing_time_ms = 3;
  void clear_processing_time_ms();
  double processing_time_ms() const;
  void set_processing_time_ms(double value);
  private:
  double _internal_processing_time_ms() const;
  void _internal_set_processing_time_ms(double value);
  public:

  // double detection_rate = 4;
  void clear_detection_rate();
  double detection_rate() const;
  void set_detection_rate(double value);
  private:
  double _internal_detection_rate() const;
  void _internal_set_detection_rate(double value);
  public:

  // uint32 sensor_id = 2;
  void clear_sensor_id();
  uint32_t sensor_id() const;
  void set_sensor_id(uint32_t value);
  private:
  uint32_t _internal_sensor_id() const;
  void _internal_set_sensor_id(uint32_t value);
  public:

  // uint32 active_tracks = 6;
  void clear_active_tracks();
  uint32_t active_tracks() const;
  void set_active_tracks(uint32_t value);
  private:
  uint32_t _internal_active_tracks() const;
  void _internal_set_active_tracks(uint32_t value);
  public:

  // double false_alarm_rate = 5;
  void clear_false_alarm_rate();
  double false_alarm_rate() const;
  void set_false_alarm_rate(double value);
  private:
  double _internal_false_alarm_rate() const;
  void _internal_set_false_alarm_rate(double value);
  public:

  // double cpu_usage = 8;
  void clear_cpu_usage();
  double cpu_usage() const;
  void set_cpu_usage(double value);
  private:
  double _internal_cpu_usage() const;
  void _internal_set_cpu_usage(double value);
  public:

  // double memory_usage_mb = 9;
  void clear_memory_usage_mb();
  double memory_usage_mb() const;
  void set_memory_usage_mb(double value);
  private:
  double _internal_memory_usage_mb() const;
  void _internal_set_memory_usage_mb(double value);
  public:

  // double input_latency_ms = 10;
  void clear_input_latency_ms();
  double input_latency_ms() const;
  void set_input_latency_ms(double value);
  private:
  double _internal_input_latency_ms() const;
  void _internal_set_input_latency_ms(double value);
  public:

  // double processing_latency_ms = 11;
  void clear_processing_latency_ms();
  double processing_latency_ms() const;
  void set_processing_latency_ms(double value);
  private:
  double _internal_processing_latency_ms() const;
  void _internal_set_processing_latency_ms(double value);
  public:

  // double output_latency_ms = 12;
  void clear_output_latency_ms();
  double output_latency_ms() const;
  void set_output_latency_ms(double value);
  private:
  double _internal_output_latency_ms() const;
  void _internal_set_output_latency_ms(double value);
  public:

  // double total_latency_ms = 13;
  void clear_total_latency_ms();
  double total_latency_ms() const;
  void set_total_latency_ms(double value);
  private:
  double _internal_total_latency_ms() const;
  void _internal_set_total_latency_ms(double value);
  public:

  // uint32 total_detections = 7;
  void clear_total_detections();
  uint32_t total_detections() const;
  void set_total_detections(uint32_t value);
  private:
  uint32_t _internal_total_detections() const;
  void _internal_set_total_detections(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:radar.messages.PerformanceMetrics)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp_;
    double processing_time_ms_;
    double detection_rate_;
    uint32_t sensor_id_;
    uint32_t active_tracks_;
    double false_alarm_rate_;
    double cpu_usage_;
    double memory_usage_mb_;
    double input_latency_ms_;
    double processing_latency_ms_;
    double output_latency_ms_;
    double total_latency_ms_;
    uint32_t total_detections_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_radar_5fmessages_2eproto;
};
// -------------------------------------------------------------------

class SystemHealth_ComponentHealthEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<SystemHealth_ComponentHealthEntry_DoNotUse, 
    std::string, ::radar::messages::SystemHealth_HealthStatus,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_ENUM> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<SystemHealth_ComponentHealthEntry_DoNotUse, 
    std::string, ::radar::messages::SystemHealth_HealthStatus,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_ENUM> SuperType;
  SystemHealth_ComponentHealthEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR SystemHealth_ComponentHealthEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit SystemHealth_ComponentHealthEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const SystemHealth_ComponentHealthEntry_DoNotUse& other);
  static const SystemHealth_ComponentHealthEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const SystemHealth_ComponentHealthEntry_DoNotUse*>(&_SystemHealth_ComponentHealthEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "radar.messages.SystemHealth.ComponentHealthEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_radar_5fmessages_2eproto;
};

// -------------------------------------------------------------------

class SystemHealth final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:radar.messages.SystemHealth) */ {
 public:
  inline SystemHealth() : SystemHealth(nullptr) {}
  ~SystemHealth() override;
  explicit PROTOBUF_CONSTEXPR SystemHealth(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SystemHealth(const SystemHealth& from);
  SystemHealth(SystemHealth&& from) noexcept
    : SystemHealth() {
    *this = ::std::move(from);
  }

  inline SystemHealth& operator=(const SystemHealth& from) {
    CopyFrom(from);
    return *this;
  }
  inline SystemHealth& operator=(SystemHealth&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SystemHealth& default_instance() {
    return *internal_default_instance();
  }
  static inline const SystemHealth* internal_default_instance() {
    return reinterpret_cast<const SystemHealth*>(
               &_SystemHealth_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(SystemHealth& a, SystemHealth& b) {
    a.Swap(&b);
  }
  inline void Swap(SystemHealth* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SystemHealth* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SystemHealth* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SystemHealth>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SystemHealth& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SystemHealth& from) {
    SystemHealth::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SystemHealth* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "radar.messages.SystemHealth";
  }
  protected:
  explicit SystemHealth(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  typedef SystemHealth_HealthStatus HealthStatus;
  static constexpr HealthStatus HEALTH_STATUS_UNSPECIFIED =
    SystemHealth_HealthStatus_HEALTH_STATUS_UNSPECIFIED;
  static constexpr HealthStatus HEALTHY =
    SystemHealth_HealthStatus_HEALTHY;
  static constexpr HealthStatus WARNING =
    SystemHealth_HealthStatus_WARNING;
  static constexpr HealthStatus ERROR =
    SystemHealth_HealthStatus_ERROR;
  static constexpr HealthStatus CRITICAL =
    SystemHealth_HealthStatus_CRITICAL;
  static inline bool HealthStatus_IsValid(int value) {
    return SystemHealth_HealthStatus_IsValid(value);
  }
  static constexpr HealthStatus HealthStatus_MIN =
    SystemHealth_HealthStatus_HealthStatus_MIN;
  static constexpr HealthStatus HealthStatus_MAX =
    SystemHealth_HealthStatus_HealthStatus_MAX;
  static constexpr int HealthStatus_ARRAYSIZE =
    SystemHealth_HealthStatus_HealthStatus_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  HealthStatus_descriptor() {
    return SystemHealth_HealthStatus_descriptor();
  }
  template<typename T>
  static inline const std::string& HealthStatus_Name(T enum_t_value) {
    static_assert(::std::is_same<T, HealthStatus>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function HealthStatus_Name.");
    return SystemHealth_HealthStatus_Name(enum_t_value);
  }
  static inline bool HealthStatus_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      HealthStatus* value) {
    return SystemHealth_HealthStatus_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kComponentHealthFieldNumber = 3,
    kRecentErrorsFieldNumber = 10,
    kRecentWarningsFieldNumber = 11,
    kTimestampFieldNumber = 1,
    kCpuUsagePercentFieldNumber = 4,
    kMemoryUsagePercentFieldNumber = 5,
    kOverallStatusFieldNumber = 2,
    kErrorCountLastHourFieldNumber = 8,
    kDiskUsagePercentFieldNumber = 6,
    kNetworkUsageMbpsFieldNumber = 7,
    kWarningCountLastHourFieldNumber = 9,
  };
  // map<string, .radar.messages.SystemHealth.HealthStatus> component_health = 3;
  int component_health_size() const;
  private:
  int _internal_component_health_size() const;
  public:
  void clear_component_health();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::radar::messages::SystemHealth_HealthStatus >&
      _internal_component_health() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::radar::messages::SystemHealth_HealthStatus >*
      _internal_mutable_component_health();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::radar::messages::SystemHealth_HealthStatus >&
      component_health() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::radar::messages::SystemHealth_HealthStatus >*
      mutable_component_health();

  // repeated string recent_errors = 10;
  int recent_errors_size() const;
  private:
  int _internal_recent_errors_size() const;
  public:
  void clear_recent_errors();
  const std::string& recent_errors(int index) const;
  std::string* mutable_recent_errors(int index);
  void set_recent_errors(int index, const std::string& value);
  void set_recent_errors(int index, std::string&& value);
  void set_recent_errors(int index, const char* value);
  void set_recent_errors(int index, const char* value, size_t size);
  std::string* add_recent_errors();
  void add_recent_errors(const std::string& value);
  void add_recent_errors(std::string&& value);
  void add_recent_errors(const char* value);
  void add_recent_errors(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& recent_errors() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_recent_errors();
  private:
  const std::string& _internal_recent_errors(int index) const;
  std::string* _internal_add_recent_errors();
  public:

  // repeated string recent_warnings = 11;
  int recent_warnings_size() const;
  private:
  int _internal_recent_warnings_size() const;
  public:
  void clear_recent_warnings();
  const std::string& recent_warnings(int index) const;
  std::string* mutable_recent_warnings(int index);
  void set_recent_warnings(int index, const std::string& value);
  void set_recent_warnings(int index, std::string&& value);
  void set_recent_warnings(int index, const char* value);
  void set_recent_warnings(int index, const char* value, size_t size);
  std::string* add_recent_warnings();
  void add_recent_warnings(const std::string& value);
  void add_recent_warnings(std::string&& value);
  void add_recent_warnings(const char* value);
  void add_recent_warnings(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& recent_warnings() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_recent_warnings();
  private:
  const std::string& _internal_recent_warnings(int index) const;
  std::string* _internal_add_recent_warnings();
  public:

  // .google.protobuf.Timestamp timestamp = 1;
  bool has_timestamp() const;
  private:
  bool _internal_has_timestamp() const;
  public:
  void clear_timestamp();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& timestamp() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_timestamp();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_timestamp();
  void set_allocated_timestamp(::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_timestamp() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_timestamp();
  public:
  void unsafe_arena_set_allocated_timestamp(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_timestamp();

  // double cpu_usage_percent = 4;
  void clear_cpu_usage_percent();
  double cpu_usage_percent() const;
  void set_cpu_usage_percent(double value);
  private:
  double _internal_cpu_usage_percent() const;
  void _internal_set_cpu_usage_percent(double value);
  public:

  // double memory_usage_percent = 5;
  void clear_memory_usage_percent();
  double memory_usage_percent() const;
  void set_memory_usage_percent(double value);
  private:
  double _internal_memory_usage_percent() const;
  void _internal_set_memory_usage_percent(double value);
  public:

  // .radar.messages.SystemHealth.HealthStatus overall_status = 2;
  void clear_overall_status();
  ::radar::messages::SystemHealth_HealthStatus overall_status() const;
  void set_overall_status(::radar::messages::SystemHealth_HealthStatus value);
  private:
  ::radar::messages::SystemHealth_HealthStatus _internal_overall_status() const;
  void _internal_set_overall_status(::radar::messages::SystemHealth_HealthStatus value);
  public:

  // uint32 error_count_last_hour = 8;
  void clear_error_count_last_hour();
  uint32_t error_count_last_hour() const;
  void set_error_count_last_hour(uint32_t value);
  private:
  uint32_t _internal_error_count_last_hour() const;
  void _internal_set_error_count_last_hour(uint32_t value);
  public:

  // double disk_usage_percent = 6;
  void clear_disk_usage_percent();
  double disk_usage_percent() const;
  void set_disk_usage_percent(double value);
  private:
  double _internal_disk_usage_percent() const;
  void _internal_set_disk_usage_percent(double value);
  public:

  // double network_usage_mbps = 7;
  void clear_network_usage_mbps();
  double network_usage_mbps() const;
  void set_network_usage_mbps(double value);
  private:
  double _internal_network_usage_mbps() const;
  void _internal_set_network_usage_mbps(double value);
  public:

  // uint32 warning_count_last_hour = 9;
  void clear_warning_count_last_hour();
  uint32_t warning_count_last_hour() const;
  void set_warning_count_last_hour(uint32_t value);
  private:
  uint32_t _internal_warning_count_last_hour() const;
  void _internal_set_warning_count_last_hour(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:radar.messages.SystemHealth)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        SystemHealth_ComponentHealthEntry_DoNotUse,
        std::string, ::radar::messages::SystemHealth_HealthStatus,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_ENUM> component_health_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> recent_errors_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> recent_warnings_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp_;
    double cpu_usage_percent_;
    double memory_usage_percent_;
    int overall_status_;
    uint32_t error_count_last_hour_;
    double disk_usage_percent_;
    double network_usage_mbps_;
    uint32_t warning_count_last_hour_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_radar_5fmessages_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Point3D

// double x = 1;
inline void Point3D::clear_x() {
  _impl_.x_ = 0;
}
inline double Point3D::_internal_x() const {
  return _impl_.x_;
}
inline double Point3D::x() const {
  // @@protoc_insertion_point(field_get:radar.messages.Point3D.x)
  return _internal_x();
}
inline void Point3D::_internal_set_x(double value) {
  
  _impl_.x_ = value;
}
inline void Point3D::set_x(double value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:radar.messages.Point3D.x)
}

// double y = 2;
inline void Point3D::clear_y() {
  _impl_.y_ = 0;
}
inline double Point3D::_internal_y() const {
  return _impl_.y_;
}
inline double Point3D::y() const {
  // @@protoc_insertion_point(field_get:radar.messages.Point3D.y)
  return _internal_y();
}
inline void Point3D::_internal_set_y(double value) {
  
  _impl_.y_ = value;
}
inline void Point3D::set_y(double value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:radar.messages.Point3D.y)
}

// double z = 3;
inline void Point3D::clear_z() {
  _impl_.z_ = 0;
}
inline double Point3D::_internal_z() const {
  return _impl_.z_;
}
inline double Point3D::z() const {
  // @@protoc_insertion_point(field_get:radar.messages.Point3D.z)
  return _internal_z();
}
inline void Point3D::_internal_set_z(double value) {
  
  _impl_.z_ = value;
}
inline void Point3D::set_z(double value) {
  _internal_set_z(value);
  // @@protoc_insertion_point(field_set:radar.messages.Point3D.z)
}

// -------------------------------------------------------------------

// Vector3D

// double x = 1;
inline void Vector3D::clear_x() {
  _impl_.x_ = 0;
}
inline double Vector3D::_internal_x() const {
  return _impl_.x_;
}
inline double Vector3D::x() const {
  // @@protoc_insertion_point(field_get:radar.messages.Vector3D.x)
  return _internal_x();
}
inline void Vector3D::_internal_set_x(double value) {
  
  _impl_.x_ = value;
}
inline void Vector3D::set_x(double value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:radar.messages.Vector3D.x)
}

// double y = 2;
inline void Vector3D::clear_y() {
  _impl_.y_ = 0;
}
inline double Vector3D::_internal_y() const {
  return _impl_.y_;
}
inline double Vector3D::y() const {
  // @@protoc_insertion_point(field_get:radar.messages.Vector3D.y)
  return _internal_y();
}
inline void Vector3D::_internal_set_y(double value) {
  
  _impl_.y_ = value;
}
inline void Vector3D::set_y(double value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:radar.messages.Vector3D.y)
}

// double z = 3;
inline void Vector3D::clear_z() {
  _impl_.z_ = 0;
}
inline double Vector3D::_internal_z() const {
  return _impl_.z_;
}
inline double Vector3D::z() const {
  // @@protoc_insertion_point(field_get:radar.messages.Vector3D.z)
  return _internal_z();
}
inline void Vector3D::_internal_set_z(double value) {
  
  _impl_.z_ = value;
}
inline void Vector3D::set_z(double value) {
  _internal_set_z(value);
  // @@protoc_insertion_point(field_set:radar.messages.Vector3D.z)
}

// -------------------------------------------------------------------

// Matrix3D

// repeated double data = 1;
inline int Matrix3D::_internal_data_size() const {
  return _impl_.data_.size();
}
inline int Matrix3D::data_size() const {
  return _internal_data_size();
}
inline void Matrix3D::clear_data() {
  _impl_.data_.Clear();
}
inline double Matrix3D::_internal_data(int index) const {
  return _impl_.data_.Get(index);
}
inline double Matrix3D::data(int index) const {
  // @@protoc_insertion_point(field_get:radar.messages.Matrix3D.data)
  return _internal_data(index);
}
inline void Matrix3D::set_data(int index, double value) {
  _impl_.data_.Set(index, value);
  // @@protoc_insertion_point(field_set:radar.messages.Matrix3D.data)
}
inline void Matrix3D::_internal_add_data(double value) {
  _impl_.data_.Add(value);
}
inline void Matrix3D::add_data(double value) {
  _internal_add_data(value);
  // @@protoc_insertion_point(field_add:radar.messages.Matrix3D.data)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
Matrix3D::_internal_data() const {
  return _impl_.data_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
Matrix3D::data() const {
  // @@protoc_insertion_point(field_list:radar.messages.Matrix3D.data)
  return _internal_data();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
Matrix3D::_internal_mutable_data() {
  return &_impl_.data_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
Matrix3D::mutable_data() {
  // @@protoc_insertion_point(field_mutable_list:radar.messages.Matrix3D.data)
  return _internal_mutable_data();
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// Detection

// uint32 id = 1;
inline void Detection::clear_id() {
  _impl_.id_ = 0u;
}
inline uint32_t Detection::_internal_id() const {
  return _impl_.id_;
}
inline uint32_t Detection::id() const {
  // @@protoc_insertion_point(field_get:radar.messages.Detection.id)
  return _internal_id();
}
inline void Detection::_internal_set_id(uint32_t value) {
  
  _impl_.id_ = value;
}
inline void Detection::set_id(uint32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:radar.messages.Detection.id)
}

// uint32 sensor_id = 2;
inline void Detection::clear_sensor_id() {
  _impl_.sensor_id_ = 0u;
}
inline uint32_t Detection::_internal_sensor_id() const {
  return _impl_.sensor_id_;
}
inline uint32_t Detection::sensor_id() const {
  // @@protoc_insertion_point(field_get:radar.messages.Detection.sensor_id)
  return _internal_sensor_id();
}
inline void Detection::_internal_set_sensor_id(uint32_t value) {
  
  _impl_.sensor_id_ = value;
}
inline void Detection::set_sensor_id(uint32_t value) {
  _internal_set_sensor_id(value);
  // @@protoc_insertion_point(field_set:radar.messages.Detection.sensor_id)
}

// .google.protobuf.Timestamp timestamp = 3;
inline bool Detection::_internal_has_timestamp() const {
  return this != internal_default_instance() && _impl_.timestamp_ != nullptr;
}
inline bool Detection::has_timestamp() const {
  return _internal_has_timestamp();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& Detection::_internal_timestamp() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.timestamp_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& Detection::timestamp() const {
  // @@protoc_insertion_point(field_get:radar.messages.Detection.timestamp)
  return _internal_timestamp();
}
inline void Detection::unsafe_arena_set_allocated_timestamp(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.timestamp_);
  }
  _impl_.timestamp_ = timestamp;
  if (timestamp) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:radar.messages.Detection.timestamp)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Detection::release_timestamp() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.timestamp_;
  _impl_.timestamp_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Detection::unsafe_arena_release_timestamp() {
  // @@protoc_insertion_point(field_release:radar.messages.Detection.timestamp)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.timestamp_;
  _impl_.timestamp_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Detection::_internal_mutable_timestamp() {
  
  if (_impl_.timestamp_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.timestamp_ = p;
  }
  return _impl_.timestamp_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Detection::mutable_timestamp() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_timestamp();
  // @@protoc_insertion_point(field_mutable:radar.messages.Detection.timestamp)
  return _msg;
}
inline void Detection::set_allocated_timestamp(::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.timestamp_);
  }
  if (timestamp) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(timestamp));
    if (message_arena != submessage_arena) {
      timestamp = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, timestamp, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.timestamp_ = timestamp;
  // @@protoc_insertion_point(field_set_allocated:radar.messages.Detection.timestamp)
}

// .radar.messages.Point3D position = 4;
inline bool Detection::_internal_has_position() const {
  return this != internal_default_instance() && _impl_.position_ != nullptr;
}
inline bool Detection::has_position() const {
  return _internal_has_position();
}
inline void Detection::clear_position() {
  if (GetArenaForAllocation() == nullptr && _impl_.position_ != nullptr) {
    delete _impl_.position_;
  }
  _impl_.position_ = nullptr;
}
inline const ::radar::messages::Point3D& Detection::_internal_position() const {
  const ::radar::messages::Point3D* p = _impl_.position_;
  return p != nullptr ? *p : reinterpret_cast<const ::radar::messages::Point3D&>(
      ::radar::messages::_Point3D_default_instance_);
}
inline const ::radar::messages::Point3D& Detection::position() const {
  // @@protoc_insertion_point(field_get:radar.messages.Detection.position)
  return _internal_position();
}
inline void Detection::unsafe_arena_set_allocated_position(
    ::radar::messages::Point3D* position) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.position_);
  }
  _impl_.position_ = position;
  if (position) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:radar.messages.Detection.position)
}
inline ::radar::messages::Point3D* Detection::release_position() {
  
  ::radar::messages::Point3D* temp = _impl_.position_;
  _impl_.position_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::radar::messages::Point3D* Detection::unsafe_arena_release_position() {
  // @@protoc_insertion_point(field_release:radar.messages.Detection.position)
  
  ::radar::messages::Point3D* temp = _impl_.position_;
  _impl_.position_ = nullptr;
  return temp;
}
inline ::radar::messages::Point3D* Detection::_internal_mutable_position() {
  
  if (_impl_.position_ == nullptr) {
    auto* p = CreateMaybeMessage<::radar::messages::Point3D>(GetArenaForAllocation());
    _impl_.position_ = p;
  }
  return _impl_.position_;
}
inline ::radar::messages::Point3D* Detection::mutable_position() {
  ::radar::messages::Point3D* _msg = _internal_mutable_position();
  // @@protoc_insertion_point(field_mutable:radar.messages.Detection.position)
  return _msg;
}
inline void Detection::set_allocated_position(::radar::messages::Point3D* position) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.position_;
  }
  if (position) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(position);
    if (message_arena != submessage_arena) {
      position = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, position, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.position_ = position;
  // @@protoc_insertion_point(field_set_allocated:radar.messages.Detection.position)
}

// .radar.messages.Matrix3D position_covariance = 5;
inline bool Detection::_internal_has_position_covariance() const {
  return this != internal_default_instance() && _impl_.position_covariance_ != nullptr;
}
inline bool Detection::has_position_covariance() const {
  return _internal_has_position_covariance();
}
inline void Detection::clear_position_covariance() {
  if (GetArenaForAllocation() == nullptr && _impl_.position_covariance_ != nullptr) {
    delete _impl_.position_covariance_;
  }
  _impl_.position_covariance_ = nullptr;
}
inline const ::radar::messages::Matrix3D& Detection::_internal_position_covariance() const {
  const ::radar::messages::Matrix3D* p = _impl_.position_covariance_;
  return p != nullptr ? *p : reinterpret_cast<const ::radar::messages::Matrix3D&>(
      ::radar::messages::_Matrix3D_default_instance_);
}
inline const ::radar::messages::Matrix3D& Detection::position_covariance() const {
  // @@protoc_insertion_point(field_get:radar.messages.Detection.position_covariance)
  return _internal_position_covariance();
}
inline void Detection::unsafe_arena_set_allocated_position_covariance(
    ::radar::messages::Matrix3D* position_covariance) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.position_covariance_);
  }
  _impl_.position_covariance_ = position_covariance;
  if (position_covariance) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:radar.messages.Detection.position_covariance)
}
inline ::radar::messages::Matrix3D* Detection::release_position_covariance() {
  
  ::radar::messages::Matrix3D* temp = _impl_.position_covariance_;
  _impl_.position_covariance_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::radar::messages::Matrix3D* Detection::unsafe_arena_release_position_covariance() {
  // @@protoc_insertion_point(field_release:radar.messages.Detection.position_covariance)
  
  ::radar::messages::Matrix3D* temp = _impl_.position_covariance_;
  _impl_.position_covariance_ = nullptr;
  return temp;
}
inline ::radar::messages::Matrix3D* Detection::_internal_mutable_position_covariance() {
  
  if (_impl_.position_covariance_ == nullptr) {
    auto* p = CreateMaybeMessage<::radar::messages::Matrix3D>(GetArenaForAllocation());
    _impl_.position_covariance_ = p;
  }
  return _impl_.position_covariance_;
}
inline ::radar::messages::Matrix3D* Detection::mutable_position_covariance() {
  ::radar::messages::Matrix3D* _msg = _internal_mutable_position_covariance();
  // @@protoc_insertion_point(field_mutable:radar.messages.Detection.position_covariance)
  return _msg;
}
inline void Detection::set_allocated_position_covariance(::radar::messages::Matrix3D* position_covariance) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.position_covariance_;
  }
  if (position_covariance) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(position_covariance);
    if (message_arena != submessage_arena) {
      position_covariance = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, position_covariance, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.position_covariance_ = position_covariance;
  // @@protoc_insertion_point(field_set_allocated:radar.messages.Detection.position_covariance)
}

// .radar.messages.Vector3D velocity = 6;
inline bool Detection::_internal_has_velocity() const {
  return this != internal_default_instance() && _impl_.velocity_ != nullptr;
}
inline bool Detection::has_velocity() const {
  return _internal_has_velocity();
}
inline void Detection::clear_velocity() {
  if (GetArenaForAllocation() == nullptr && _impl_.velocity_ != nullptr) {
    delete _impl_.velocity_;
  }
  _impl_.velocity_ = nullptr;
}
inline const ::radar::messages::Vector3D& Detection::_internal_velocity() const {
  const ::radar::messages::Vector3D* p = _impl_.velocity_;
  return p != nullptr ? *p : reinterpret_cast<const ::radar::messages::Vector3D&>(
      ::radar::messages::_Vector3D_default_instance_);
}
inline const ::radar::messages::Vector3D& Detection::velocity() const {
  // @@protoc_insertion_point(field_get:radar.messages.Detection.velocity)
  return _internal_velocity();
}
inline void Detection::unsafe_arena_set_allocated_velocity(
    ::radar::messages::Vector3D* velocity) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.velocity_);
  }
  _impl_.velocity_ = velocity;
  if (velocity) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:radar.messages.Detection.velocity)
}
inline ::radar::messages::Vector3D* Detection::release_velocity() {
  
  ::radar::messages::Vector3D* temp = _impl_.velocity_;
  _impl_.velocity_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::radar::messages::Vector3D* Detection::unsafe_arena_release_velocity() {
  // @@protoc_insertion_point(field_release:radar.messages.Detection.velocity)
  
  ::radar::messages::Vector3D* temp = _impl_.velocity_;
  _impl_.velocity_ = nullptr;
  return temp;
}
inline ::radar::messages::Vector3D* Detection::_internal_mutable_velocity() {
  
  if (_impl_.velocity_ == nullptr) {
    auto* p = CreateMaybeMessage<::radar::messages::Vector3D>(GetArenaForAllocation());
    _impl_.velocity_ = p;
  }
  return _impl_.velocity_;
}
inline ::radar::messages::Vector3D* Detection::mutable_velocity() {
  ::radar::messages::Vector3D* _msg = _internal_mutable_velocity();
  // @@protoc_insertion_point(field_mutable:radar.messages.Detection.velocity)
  return _msg;
}
inline void Detection::set_allocated_velocity(::radar::messages::Vector3D* velocity) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.velocity_;
  }
  if (velocity) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(velocity);
    if (message_arena != submessage_arena) {
      velocity = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, velocity, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.velocity_ = velocity;
  // @@protoc_insertion_point(field_set_allocated:radar.messages.Detection.velocity)
}

// .radar.messages.Matrix3D velocity_covariance = 7;
inline bool Detection::_internal_has_velocity_covariance() const {
  return this != internal_default_instance() && _impl_.velocity_covariance_ != nullptr;
}
inline bool Detection::has_velocity_covariance() const {
  return _internal_has_velocity_covariance();
}
inline void Detection::clear_velocity_covariance() {
  if (GetArenaForAllocation() == nullptr && _impl_.velocity_covariance_ != nullptr) {
    delete _impl_.velocity_covariance_;
  }
  _impl_.velocity_covariance_ = nullptr;
}
inline const ::radar::messages::Matrix3D& Detection::_internal_velocity_covariance() const {
  const ::radar::messages::Matrix3D* p = _impl_.velocity_covariance_;
  return p != nullptr ? *p : reinterpret_cast<const ::radar::messages::Matrix3D&>(
      ::radar::messages::_Matrix3D_default_instance_);
}
inline const ::radar::messages::Matrix3D& Detection::velocity_covariance() const {
  // @@protoc_insertion_point(field_get:radar.messages.Detection.velocity_covariance)
  return _internal_velocity_covariance();
}
inline void Detection::unsafe_arena_set_allocated_velocity_covariance(
    ::radar::messages::Matrix3D* velocity_covariance) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.velocity_covariance_);
  }
  _impl_.velocity_covariance_ = velocity_covariance;
  if (velocity_covariance) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:radar.messages.Detection.velocity_covariance)
}
inline ::radar::messages::Matrix3D* Detection::release_velocity_covariance() {
  
  ::radar::messages::Matrix3D* temp = _impl_.velocity_covariance_;
  _impl_.velocity_covariance_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::radar::messages::Matrix3D* Detection::unsafe_arena_release_velocity_covariance() {
  // @@protoc_insertion_point(field_release:radar.messages.Detection.velocity_covariance)
  
  ::radar::messages::Matrix3D* temp = _impl_.velocity_covariance_;
  _impl_.velocity_covariance_ = nullptr;
  return temp;
}
inline ::radar::messages::Matrix3D* Detection::_internal_mutable_velocity_covariance() {
  
  if (_impl_.velocity_covariance_ == nullptr) {
    auto* p = CreateMaybeMessage<::radar::messages::Matrix3D>(GetArenaForAllocation());
    _impl_.velocity_covariance_ = p;
  }
  return _impl_.velocity_covariance_;
}
inline ::radar::messages::Matrix3D* Detection::mutable_velocity_covariance() {
  ::radar::messages::Matrix3D* _msg = _internal_mutable_velocity_covariance();
  // @@protoc_insertion_point(field_mutable:radar.messages.Detection.velocity_covariance)
  return _msg;
}
inline void Detection::set_allocated_velocity_covariance(::radar::messages::Matrix3D* velocity_covariance) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.velocity_covariance_;
  }
  if (velocity_covariance) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(velocity_covariance);
    if (message_arena != submessage_arena) {
      velocity_covariance = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, velocity_covariance, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.velocity_covariance_ = velocity_covariance;
  // @@protoc_insertion_point(field_set_allocated:radar.messages.Detection.velocity_covariance)
}

// double snr = 8;
inline void Detection::clear_snr() {
  _impl_.snr_ = 0;
}
inline double Detection::_internal_snr() const {
  return _impl_.snr_;
}
inline double Detection::snr() const {
  // @@protoc_insertion_point(field_get:radar.messages.Detection.snr)
  return _internal_snr();
}
inline void Detection::_internal_set_snr(double value) {
  
  _impl_.snr_ = value;
}
inline void Detection::set_snr(double value) {
  _internal_set_snr(value);
  // @@protoc_insertion_point(field_set:radar.messages.Detection.snr)
}

// double amplitude = 9;
inline void Detection::clear_amplitude() {
  _impl_.amplitude_ = 0;
}
inline double Detection::_internal_amplitude() const {
  return _impl_.amplitude_;
}
inline double Detection::amplitude() const {
  // @@protoc_insertion_point(field_get:radar.messages.Detection.amplitude)
  return _internal_amplitude();
}
inline void Detection::_internal_set_amplitude(double value) {
  
  _impl_.amplitude_ = value;
}
inline void Detection::set_amplitude(double value) {
  _internal_set_amplitude(value);
  // @@protoc_insertion_point(field_set:radar.messages.Detection.amplitude)
}

// double doppler = 10;
inline void Detection::clear_doppler() {
  _impl_.doppler_ = 0;
}
inline double Detection::_internal_doppler() const {
  return _impl_.doppler_;
}
inline double Detection::doppler() const {
  // @@protoc_insertion_point(field_get:radar.messages.Detection.doppler)
  return _internal_doppler();
}
inline void Detection::_internal_set_doppler(double value) {
  
  _impl_.doppler_ = value;
}
inline void Detection::set_doppler(double value) {
  _internal_set_doppler(value);
  // @@protoc_insertion_point(field_set:radar.messages.Detection.doppler)
}

// .radar.messages.DetectionType type = 11;
inline void Detection::clear_type() {
  _impl_.type_ = 0;
}
inline ::radar::messages::DetectionType Detection::_internal_type() const {
  return static_cast< ::radar::messages::DetectionType >(_impl_.type_);
}
inline ::radar::messages::DetectionType Detection::type() const {
  // @@protoc_insertion_point(field_get:radar.messages.Detection.type)
  return _internal_type();
}
inline void Detection::_internal_set_type(::radar::messages::DetectionType value) {
  
  _impl_.type_ = value;
}
inline void Detection::set_type(::radar::messages::DetectionType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:radar.messages.Detection.type)
}

// .radar.messages.CoordinateSystem coord_system = 12;
inline void Detection::clear_coord_system() {
  _impl_.coord_system_ = 0;
}
inline ::radar::messages::CoordinateSystem Detection::_internal_coord_system() const {
  return static_cast< ::radar::messages::CoordinateSystem >(_impl_.coord_system_);
}
inline ::radar::messages::CoordinateSystem Detection::coord_system() const {
  // @@protoc_insertion_point(field_get:radar.messages.Detection.coord_system)
  return _internal_coord_system();
}
inline void Detection::_internal_set_coord_system(::radar::messages::CoordinateSystem value) {
  
  _impl_.coord_system_ = value;
}
inline void Detection::set_coord_system(::radar::messages::CoordinateSystem value) {
  _internal_set_coord_system(value);
  // @@protoc_insertion_point(field_set:radar.messages.Detection.coord_system)
}

// map<string, double> attributes = 13;
inline int Detection::_internal_attributes_size() const {
  return _impl_.attributes_.size();
}
inline int Detection::attributes_size() const {
  return _internal_attributes_size();
}
inline void Detection::clear_attributes() {
  _impl_.attributes_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >&
Detection::_internal_attributes() const {
  return _impl_.attributes_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >&
Detection::attributes() const {
  // @@protoc_insertion_point(field_map:radar.messages.Detection.attributes)
  return _internal_attributes();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >*
Detection::_internal_mutable_attributes() {
  return _impl_.attributes_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >*
Detection::mutable_attributes() {
  // @@protoc_insertion_point(field_mutable_map:radar.messages.Detection.attributes)
  return _internal_mutable_attributes();
}

// -------------------------------------------------------------------

// DetectionBatch

// repeated .radar.messages.Detection detections = 1;
inline int DetectionBatch::_internal_detections_size() const {
  return _impl_.detections_.size();
}
inline int DetectionBatch::detections_size() const {
  return _internal_detections_size();
}
inline void DetectionBatch::clear_detections() {
  _impl_.detections_.Clear();
}
inline ::radar::messages::Detection* DetectionBatch::mutable_detections(int index) {
  // @@protoc_insertion_point(field_mutable:radar.messages.DetectionBatch.detections)
  return _impl_.detections_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::radar::messages::Detection >*
DetectionBatch::mutable_detections() {
  // @@protoc_insertion_point(field_mutable_list:radar.messages.DetectionBatch.detections)
  return &_impl_.detections_;
}
inline const ::radar::messages::Detection& DetectionBatch::_internal_detections(int index) const {
  return _impl_.detections_.Get(index);
}
inline const ::radar::messages::Detection& DetectionBatch::detections(int index) const {
  // @@protoc_insertion_point(field_get:radar.messages.DetectionBatch.detections)
  return _internal_detections(index);
}
inline ::radar::messages::Detection* DetectionBatch::_internal_add_detections() {
  return _impl_.detections_.Add();
}
inline ::radar::messages::Detection* DetectionBatch::add_detections() {
  ::radar::messages::Detection* _add = _internal_add_detections();
  // @@protoc_insertion_point(field_add:radar.messages.DetectionBatch.detections)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::radar::messages::Detection >&
DetectionBatch::detections() const {
  // @@protoc_insertion_point(field_list:radar.messages.DetectionBatch.detections)
  return _impl_.detections_;
}

// .google.protobuf.Timestamp batch_timestamp = 2;
inline bool DetectionBatch::_internal_has_batch_timestamp() const {
  return this != internal_default_instance() && _impl_.batch_timestamp_ != nullptr;
}
inline bool DetectionBatch::has_batch_timestamp() const {
  return _internal_has_batch_timestamp();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& DetectionBatch::_internal_batch_timestamp() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.batch_timestamp_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& DetectionBatch::batch_timestamp() const {
  // @@protoc_insertion_point(field_get:radar.messages.DetectionBatch.batch_timestamp)
  return _internal_batch_timestamp();
}
inline void DetectionBatch::unsafe_arena_set_allocated_batch_timestamp(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* batch_timestamp) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.batch_timestamp_);
  }
  _impl_.batch_timestamp_ = batch_timestamp;
  if (batch_timestamp) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:radar.messages.DetectionBatch.batch_timestamp)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* DetectionBatch::release_batch_timestamp() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.batch_timestamp_;
  _impl_.batch_timestamp_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* DetectionBatch::unsafe_arena_release_batch_timestamp() {
  // @@protoc_insertion_point(field_release:radar.messages.DetectionBatch.batch_timestamp)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.batch_timestamp_;
  _impl_.batch_timestamp_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* DetectionBatch::_internal_mutable_batch_timestamp() {
  
  if (_impl_.batch_timestamp_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.batch_timestamp_ = p;
  }
  return _impl_.batch_timestamp_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* DetectionBatch::mutable_batch_timestamp() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_batch_timestamp();
  // @@protoc_insertion_point(field_mutable:radar.messages.DetectionBatch.batch_timestamp)
  return _msg;
}
inline void DetectionBatch::set_allocated_batch_timestamp(::PROTOBUF_NAMESPACE_ID::Timestamp* batch_timestamp) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.batch_timestamp_);
  }
  if (batch_timestamp) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(batch_timestamp));
    if (message_arena != submessage_arena) {
      batch_timestamp = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, batch_timestamp, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.batch_timestamp_ = batch_timestamp;
  // @@protoc_insertion_point(field_set_allocated:radar.messages.DetectionBatch.batch_timestamp)
}

// uint32 sensor_id = 3;
inline void DetectionBatch::clear_sensor_id() {
  _impl_.sensor_id_ = 0u;
}
inline uint32_t DetectionBatch::_internal_sensor_id() const {
  return _impl_.sensor_id_;
}
inline uint32_t DetectionBatch::sensor_id() const {
  // @@protoc_insertion_point(field_get:radar.messages.DetectionBatch.sensor_id)
  return _internal_sensor_id();
}
inline void DetectionBatch::_internal_set_sensor_id(uint32_t value) {
  
  _impl_.sensor_id_ = value;
}
inline void DetectionBatch::set_sensor_id(uint32_t value) {
  _internal_set_sensor_id(value);
  // @@protoc_insertion_point(field_set:radar.messages.DetectionBatch.sensor_id)
}

// uint32 sequence_number = 4;
inline void DetectionBatch::clear_sequence_number() {
  _impl_.sequence_number_ = 0u;
}
inline uint32_t DetectionBatch::_internal_sequence_number() const {
  return _impl_.sequence_number_;
}
inline uint32_t DetectionBatch::sequence_number() const {
  // @@protoc_insertion_point(field_get:radar.messages.DetectionBatch.sequence_number)
  return _internal_sequence_number();
}
inline void DetectionBatch::_internal_set_sequence_number(uint32_t value) {
  
  _impl_.sequence_number_ = value;
}
inline void DetectionBatch::set_sequence_number(uint32_t value) {
  _internal_set_sequence_number(value);
  // @@protoc_insertion_point(field_set:radar.messages.DetectionBatch.sequence_number)
}

// double scan_period = 5;
inline void DetectionBatch::clear_scan_period() {
  _impl_.scan_period_ = 0;
}
inline double DetectionBatch::_internal_scan_period() const {
  return _impl_.scan_period_;
}
inline double DetectionBatch::scan_period() const {
  // @@protoc_insertion_point(field_get:radar.messages.DetectionBatch.scan_period)
  return _internal_scan_period();
}
inline void DetectionBatch::_internal_set_scan_period(double value) {
  
  _impl_.scan_period_ = value;
}
inline void DetectionBatch::set_scan_period(double value) {
  _internal_set_scan_period(value);
  // @@protoc_insertion_point(field_set:radar.messages.DetectionBatch.scan_period)
}

// double azimuth_start = 6;
inline void DetectionBatch::clear_azimuth_start() {
  _impl_.azimuth_start_ = 0;
}
inline double DetectionBatch::_internal_azimuth_start() const {
  return _impl_.azimuth_start_;
}
inline double DetectionBatch::azimuth_start() const {
  // @@protoc_insertion_point(field_get:radar.messages.DetectionBatch.azimuth_start)
  return _internal_azimuth_start();
}
inline void DetectionBatch::_internal_set_azimuth_start(double value) {
  
  _impl_.azimuth_start_ = value;
}
inline void DetectionBatch::set_azimuth_start(double value) {
  _internal_set_azimuth_start(value);
  // @@protoc_insertion_point(field_set:radar.messages.DetectionBatch.azimuth_start)
}

// double azimuth_end = 7;
inline void DetectionBatch::clear_azimuth_end() {
  _impl_.azimuth_end_ = 0;
}
inline double DetectionBatch::_internal_azimuth_end() const {
  return _impl_.azimuth_end_;
}
inline double DetectionBatch::azimuth_end() const {
  // @@protoc_insertion_point(field_get:radar.messages.DetectionBatch.azimuth_end)
  return _internal_azimuth_end();
}
inline void DetectionBatch::_internal_set_azimuth_end(double value) {
  
  _impl_.azimuth_end_ = value;
}
inline void DetectionBatch::set_azimuth_end(double value) {
  _internal_set_azimuth_end(value);
  // @@protoc_insertion_point(field_set:radar.messages.DetectionBatch.azimuth_end)
}

// double elevation_start = 8;
inline void DetectionBatch::clear_elevation_start() {
  _impl_.elevation_start_ = 0;
}
inline double DetectionBatch::_internal_elevation_start() const {
  return _impl_.elevation_start_;
}
inline double DetectionBatch::elevation_start() const {
  // @@protoc_insertion_point(field_get:radar.messages.DetectionBatch.elevation_start)
  return _internal_elevation_start();
}
inline void DetectionBatch::_internal_set_elevation_start(double value) {
  
  _impl_.elevation_start_ = value;
}
inline void DetectionBatch::set_elevation_start(double value) {
  _internal_set_elevation_start(value);
  // @@protoc_insertion_point(field_set:radar.messages.DetectionBatch.elevation_start)
}

// double elevation_end = 9;
inline void DetectionBatch::clear_elevation_end() {
  _impl_.elevation_end_ = 0;
}
inline double DetectionBatch::_internal_elevation_end() const {
  return _impl_.elevation_end_;
}
inline double DetectionBatch::elevation_end() const {
  // @@protoc_insertion_point(field_get:radar.messages.DetectionBatch.elevation_end)
  return _internal_elevation_end();
}
inline void DetectionBatch::_internal_set_elevation_end(double value) {
  
  _impl_.elevation_end_ = value;
}
inline void DetectionBatch::set_elevation_end(double value) {
  _internal_set_elevation_end(value);
  // @@protoc_insertion_point(field_set:radar.messages.DetectionBatch.elevation_end)
}

// string processing_mode = 10;
inline void DetectionBatch::clear_processing_mode() {
  _impl_.processing_mode_.ClearToEmpty();
}
inline const std::string& DetectionBatch::processing_mode() const {
  // @@protoc_insertion_point(field_get:radar.messages.DetectionBatch.processing_mode)
  return _internal_processing_mode();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DetectionBatch::set_processing_mode(ArgT0&& arg0, ArgT... args) {
 
 _impl_.processing_mode_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:radar.messages.DetectionBatch.processing_mode)
}
inline std::string* DetectionBatch::mutable_processing_mode() {
  std::string* _s = _internal_mutable_processing_mode();
  // @@protoc_insertion_point(field_mutable:radar.messages.DetectionBatch.processing_mode)
  return _s;
}
inline const std::string& DetectionBatch::_internal_processing_mode() const {
  return _impl_.processing_mode_.Get();
}
inline void DetectionBatch::_internal_set_processing_mode(const std::string& value) {
  
  _impl_.processing_mode_.Set(value, GetArenaForAllocation());
}
inline std::string* DetectionBatch::_internal_mutable_processing_mode() {
  
  return _impl_.processing_mode_.Mutable(GetArenaForAllocation());
}
inline std::string* DetectionBatch::release_processing_mode() {
  // @@protoc_insertion_point(field_release:radar.messages.DetectionBatch.processing_mode)
  return _impl_.processing_mode_.Release();
}
inline void DetectionBatch::set_allocated_processing_mode(std::string* processing_mode) {
  if (processing_mode != nullptr) {
    
  } else {
    
  }
  _impl_.processing_mode_.SetAllocated(processing_mode, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.processing_mode_.IsDefault()) {
    _impl_.processing_mode_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:radar.messages.DetectionBatch.processing_mode)
}

// double processing_time_ms = 11;
inline void DetectionBatch::clear_processing_time_ms() {
  _impl_.processing_time_ms_ = 0;
}
inline double DetectionBatch::_internal_processing_time_ms() const {
  return _impl_.processing_time_ms_;
}
inline double DetectionBatch::processing_time_ms() const {
  // @@protoc_insertion_point(field_get:radar.messages.DetectionBatch.processing_time_ms)
  return _internal_processing_time_ms();
}
inline void DetectionBatch::_internal_set_processing_time_ms(double value) {
  
  _impl_.processing_time_ms_ = value;
}
inline void DetectionBatch::set_processing_time_ms(double value) {
  _internal_set_processing_time_ms(value);
  // @@protoc_insertion_point(field_set:radar.messages.DetectionBatch.processing_time_ms)
}

// uint32 total_detections = 12;
inline void DetectionBatch::clear_total_detections() {
  _impl_.total_detections_ = 0u;
}
inline uint32_t DetectionBatch::_internal_total_detections() const {
  return _impl_.total_detections_;
}
inline uint32_t DetectionBatch::total_detections() const {
  // @@protoc_insertion_point(field_get:radar.messages.DetectionBatch.total_detections)
  return _internal_total_detections();
}
inline void DetectionBatch::_internal_set_total_detections(uint32_t value) {
  
  _impl_.total_detections_ = value;
}
inline void DetectionBatch::set_total_detections(uint32_t value) {
  _internal_set_total_detections(value);
  // @@protoc_insertion_point(field_set:radar.messages.DetectionBatch.total_detections)
}

// uint32 filtered_detections = 13;
inline void DetectionBatch::clear_filtered_detections() {
  _impl_.filtered_detections_ = 0u;
}
inline uint32_t DetectionBatch::_internal_filtered_detections() const {
  return _impl_.filtered_detections_;
}
inline uint32_t DetectionBatch::filtered_detections() const {
  // @@protoc_insertion_point(field_get:radar.messages.DetectionBatch.filtered_detections)
  return _internal_filtered_detections();
}
inline void DetectionBatch::_internal_set_filtered_detections(uint32_t value) {
  
  _impl_.filtered_detections_ = value;
}
inline void DetectionBatch::set_filtered_detections(uint32_t value) {
  _internal_set_filtered_detections(value);
  // @@protoc_insertion_point(field_set:radar.messages.DetectionBatch.filtered_detections)
}

// -------------------------------------------------------------------

// RadarStatus

// uint32 sensor_id = 1;
inline void RadarStatus::clear_sensor_id() {
  _impl_.sensor_id_ = 0u;
}
inline uint32_t RadarStatus::_internal_sensor_id() const {
  return _impl_.sensor_id_;
}
inline uint32_t RadarStatus::sensor_id() const {
  // @@protoc_insertion_point(field_get:radar.messages.RadarStatus.sensor_id)
  return _internal_sensor_id();
}
inline void RadarStatus::_internal_set_sensor_id(uint32_t value) {
  
  _impl_.sensor_id_ = value;
}
inline void RadarStatus::set_sensor_id(uint32_t value) {
  _internal_set_sensor_id(value);
  // @@protoc_insertion_point(field_set:radar.messages.RadarStatus.sensor_id)
}

// .google.protobuf.Timestamp timestamp = 2;
inline bool RadarStatus::_internal_has_timestamp() const {
  return this != internal_default_instance() && _impl_.timestamp_ != nullptr;
}
inline bool RadarStatus::has_timestamp() const {
  return _internal_has_timestamp();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& RadarStatus::_internal_timestamp() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.timestamp_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& RadarStatus::timestamp() const {
  // @@protoc_insertion_point(field_get:radar.messages.RadarStatus.timestamp)
  return _internal_timestamp();
}
inline void RadarStatus::unsafe_arena_set_allocated_timestamp(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.timestamp_);
  }
  _impl_.timestamp_ = timestamp;
  if (timestamp) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:radar.messages.RadarStatus.timestamp)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* RadarStatus::release_timestamp() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.timestamp_;
  _impl_.timestamp_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* RadarStatus::unsafe_arena_release_timestamp() {
  // @@protoc_insertion_point(field_release:radar.messages.RadarStatus.timestamp)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.timestamp_;
  _impl_.timestamp_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* RadarStatus::_internal_mutable_timestamp() {
  
  if (_impl_.timestamp_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.timestamp_ = p;
  }
  return _impl_.timestamp_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* RadarStatus::mutable_timestamp() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_timestamp();
  // @@protoc_insertion_point(field_mutable:radar.messages.RadarStatus.timestamp)
  return _msg;
}
inline void RadarStatus::set_allocated_timestamp(::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.timestamp_);
  }
  if (timestamp) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(timestamp));
    if (message_arena != submessage_arena) {
      timestamp = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, timestamp, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.timestamp_ = timestamp;
  // @@protoc_insertion_point(field_set_allocated:radar.messages.RadarStatus.timestamp)
}

// bool is_active = 3;
inline void RadarStatus::clear_is_active() {
  _impl_.is_active_ = false;
}
inline bool RadarStatus::_internal_is_active() const {
  return _impl_.is_active_;
}
inline bool RadarStatus::is_active() const {
  // @@protoc_insertion_point(field_get:radar.messages.RadarStatus.is_active)
  return _internal_is_active();
}
inline void RadarStatus::_internal_set_is_active(bool value) {
  
  _impl_.is_active_ = value;
}
inline void RadarStatus::set_is_active(bool value) {
  _internal_set_is_active(value);
  // @@protoc_insertion_point(field_set:radar.messages.RadarStatus.is_active)
}

// string mode = 4;
inline void RadarStatus::clear_mode() {
  _impl_.mode_.ClearToEmpty();
}
inline const std::string& RadarStatus::mode() const {
  // @@protoc_insertion_point(field_get:radar.messages.RadarStatus.mode)
  return _internal_mode();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RadarStatus::set_mode(ArgT0&& arg0, ArgT... args) {
 
 _impl_.mode_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:radar.messages.RadarStatus.mode)
}
inline std::string* RadarStatus::mutable_mode() {
  std::string* _s = _internal_mutable_mode();
  // @@protoc_insertion_point(field_mutable:radar.messages.RadarStatus.mode)
  return _s;
}
inline const std::string& RadarStatus::_internal_mode() const {
  return _impl_.mode_.Get();
}
inline void RadarStatus::_internal_set_mode(const std::string& value) {
  
  _impl_.mode_.Set(value, GetArenaForAllocation());
}
inline std::string* RadarStatus::_internal_mutable_mode() {
  
  return _impl_.mode_.Mutable(GetArenaForAllocation());
}
inline std::string* RadarStatus::release_mode() {
  // @@protoc_insertion_point(field_release:radar.messages.RadarStatus.mode)
  return _impl_.mode_.Release();
}
inline void RadarStatus::set_allocated_mode(std::string* mode) {
  if (mode != nullptr) {
    
  } else {
    
  }
  _impl_.mode_.SetAllocated(mode, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.mode_.IsDefault()) {
    _impl_.mode_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:radar.messages.RadarStatus.mode)
}

// double cpu_usage = 5;
inline void RadarStatus::clear_cpu_usage() {
  _impl_.cpu_usage_ = 0;
}
inline double RadarStatus::_internal_cpu_usage() const {
  return _impl_.cpu_usage_;
}
inline double RadarStatus::cpu_usage() const {
  // @@protoc_insertion_point(field_get:radar.messages.RadarStatus.cpu_usage)
  return _internal_cpu_usage();
}
inline void RadarStatus::_internal_set_cpu_usage(double value) {
  
  _impl_.cpu_usage_ = value;
}
inline void RadarStatus::set_cpu_usage(double value) {
  _internal_set_cpu_usage(value);
  // @@protoc_insertion_point(field_set:radar.messages.RadarStatus.cpu_usage)
}

// double memory_usage_mb = 6;
inline void RadarStatus::clear_memory_usage_mb() {
  _impl_.memory_usage_mb_ = 0;
}
inline double RadarStatus::_internal_memory_usage_mb() const {
  return _impl_.memory_usage_mb_;
}
inline double RadarStatus::memory_usage_mb() const {
  // @@protoc_insertion_point(field_get:radar.messages.RadarStatus.memory_usage_mb)
  return _internal_memory_usage_mb();
}
inline void RadarStatus::_internal_set_memory_usage_mb(double value) {
  
  _impl_.memory_usage_mb_ = value;
}
inline void RadarStatus::set_memory_usage_mb(double value) {
  _internal_set_memory_usage_mb(value);
  // @@protoc_insertion_point(field_set:radar.messages.RadarStatus.memory_usage_mb)
}

// double temperature_celsius = 7;
inline void RadarStatus::clear_temperature_celsius() {
  _impl_.temperature_celsius_ = 0;
}
inline double RadarStatus::_internal_temperature_celsius() const {
  return _impl_.temperature_celsius_;
}
inline double RadarStatus::temperature_celsius() const {
  // @@protoc_insertion_point(field_get:radar.messages.RadarStatus.temperature_celsius)
  return _internal_temperature_celsius();
}
inline void RadarStatus::_internal_set_temperature_celsius(double value) {
  
  _impl_.temperature_celsius_ = value;
}
inline void RadarStatus::set_temperature_celsius(double value) {
  _internal_set_temperature_celsius(value);
  // @@protoc_insertion_point(field_set:radar.messages.RadarStatus.temperature_celsius)
}

// double transmit_power_watts = 8;
inline void RadarStatus::clear_transmit_power_watts() {
  _impl_.transmit_power_watts_ = 0;
}
inline double RadarStatus::_internal_transmit_power_watts() const {
  return _impl_.transmit_power_watts_;
}
inline double RadarStatus::transmit_power_watts() const {
  // @@protoc_insertion_point(field_get:radar.messages.RadarStatus.transmit_power_watts)
  return _internal_transmit_power_watts();
}
inline void RadarStatus::_internal_set_transmit_power_watts(double value) {
  
  _impl_.transmit_power_watts_ = value;
}
inline void RadarStatus::set_transmit_power_watts(double value) {
  _internal_set_transmit_power_watts(value);
  // @@protoc_insertion_point(field_set:radar.messages.RadarStatus.transmit_power_watts)
}

// double receiver_gain_db = 9;
inline void RadarStatus::clear_receiver_gain_db() {
  _impl_.receiver_gain_db_ = 0;
}
inline double RadarStatus::_internal_receiver_gain_db() const {
  return _impl_.receiver_gain_db_;
}
inline double RadarStatus::receiver_gain_db() const {
  // @@protoc_insertion_point(field_get:radar.messages.RadarStatus.receiver_gain_db)
  return _internal_receiver_gain_db();
}
inline void RadarStatus::_internal_set_receiver_gain_db(double value) {
  
  _impl_.receiver_gain_db_ = value;
}
inline void RadarStatus::set_receiver_gain_db(double value) {
  _internal_set_receiver_gain_db(value);
  // @@protoc_insertion_point(field_set:radar.messages.RadarStatus.receiver_gain_db)
}

// bool antenna_rotating = 10;
inline void RadarStatus::clear_antenna_rotating() {
  _impl_.antenna_rotating_ = false;
}
inline bool RadarStatus::_internal_antenna_rotating() const {
  return _impl_.antenna_rotating_;
}
inline bool RadarStatus::antenna_rotating() const {
  // @@protoc_insertion_point(field_get:radar.messages.RadarStatus.antenna_rotating)
  return _internal_antenna_rotating();
}
inline void RadarStatus::_internal_set_antenna_rotating(bool value) {
  
  _impl_.antenna_rotating_ = value;
}
inline void RadarStatus::set_antenna_rotating(bool value) {
  _internal_set_antenna_rotating(value);
  // @@protoc_insertion_point(field_set:radar.messages.RadarStatus.antenna_rotating)
}

// double current_azimuth = 11;
inline void RadarStatus::clear_current_azimuth() {
  _impl_.current_azimuth_ = 0;
}
inline double RadarStatus::_internal_current_azimuth() const {
  return _impl_.current_azimuth_;
}
inline double RadarStatus::current_azimuth() const {
  // @@protoc_insertion_point(field_get:radar.messages.RadarStatus.current_azimuth)
  return _internal_current_azimuth();
}
inline void RadarStatus::_internal_set_current_azimuth(double value) {
  
  _impl_.current_azimuth_ = value;
}
inline void RadarStatus::set_current_azimuth(double value) {
  _internal_set_current_azimuth(value);
  // @@protoc_insertion_point(field_set:radar.messages.RadarStatus.current_azimuth)
}

// double current_elevation = 12;
inline void RadarStatus::clear_current_elevation() {
  _impl_.current_elevation_ = 0;
}
inline double RadarStatus::_internal_current_elevation() const {
  return _impl_.current_elevation_;
}
inline double RadarStatus::current_elevation() const {
  // @@protoc_insertion_point(field_get:radar.messages.RadarStatus.current_elevation)
  return _internal_current_elevation();
}
inline void RadarStatus::_internal_set_current_elevation(double value) {
  
  _impl_.current_elevation_ = value;
}
inline void RadarStatus::set_current_elevation(double value) {
  _internal_set_current_elevation(value);
  // @@protoc_insertion_point(field_set:radar.messages.RadarStatus.current_elevation)
}

// repeated string errors = 13;
inline int RadarStatus::_internal_errors_size() const {
  return _impl_.errors_.size();
}
inline int RadarStatus::errors_size() const {
  return _internal_errors_size();
}
inline void RadarStatus::clear_errors() {
  _impl_.errors_.Clear();
}
inline std::string* RadarStatus::add_errors() {
  std::string* _s = _internal_add_errors();
  // @@protoc_insertion_point(field_add_mutable:radar.messages.RadarStatus.errors)
  return _s;
}
inline const std::string& RadarStatus::_internal_errors(int index) const {
  return _impl_.errors_.Get(index);
}
inline const std::string& RadarStatus::errors(int index) const {
  // @@protoc_insertion_point(field_get:radar.messages.RadarStatus.errors)
  return _internal_errors(index);
}
inline std::string* RadarStatus::mutable_errors(int index) {
  // @@protoc_insertion_point(field_mutable:radar.messages.RadarStatus.errors)
  return _impl_.errors_.Mutable(index);
}
inline void RadarStatus::set_errors(int index, const std::string& value) {
  _impl_.errors_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:radar.messages.RadarStatus.errors)
}
inline void RadarStatus::set_errors(int index, std::string&& value) {
  _impl_.errors_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:radar.messages.RadarStatus.errors)
}
inline void RadarStatus::set_errors(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.errors_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:radar.messages.RadarStatus.errors)
}
inline void RadarStatus::set_errors(int index, const char* value, size_t size) {
  _impl_.errors_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:radar.messages.RadarStatus.errors)
}
inline std::string* RadarStatus::_internal_add_errors() {
  return _impl_.errors_.Add();
}
inline void RadarStatus::add_errors(const std::string& value) {
  _impl_.errors_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:radar.messages.RadarStatus.errors)
}
inline void RadarStatus::add_errors(std::string&& value) {
  _impl_.errors_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:radar.messages.RadarStatus.errors)
}
inline void RadarStatus::add_errors(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.errors_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:radar.messages.RadarStatus.errors)
}
inline void RadarStatus::add_errors(const char* value, size_t size) {
  _impl_.errors_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:radar.messages.RadarStatus.errors)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
RadarStatus::errors() const {
  // @@protoc_insertion_point(field_list:radar.messages.RadarStatus.errors)
  return _impl_.errors_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
RadarStatus::mutable_errors() {
  // @@protoc_insertion_point(field_mutable_list:radar.messages.RadarStatus.errors)
  return &_impl_.errors_;
}

// repeated string warnings = 14;
inline int RadarStatus::_internal_warnings_size() const {
  return _impl_.warnings_.size();
}
inline int RadarStatus::warnings_size() const {
  return _internal_warnings_size();
}
inline void RadarStatus::clear_warnings() {
  _impl_.warnings_.Clear();
}
inline std::string* RadarStatus::add_warnings() {
  std::string* _s = _internal_add_warnings();
  // @@protoc_insertion_point(field_add_mutable:radar.messages.RadarStatus.warnings)
  return _s;
}
inline const std::string& RadarStatus::_internal_warnings(int index) const {
  return _impl_.warnings_.Get(index);
}
inline const std::string& RadarStatus::warnings(int index) const {
  // @@protoc_insertion_point(field_get:radar.messages.RadarStatus.warnings)
  return _internal_warnings(index);
}
inline std::string* RadarStatus::mutable_warnings(int index) {
  // @@protoc_insertion_point(field_mutable:radar.messages.RadarStatus.warnings)
  return _impl_.warnings_.Mutable(index);
}
inline void RadarStatus::set_warnings(int index, const std::string& value) {
  _impl_.warnings_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:radar.messages.RadarStatus.warnings)
}
inline void RadarStatus::set_warnings(int index, std::string&& value) {
  _impl_.warnings_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:radar.messages.RadarStatus.warnings)
}
inline void RadarStatus::set_warnings(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.warnings_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:radar.messages.RadarStatus.warnings)
}
inline void RadarStatus::set_warnings(int index, const char* value, size_t size) {
  _impl_.warnings_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:radar.messages.RadarStatus.warnings)
}
inline std::string* RadarStatus::_internal_add_warnings() {
  return _impl_.warnings_.Add();
}
inline void RadarStatus::add_warnings(const std::string& value) {
  _impl_.warnings_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:radar.messages.RadarStatus.warnings)
}
inline void RadarStatus::add_warnings(std::string&& value) {
  _impl_.warnings_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:radar.messages.RadarStatus.warnings)
}
inline void RadarStatus::add_warnings(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.warnings_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:radar.messages.RadarStatus.warnings)
}
inline void RadarStatus::add_warnings(const char* value, size_t size) {
  _impl_.warnings_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:radar.messages.RadarStatus.warnings)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
RadarStatus::warnings() const {
  // @@protoc_insertion_point(field_list:radar.messages.RadarStatus.warnings)
  return _impl_.warnings_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
RadarStatus::mutable_warnings() {
  // @@protoc_insertion_point(field_mutable_list:radar.messages.RadarStatus.warnings)
  return &_impl_.warnings_;
}

// -------------------------------------------------------------------

// SignalProcessingConfig

// uint32 sensor_id = 1;
inline void SignalProcessingConfig::clear_sensor_id() {
  _impl_.sensor_id_ = 0u;
}
inline uint32_t SignalProcessingConfig::_internal_sensor_id() const {
  return _impl_.sensor_id_;
}
inline uint32_t SignalProcessingConfig::sensor_id() const {
  // @@protoc_insertion_point(field_get:radar.messages.SignalProcessingConfig.sensor_id)
  return _internal_sensor_id();
}
inline void SignalProcessingConfig::_internal_set_sensor_id(uint32_t value) {
  
  _impl_.sensor_id_ = value;
}
inline void SignalProcessingConfig::set_sensor_id(uint32_t value) {
  _internal_set_sensor_id(value);
  // @@protoc_insertion_point(field_set:radar.messages.SignalProcessingConfig.sensor_id)
}

// double detection_threshold_db = 2;
inline void SignalProcessingConfig::clear_detection_threshold_db() {
  _impl_.detection_threshold_db_ = 0;
}
inline double SignalProcessingConfig::_internal_detection_threshold_db() const {
  return _impl_.detection_threshold_db_;
}
inline double SignalProcessingConfig::detection_threshold_db() const {
  // @@protoc_insertion_point(field_get:radar.messages.SignalProcessingConfig.detection_threshold_db)
  return _internal_detection_threshold_db();
}
inline void SignalProcessingConfig::_internal_set_detection_threshold_db(double value) {
  
  _impl_.detection_threshold_db_ = value;
}
inline void SignalProcessingConfig::set_detection_threshold_db(double value) {
  _internal_set_detection_threshold_db(value);
  // @@protoc_insertion_point(field_set:radar.messages.SignalProcessingConfig.detection_threshold_db)
}

// double false_alarm_rate = 3;
inline void SignalProcessingConfig::clear_false_alarm_rate() {
  _impl_.false_alarm_rate_ = 0;
}
inline double SignalProcessingConfig::_internal_false_alarm_rate() const {
  return _impl_.false_alarm_rate_;
}
inline double SignalProcessingConfig::false_alarm_rate() const {
  // @@protoc_insertion_point(field_get:radar.messages.SignalProcessingConfig.false_alarm_rate)
  return _internal_false_alarm_rate();
}
inline void SignalProcessingConfig::_internal_set_false_alarm_rate(double value) {
  
  _impl_.false_alarm_rate_ = value;
}
inline void SignalProcessingConfig::set_false_alarm_rate(double value) {
  _internal_set_false_alarm_rate(value);
  // @@protoc_insertion_point(field_set:radar.messages.SignalProcessingConfig.false_alarm_rate)
}

// uint32 range_gates = 4;
inline void SignalProcessingConfig::clear_range_gates() {
  _impl_.range_gates_ = 0u;
}
inline uint32_t SignalProcessingConfig::_internal_range_gates() const {
  return _impl_.range_gates_;
}
inline uint32_t SignalProcessingConfig::range_gates() const {
  // @@protoc_insertion_point(field_get:radar.messages.SignalProcessingConfig.range_gates)
  return _internal_range_gates();
}
inline void SignalProcessingConfig::_internal_set_range_gates(uint32_t value) {
  
  _impl_.range_gates_ = value;
}
inline void SignalProcessingConfig::set_range_gates(uint32_t value) {
  _internal_set_range_gates(value);
  // @@protoc_insertion_point(field_set:radar.messages.SignalProcessingConfig.range_gates)
}

// uint32 doppler_bins = 5;
inline void SignalProcessingConfig::clear_doppler_bins() {
  _impl_.doppler_bins_ = 0u;
}
inline uint32_t SignalProcessingConfig::_internal_doppler_bins() const {
  return _impl_.doppler_bins_;
}
inline uint32_t SignalProcessingConfig::doppler_bins() const {
  // @@protoc_insertion_point(field_get:radar.messages.SignalProcessingConfig.doppler_bins)
  return _internal_doppler_bins();
}
inline void SignalProcessingConfig::_internal_set_doppler_bins(uint32_t value) {
  
  _impl_.doppler_bins_ = value;
}
inline void SignalProcessingConfig::set_doppler_bins(uint32_t value) {
  _internal_set_doppler_bins(value);
  // @@protoc_insertion_point(field_set:radar.messages.SignalProcessingConfig.doppler_bins)
}

// double range_resolution_m = 6;
inline void SignalProcessingConfig::clear_range_resolution_m() {
  _impl_.range_resolution_m_ = 0;
}
inline double SignalProcessingConfig::_internal_range_resolution_m() const {
  return _impl_.range_resolution_m_;
}
inline double SignalProcessingConfig::range_resolution_m() const {
  // @@protoc_insertion_point(field_get:radar.messages.SignalProcessingConfig.range_resolution_m)
  return _internal_range_resolution_m();
}
inline void SignalProcessingConfig::_internal_set_range_resolution_m(double value) {
  
  _impl_.range_resolution_m_ = value;
}
inline void SignalProcessingConfig::set_range_resolution_m(double value) {
  _internal_set_range_resolution_m(value);
  // @@protoc_insertion_point(field_set:radar.messages.SignalProcessingConfig.range_resolution_m)
}

// double doppler_resolution_hz = 7;
inline void SignalProcessingConfig::clear_doppler_resolution_hz() {
  _impl_.doppler_resolution_hz_ = 0;
}
inline double SignalProcessingConfig::_internal_doppler_resolution_hz() const {
  return _impl_.doppler_resolution_hz_;
}
inline double SignalProcessingConfig::doppler_resolution_hz() const {
  // @@protoc_insertion_point(field_get:radar.messages.SignalProcessingConfig.doppler_resolution_hz)
  return _internal_doppler_resolution_hz();
}
inline void SignalProcessingConfig::_internal_set_doppler_resolution_hz(double value) {
  
  _impl_.doppler_resolution_hz_ = value;
}
inline void SignalProcessingConfig::set_doppler_resolution_hz(double value) {
  _internal_set_doppler_resolution_hz(value);
  // @@protoc_insertion_point(field_set:radar.messages.SignalProcessingConfig.doppler_resolution_hz)
}

// bool enable_cfar = 8;
inline void SignalProcessingConfig::clear_enable_cfar() {
  _impl_.enable_cfar_ = false;
}
inline bool SignalProcessingConfig::_internal_enable_cfar() const {
  return _impl_.enable_cfar_;
}
inline bool SignalProcessingConfig::enable_cfar() const {
  // @@protoc_insertion_point(field_get:radar.messages.SignalProcessingConfig.enable_cfar)
  return _internal_enable_cfar();
}
inline void SignalProcessingConfig::_internal_set_enable_cfar(bool value) {
  
  _impl_.enable_cfar_ = value;
}
inline void SignalProcessingConfig::set_enable_cfar(bool value) {
  _internal_set_enable_cfar(value);
  // @@protoc_insertion_point(field_set:radar.messages.SignalProcessingConfig.enable_cfar)
}

// uint32 cfar_guard_cells = 9;
inline void SignalProcessingConfig::clear_cfar_guard_cells() {
  _impl_.cfar_guard_cells_ = 0u;
}
inline uint32_t SignalProcessingConfig::_internal_cfar_guard_cells() const {
  return _impl_.cfar_guard_cells_;
}
inline uint32_t SignalProcessingConfig::cfar_guard_cells() const {
  // @@protoc_insertion_point(field_get:radar.messages.SignalProcessingConfig.cfar_guard_cells)
  return _internal_cfar_guard_cells();
}
inline void SignalProcessingConfig::_internal_set_cfar_guard_cells(uint32_t value) {
  
  _impl_.cfar_guard_cells_ = value;
}
inline void SignalProcessingConfig::set_cfar_guard_cells(uint32_t value) {
  _internal_set_cfar_guard_cells(value);
  // @@protoc_insertion_point(field_set:radar.messages.SignalProcessingConfig.cfar_guard_cells)
}

// uint32 cfar_reference_cells = 10;
inline void SignalProcessingConfig::clear_cfar_reference_cells() {
  _impl_.cfar_reference_cells_ = 0u;
}
inline uint32_t SignalProcessingConfig::_internal_cfar_reference_cells() const {
  return _impl_.cfar_reference_cells_;
}
inline uint32_t SignalProcessingConfig::cfar_reference_cells() const {
  // @@protoc_insertion_point(field_get:radar.messages.SignalProcessingConfig.cfar_reference_cells)
  return _internal_cfar_reference_cells();
}
inline void SignalProcessingConfig::_internal_set_cfar_reference_cells(uint32_t value) {
  
  _impl_.cfar_reference_cells_ = value;
}
inline void SignalProcessingConfig::set_cfar_reference_cells(uint32_t value) {
  _internal_set_cfar_reference_cells(value);
  // @@protoc_insertion_point(field_set:radar.messages.SignalProcessingConfig.cfar_reference_cells)
}

// bool output_raw_detections = 11;
inline void SignalProcessingConfig::clear_output_raw_detections() {
  _impl_.output_raw_detections_ = false;
}
inline bool SignalProcessingConfig::_internal_output_raw_detections() const {
  return _impl_.output_raw_detections_;
}
inline bool SignalProcessingConfig::output_raw_detections() const {
  // @@protoc_insertion_point(field_get:radar.messages.SignalProcessingConfig.output_raw_detections)
  return _internal_output_raw_detections();
}
inline void SignalProcessingConfig::_internal_set_output_raw_detections(bool value) {
  
  _impl_.output_raw_detections_ = value;
}
inline void SignalProcessingConfig::set_output_raw_detections(bool value) {
  _internal_set_output_raw_detections(value);
  // @@protoc_insertion_point(field_set:radar.messages.SignalProcessingConfig.output_raw_detections)
}

// bool output_clustered_detections = 12;
inline void SignalProcessingConfig::clear_output_clustered_detections() {
  _impl_.output_clustered_detections_ = false;
}
inline bool SignalProcessingConfig::_internal_output_clustered_detections() const {
  return _impl_.output_clustered_detections_;
}
inline bool SignalProcessingConfig::output_clustered_detections() const {
  // @@protoc_insertion_point(field_get:radar.messages.SignalProcessingConfig.output_clustered_detections)
  return _internal_output_clustered_detections();
}
inline void SignalProcessingConfig::_internal_set_output_clustered_detections(bool value) {
  
  _impl_.output_clustered_detections_ = value;
}
inline void SignalProcessingConfig::set_output_clustered_detections(bool value) {
  _internal_set_output_clustered_detections(value);
  // @@protoc_insertion_point(field_set:radar.messages.SignalProcessingConfig.output_clustered_detections)
}

// double max_output_rate_hz = 13;
inline void SignalProcessingConfig::clear_max_output_rate_hz() {
  _impl_.max_output_rate_hz_ = 0;
}
inline double SignalProcessingConfig::_internal_max_output_rate_hz() const {
  return _impl_.max_output_rate_hz_;
}
inline double SignalProcessingConfig::max_output_rate_hz() const {
  // @@protoc_insertion_point(field_get:radar.messages.SignalProcessingConfig.max_output_rate_hz)
  return _internal_max_output_rate_hz();
}
inline void SignalProcessingConfig::_internal_set_max_output_rate_hz(double value) {
  
  _impl_.max_output_rate_hz_ = value;
}
inline void SignalProcessingConfig::set_max_output_rate_hz(double value) {
  _internal_set_max_output_rate_hz(value);
  // @@protoc_insertion_point(field_set:radar.messages.SignalProcessingConfig.max_output_rate_hz)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// RadarCommand

// uint32 sensor_id = 1;
inline void RadarCommand::clear_sensor_id() {
  _impl_.sensor_id_ = 0u;
}
inline uint32_t RadarCommand::_internal_sensor_id() const {
  return _impl_.sensor_id_;
}
inline uint32_t RadarCommand::sensor_id() const {
  // @@protoc_insertion_point(field_get:radar.messages.RadarCommand.sensor_id)
  return _internal_sensor_id();
}
inline void RadarCommand::_internal_set_sensor_id(uint32_t value) {
  
  _impl_.sensor_id_ = value;
}
inline void RadarCommand::set_sensor_id(uint32_t value) {
  _internal_set_sensor_id(value);
  // @@protoc_insertion_point(field_set:radar.messages.RadarCommand.sensor_id)
}

// .google.protobuf.Timestamp timestamp = 2;
inline bool RadarCommand::_internal_has_timestamp() const {
  return this != internal_default_instance() && _impl_.timestamp_ != nullptr;
}
inline bool RadarCommand::has_timestamp() const {
  return _internal_has_timestamp();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& RadarCommand::_internal_timestamp() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.timestamp_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& RadarCommand::timestamp() const {
  // @@protoc_insertion_point(field_get:radar.messages.RadarCommand.timestamp)
  return _internal_timestamp();
}
inline void RadarCommand::unsafe_arena_set_allocated_timestamp(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.timestamp_);
  }
  _impl_.timestamp_ = timestamp;
  if (timestamp) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:radar.messages.RadarCommand.timestamp)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* RadarCommand::release_timestamp() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.timestamp_;
  _impl_.timestamp_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* RadarCommand::unsafe_arena_release_timestamp() {
  // @@protoc_insertion_point(field_release:radar.messages.RadarCommand.timestamp)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.timestamp_;
  _impl_.timestamp_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* RadarCommand::_internal_mutable_timestamp() {
  
  if (_impl_.timestamp_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.timestamp_ = p;
  }
  return _impl_.timestamp_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* RadarCommand::mutable_timestamp() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_timestamp();
  // @@protoc_insertion_point(field_mutable:radar.messages.RadarCommand.timestamp)
  return _msg;
}
inline void RadarCommand::set_allocated_timestamp(::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.timestamp_);
  }
  if (timestamp) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(timestamp));
    if (message_arena != submessage_arena) {
      timestamp = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, timestamp, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.timestamp_ = timestamp;
  // @@protoc_insertion_point(field_set_allocated:radar.messages.RadarCommand.timestamp)
}

// uint32 command_id = 3;
inline void RadarCommand::clear_command_id() {
  _impl_.command_id_ = 0u;
}
inline uint32_t RadarCommand::_internal_command_id() const {
  return _impl_.command_id_;
}
inline uint32_t RadarCommand::command_id() const {
  // @@protoc_insertion_point(field_get:radar.messages.RadarCommand.command_id)
  return _internal_command_id();
}
inline void RadarCommand::_internal_set_command_id(uint32_t value) {
  
  _impl_.command_id_ = value;
}
inline void RadarCommand::set_command_id(uint32_t value) {
  _internal_set_command_id(value);
  // @@protoc_insertion_point(field_set:radar.messages.RadarCommand.command_id)
}

// .radar.messages.RadarCommand.CommandType command_type = 4;
inline void RadarCommand::clear_command_type() {
  _impl_.command_type_ = 0;
}
inline ::radar::messages::RadarCommand_CommandType RadarCommand::_internal_command_type() const {
  return static_cast< ::radar::messages::RadarCommand_CommandType >(_impl_.command_type_);
}
inline ::radar::messages::RadarCommand_CommandType RadarCommand::command_type() const {
  // @@protoc_insertion_point(field_get:radar.messages.RadarCommand.command_type)
  return _internal_command_type();
}
inline void RadarCommand::_internal_set_command_type(::radar::messages::RadarCommand_CommandType value) {
  
  _impl_.command_type_ = value;
}
inline void RadarCommand::set_command_type(::radar::messages::RadarCommand_CommandType value) {
  _internal_set_command_type(value);
  // @@protoc_insertion_point(field_set:radar.messages.RadarCommand.command_type)
}

// string target_mode = 5;
inline void RadarCommand::clear_target_mode() {
  _impl_.target_mode_.ClearToEmpty();
}
inline const std::string& RadarCommand::target_mode() const {
  // @@protoc_insertion_point(field_get:radar.messages.RadarCommand.target_mode)
  return _internal_target_mode();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RadarCommand::set_target_mode(ArgT0&& arg0, ArgT... args) {
 
 _impl_.target_mode_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:radar.messages.RadarCommand.target_mode)
}
inline std::string* RadarCommand::mutable_target_mode() {
  std::string* _s = _internal_mutable_target_mode();
  // @@protoc_insertion_point(field_mutable:radar.messages.RadarCommand.target_mode)
  return _s;
}
inline const std::string& RadarCommand::_internal_target_mode() const {
  return _impl_.target_mode_.Get();
}
inline void RadarCommand::_internal_set_target_mode(const std::string& value) {
  
  _impl_.target_mode_.Set(value, GetArenaForAllocation());
}
inline std::string* RadarCommand::_internal_mutable_target_mode() {
  
  return _impl_.target_mode_.Mutable(GetArenaForAllocation());
}
inline std::string* RadarCommand::release_target_mode() {
  // @@protoc_insertion_point(field_release:radar.messages.RadarCommand.target_mode)
  return _impl_.target_mode_.Release();
}
inline void RadarCommand::set_allocated_target_mode(std::string* target_mode) {
  if (target_mode != nullptr) {
    
  } else {
    
  }
  _impl_.target_mode_.SetAllocated(target_mode, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.target_mode_.IsDefault()) {
    _impl_.target_mode_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:radar.messages.RadarCommand.target_mode)
}

// double beam_azimuth = 6;
inline void RadarCommand::clear_beam_azimuth() {
  _impl_.beam_azimuth_ = 0;
}
inline double RadarCommand::_internal_beam_azimuth() const {
  return _impl_.beam_azimuth_;
}
inline double RadarCommand::beam_azimuth() const {
  // @@protoc_insertion_point(field_get:radar.messages.RadarCommand.beam_azimuth)
  return _internal_beam_azimuth();
}
inline void RadarCommand::_internal_set_beam_azimuth(double value) {
  
  _impl_.beam_azimuth_ = value;
}
inline void RadarCommand::set_beam_azimuth(double value) {
  _internal_set_beam_azimuth(value);
  // @@protoc_insertion_point(field_set:radar.messages.RadarCommand.beam_azimuth)
}

// double beam_elevation = 7;
inline void RadarCommand::clear_beam_elevation() {
  _impl_.beam_elevation_ = 0;
}
inline double RadarCommand::_internal_beam_elevation() const {
  return _impl_.beam_elevation_;
}
inline double RadarCommand::beam_elevation() const {
  // @@protoc_insertion_point(field_get:radar.messages.RadarCommand.beam_elevation)
  return _internal_beam_elevation();
}
inline void RadarCommand::_internal_set_beam_elevation(double value) {
  
  _impl_.beam_elevation_ = value;
}
inline void RadarCommand::set_beam_elevation(double value) {
  _internal_set_beam_elevation(value);
  // @@protoc_insertion_point(field_set:radar.messages.RadarCommand.beam_elevation)
}

// double beam_duration_ms = 8;
inline void RadarCommand::clear_beam_duration_ms() {
  _impl_.beam_duration_ms_ = 0;
}
inline double RadarCommand::_internal_beam_duration_ms() const {
  return _impl_.beam_duration_ms_;
}
inline double RadarCommand::beam_duration_ms() const {
  // @@protoc_insertion_point(field_get:radar.messages.RadarCommand.beam_duration_ms)
  return _internal_beam_duration_ms();
}
inline void RadarCommand::_internal_set_beam_duration_ms(double value) {
  
  _impl_.beam_duration_ms_ = value;
}
inline void RadarCommand::set_beam_duration_ms(double value) {
  _internal_set_beam_duration_ms(value);
  // @@protoc_insertion_point(field_set:radar.messages.RadarCommand.beam_duration_ms)
}

// .radar.messages.SignalProcessingConfig config_update = 9;
inline bool RadarCommand::_internal_has_config_update() const {
  return this != internal_default_instance() && _impl_.config_update_ != nullptr;
}
inline bool RadarCommand::has_config_update() const {
  return _internal_has_config_update();
}
inline void RadarCommand::clear_config_update() {
  if (GetArenaForAllocation() == nullptr && _impl_.config_update_ != nullptr) {
    delete _impl_.config_update_;
  }
  _impl_.config_update_ = nullptr;
}
inline const ::radar::messages::SignalProcessingConfig& RadarCommand::_internal_config_update() const {
  const ::radar::messages::SignalProcessingConfig* p = _impl_.config_update_;
  return p != nullptr ? *p : reinterpret_cast<const ::radar::messages::SignalProcessingConfig&>(
      ::radar::messages::_SignalProcessingConfig_default_instance_);
}
inline const ::radar::messages::SignalProcessingConfig& RadarCommand::config_update() const {
  // @@protoc_insertion_point(field_get:radar.messages.RadarCommand.config_update)
  return _internal_config_update();
}
inline void RadarCommand::unsafe_arena_set_allocated_config_update(
    ::radar::messages::SignalProcessingConfig* config_update) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.config_update_);
  }
  _impl_.config_update_ = config_update;
  if (config_update) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:radar.messages.RadarCommand.config_update)
}
inline ::radar::messages::SignalProcessingConfig* RadarCommand::release_config_update() {
  
  ::radar::messages::SignalProcessingConfig* temp = _impl_.config_update_;
  _impl_.config_update_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::radar::messages::SignalProcessingConfig* RadarCommand::unsafe_arena_release_config_update() {
  // @@protoc_insertion_point(field_release:radar.messages.RadarCommand.config_update)
  
  ::radar::messages::SignalProcessingConfig* temp = _impl_.config_update_;
  _impl_.config_update_ = nullptr;
  return temp;
}
inline ::radar::messages::SignalProcessingConfig* RadarCommand::_internal_mutable_config_update() {
  
  if (_impl_.config_update_ == nullptr) {
    auto* p = CreateMaybeMessage<::radar::messages::SignalProcessingConfig>(GetArenaForAllocation());
    _impl_.config_update_ = p;
  }
  return _impl_.config_update_;
}
inline ::radar::messages::SignalProcessingConfig* RadarCommand::mutable_config_update() {
  ::radar::messages::SignalProcessingConfig* _msg = _internal_mutable_config_update();
  // @@protoc_insertion_point(field_mutable:radar.messages.RadarCommand.config_update)
  return _msg;
}
inline void RadarCommand::set_allocated_config_update(::radar::messages::SignalProcessingConfig* config_update) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.config_update_;
  }
  if (config_update) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(config_update);
    if (message_arena != submessage_arena) {
      config_update = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, config_update, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.config_update_ = config_update;
  // @@protoc_insertion_point(field_set_allocated:radar.messages.RadarCommand.config_update)
}

// map<string, string> parameters = 10;
inline int RadarCommand::_internal_parameters_size() const {
  return _impl_.parameters_.size();
}
inline int RadarCommand::parameters_size() const {
  return _internal_parameters_size();
}
inline void RadarCommand::clear_parameters() {
  _impl_.parameters_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
RadarCommand::_internal_parameters() const {
  return _impl_.parameters_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
RadarCommand::parameters() const {
  // @@protoc_insertion_point(field_map:radar.messages.RadarCommand.parameters)
  return _internal_parameters();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
RadarCommand::_internal_mutable_parameters() {
  return _impl_.parameters_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
RadarCommand::mutable_parameters() {
  // @@protoc_insertion_point(field_mutable_map:radar.messages.RadarCommand.parameters)
  return _internal_mutable_parameters();
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// RadarCommandResponse

// uint32 sensor_id = 1;
inline void RadarCommandResponse::clear_sensor_id() {
  _impl_.sensor_id_ = 0u;
}
inline uint32_t RadarCommandResponse::_internal_sensor_id() const {
  return _impl_.sensor_id_;
}
inline uint32_t RadarCommandResponse::sensor_id() const {
  // @@protoc_insertion_point(field_get:radar.messages.RadarCommandResponse.sensor_id)
  return _internal_sensor_id();
}
inline void RadarCommandResponse::_internal_set_sensor_id(uint32_t value) {
  
  _impl_.sensor_id_ = value;
}
inline void RadarCommandResponse::set_sensor_id(uint32_t value) {
  _internal_set_sensor_id(value);
  // @@protoc_insertion_point(field_set:radar.messages.RadarCommandResponse.sensor_id)
}

// uint32 command_id = 2;
inline void RadarCommandResponse::clear_command_id() {
  _impl_.command_id_ = 0u;
}
inline uint32_t RadarCommandResponse::_internal_command_id() const {
  return _impl_.command_id_;
}
inline uint32_t RadarCommandResponse::command_id() const {
  // @@protoc_insertion_point(field_get:radar.messages.RadarCommandResponse.command_id)
  return _internal_command_id();
}
inline void RadarCommandResponse::_internal_set_command_id(uint32_t value) {
  
  _impl_.command_id_ = value;
}
inline void RadarCommandResponse::set_command_id(uint32_t value) {
  _internal_set_command_id(value);
  // @@protoc_insertion_point(field_set:radar.messages.RadarCommandResponse.command_id)
}

// .google.protobuf.Timestamp timestamp = 3;
inline bool RadarCommandResponse::_internal_has_timestamp() const {
  return this != internal_default_instance() && _impl_.timestamp_ != nullptr;
}
inline bool RadarCommandResponse::has_timestamp() const {
  return _internal_has_timestamp();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& RadarCommandResponse::_internal_timestamp() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.timestamp_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& RadarCommandResponse::timestamp() const {
  // @@protoc_insertion_point(field_get:radar.messages.RadarCommandResponse.timestamp)
  return _internal_timestamp();
}
inline void RadarCommandResponse::unsafe_arena_set_allocated_timestamp(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.timestamp_);
  }
  _impl_.timestamp_ = timestamp;
  if (timestamp) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:radar.messages.RadarCommandResponse.timestamp)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* RadarCommandResponse::release_timestamp() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.timestamp_;
  _impl_.timestamp_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* RadarCommandResponse::unsafe_arena_release_timestamp() {
  // @@protoc_insertion_point(field_release:radar.messages.RadarCommandResponse.timestamp)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.timestamp_;
  _impl_.timestamp_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* RadarCommandResponse::_internal_mutable_timestamp() {
  
  if (_impl_.timestamp_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.timestamp_ = p;
  }
  return _impl_.timestamp_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* RadarCommandResponse::mutable_timestamp() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_timestamp();
  // @@protoc_insertion_point(field_mutable:radar.messages.RadarCommandResponse.timestamp)
  return _msg;
}
inline void RadarCommandResponse::set_allocated_timestamp(::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.timestamp_);
  }
  if (timestamp) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(timestamp));
    if (message_arena != submessage_arena) {
      timestamp = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, timestamp, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.timestamp_ = timestamp;
  // @@protoc_insertion_point(field_set_allocated:radar.messages.RadarCommandResponse.timestamp)
}

// .radar.messages.RadarCommandResponse.ResponseStatus status = 4;
inline void RadarCommandResponse::clear_status() {
  _impl_.status_ = 0;
}
inline ::radar::messages::RadarCommandResponse_ResponseStatus RadarCommandResponse::_internal_status() const {
  return static_cast< ::radar::messages::RadarCommandResponse_ResponseStatus >(_impl_.status_);
}
inline ::radar::messages::RadarCommandResponse_ResponseStatus RadarCommandResponse::status() const {
  // @@protoc_insertion_point(field_get:radar.messages.RadarCommandResponse.status)
  return _internal_status();
}
inline void RadarCommandResponse::_internal_set_status(::radar::messages::RadarCommandResponse_ResponseStatus value) {
  
  _impl_.status_ = value;
}
inline void RadarCommandResponse::set_status(::radar::messages::RadarCommandResponse_ResponseStatus value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:radar.messages.RadarCommandResponse.status)
}

// string message = 5;
inline void RadarCommandResponse::clear_message() {
  _impl_.message_.ClearToEmpty();
}
inline const std::string& RadarCommandResponse::message() const {
  // @@protoc_insertion_point(field_get:radar.messages.RadarCommandResponse.message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RadarCommandResponse::set_message(ArgT0&& arg0, ArgT... args) {
 
 _impl_.message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:radar.messages.RadarCommandResponse.message)
}
inline std::string* RadarCommandResponse::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:radar.messages.RadarCommandResponse.message)
  return _s;
}
inline const std::string& RadarCommandResponse::_internal_message() const {
  return _impl_.message_.Get();
}
inline void RadarCommandResponse::_internal_set_message(const std::string& value) {
  
  _impl_.message_.Set(value, GetArenaForAllocation());
}
inline std::string* RadarCommandResponse::_internal_mutable_message() {
  
  return _impl_.message_.Mutable(GetArenaForAllocation());
}
inline std::string* RadarCommandResponse::release_message() {
  // @@protoc_insertion_point(field_release:radar.messages.RadarCommandResponse.message)
  return _impl_.message_.Release();
}
inline void RadarCommandResponse::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  _impl_.message_.SetAllocated(message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.message_.IsDefault()) {
    _impl_.message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:radar.messages.RadarCommandResponse.message)
}

// double execution_time_ms = 6;
inline void RadarCommandResponse::clear_execution_time_ms() {
  _impl_.execution_time_ms_ = 0;
}
inline double RadarCommandResponse::_internal_execution_time_ms() const {
  return _impl_.execution_time_ms_;
}
inline double RadarCommandResponse::execution_time_ms() const {
  // @@protoc_insertion_point(field_get:radar.messages.RadarCommandResponse.execution_time_ms)
  return _internal_execution_time_ms();
}
inline void RadarCommandResponse::_internal_set_execution_time_ms(double value) {
  
  _impl_.execution_time_ms_ = value;
}
inline void RadarCommandResponse::set_execution_time_ms(double value) {
  _internal_set_execution_time_ms(value);
  // @@protoc_insertion_point(field_set:radar.messages.RadarCommandResponse.execution_time_ms)
}

// map<string, string> result_data = 7;
inline int RadarCommandResponse::_internal_result_data_size() const {
  return _impl_.result_data_.size();
}
inline int RadarCommandResponse::result_data_size() const {
  return _internal_result_data_size();
}
inline void RadarCommandResponse::clear_result_data() {
  _impl_.result_data_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
RadarCommandResponse::_internal_result_data() const {
  return _impl_.result_data_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
RadarCommandResponse::result_data() const {
  // @@protoc_insertion_point(field_map:radar.messages.RadarCommandResponse.result_data)
  return _internal_result_data();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
RadarCommandResponse::_internal_mutable_result_data() {
  return _impl_.result_data_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
RadarCommandResponse::mutable_result_data() {
  // @@protoc_insertion_point(field_mutable_map:radar.messages.RadarCommandResponse.result_data)
  return _internal_mutable_result_data();
}

// -------------------------------------------------------------------

// PerformanceMetrics

// .google.protobuf.Timestamp timestamp = 1;
inline bool PerformanceMetrics::_internal_has_timestamp() const {
  return this != internal_default_instance() && _impl_.timestamp_ != nullptr;
}
inline bool PerformanceMetrics::has_timestamp() const {
  return _internal_has_timestamp();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& PerformanceMetrics::_internal_timestamp() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.timestamp_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& PerformanceMetrics::timestamp() const {
  // @@protoc_insertion_point(field_get:radar.messages.PerformanceMetrics.timestamp)
  return _internal_timestamp();
}
inline void PerformanceMetrics::unsafe_arena_set_allocated_timestamp(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.timestamp_);
  }
  _impl_.timestamp_ = timestamp;
  if (timestamp) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:radar.messages.PerformanceMetrics.timestamp)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* PerformanceMetrics::release_timestamp() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.timestamp_;
  _impl_.timestamp_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* PerformanceMetrics::unsafe_arena_release_timestamp() {
  // @@protoc_insertion_point(field_release:radar.messages.PerformanceMetrics.timestamp)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.timestamp_;
  _impl_.timestamp_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* PerformanceMetrics::_internal_mutable_timestamp() {
  
  if (_impl_.timestamp_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.timestamp_ = p;
  }
  return _impl_.timestamp_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* PerformanceMetrics::mutable_timestamp() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_timestamp();
  // @@protoc_insertion_point(field_mutable:radar.messages.PerformanceMetrics.timestamp)
  return _msg;
}
inline void PerformanceMetrics::set_allocated_timestamp(::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.timestamp_);
  }
  if (timestamp) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(timestamp));
    if (message_arena != submessage_arena) {
      timestamp = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, timestamp, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.timestamp_ = timestamp;
  // @@protoc_insertion_point(field_set_allocated:radar.messages.PerformanceMetrics.timestamp)
}

// uint32 sensor_id = 2;
inline void PerformanceMetrics::clear_sensor_id() {
  _impl_.sensor_id_ = 0u;
}
inline uint32_t PerformanceMetrics::_internal_sensor_id() const {
  return _impl_.sensor_id_;
}
inline uint32_t PerformanceMetrics::sensor_id() const {
  // @@protoc_insertion_point(field_get:radar.messages.PerformanceMetrics.sensor_id)
  return _internal_sensor_id();
}
inline void PerformanceMetrics::_internal_set_sensor_id(uint32_t value) {
  
  _impl_.sensor_id_ = value;
}
inline void PerformanceMetrics::set_sensor_id(uint32_t value) {
  _internal_set_sensor_id(value);
  // @@protoc_insertion_point(field_set:radar.messages.PerformanceMetrics.sensor_id)
}

// double processing_time_ms = 3;
inline void PerformanceMetrics::clear_processing_time_ms() {
  _impl_.processing_time_ms_ = 0;
}
inline double PerformanceMetrics::_internal_processing_time_ms() const {
  return _impl_.processing_time_ms_;
}
inline double PerformanceMetrics::processing_time_ms() const {
  // @@protoc_insertion_point(field_get:radar.messages.PerformanceMetrics.processing_time_ms)
  return _internal_processing_time_ms();
}
inline void PerformanceMetrics::_internal_set_processing_time_ms(double value) {
  
  _impl_.processing_time_ms_ = value;
}
inline void PerformanceMetrics::set_processing_time_ms(double value) {
  _internal_set_processing_time_ms(value);
  // @@protoc_insertion_point(field_set:radar.messages.PerformanceMetrics.processing_time_ms)
}

// double detection_rate = 4;
inline void PerformanceMetrics::clear_detection_rate() {
  _impl_.detection_rate_ = 0;
}
inline double PerformanceMetrics::_internal_detection_rate() const {
  return _impl_.detection_rate_;
}
inline double PerformanceMetrics::detection_rate() const {
  // @@protoc_insertion_point(field_get:radar.messages.PerformanceMetrics.detection_rate)
  return _internal_detection_rate();
}
inline void PerformanceMetrics::_internal_set_detection_rate(double value) {
  
  _impl_.detection_rate_ = value;
}
inline void PerformanceMetrics::set_detection_rate(double value) {
  _internal_set_detection_rate(value);
  // @@protoc_insertion_point(field_set:radar.messages.PerformanceMetrics.detection_rate)
}

// double false_alarm_rate = 5;
inline void PerformanceMetrics::clear_false_alarm_rate() {
  _impl_.false_alarm_rate_ = 0;
}
inline double PerformanceMetrics::_internal_false_alarm_rate() const {
  return _impl_.false_alarm_rate_;
}
inline double PerformanceMetrics::false_alarm_rate() const {
  // @@protoc_insertion_point(field_get:radar.messages.PerformanceMetrics.false_alarm_rate)
  return _internal_false_alarm_rate();
}
inline void PerformanceMetrics::_internal_set_false_alarm_rate(double value) {
  
  _impl_.false_alarm_rate_ = value;
}
inline void PerformanceMetrics::set_false_alarm_rate(double value) {
  _internal_set_false_alarm_rate(value);
  // @@protoc_insertion_point(field_set:radar.messages.PerformanceMetrics.false_alarm_rate)
}

// uint32 active_tracks = 6;
inline void PerformanceMetrics::clear_active_tracks() {
  _impl_.active_tracks_ = 0u;
}
inline uint32_t PerformanceMetrics::_internal_active_tracks() const {
  return _impl_.active_tracks_;
}
inline uint32_t PerformanceMetrics::active_tracks() const {
  // @@protoc_insertion_point(field_get:radar.messages.PerformanceMetrics.active_tracks)
  return _internal_active_tracks();
}
inline void PerformanceMetrics::_internal_set_active_tracks(uint32_t value) {
  
  _impl_.active_tracks_ = value;
}
inline void PerformanceMetrics::set_active_tracks(uint32_t value) {
  _internal_set_active_tracks(value);
  // @@protoc_insertion_point(field_set:radar.messages.PerformanceMetrics.active_tracks)
}

// uint32 total_detections = 7;
inline void PerformanceMetrics::clear_total_detections() {
  _impl_.total_detections_ = 0u;
}
inline uint32_t PerformanceMetrics::_internal_total_detections() const {
  return _impl_.total_detections_;
}
inline uint32_t PerformanceMetrics::total_detections() const {
  // @@protoc_insertion_point(field_get:radar.messages.PerformanceMetrics.total_detections)
  return _internal_total_detections();
}
inline void PerformanceMetrics::_internal_set_total_detections(uint32_t value) {
  
  _impl_.total_detections_ = value;
}
inline void PerformanceMetrics::set_total_detections(uint32_t value) {
  _internal_set_total_detections(value);
  // @@protoc_insertion_point(field_set:radar.messages.PerformanceMetrics.total_detections)
}

// double cpu_usage = 8;
inline void PerformanceMetrics::clear_cpu_usage() {
  _impl_.cpu_usage_ = 0;
}
inline double PerformanceMetrics::_internal_cpu_usage() const {
  return _impl_.cpu_usage_;
}
inline double PerformanceMetrics::cpu_usage() const {
  // @@protoc_insertion_point(field_get:radar.messages.PerformanceMetrics.cpu_usage)
  return _internal_cpu_usage();
}
inline void PerformanceMetrics::_internal_set_cpu_usage(double value) {
  
  _impl_.cpu_usage_ = value;
}
inline void PerformanceMetrics::set_cpu_usage(double value) {
  _internal_set_cpu_usage(value);
  // @@protoc_insertion_point(field_set:radar.messages.PerformanceMetrics.cpu_usage)
}

// double memory_usage_mb = 9;
inline void PerformanceMetrics::clear_memory_usage_mb() {
  _impl_.memory_usage_mb_ = 0;
}
inline double PerformanceMetrics::_internal_memory_usage_mb() const {
  return _impl_.memory_usage_mb_;
}
inline double PerformanceMetrics::memory_usage_mb() const {
  // @@protoc_insertion_point(field_get:radar.messages.PerformanceMetrics.memory_usage_mb)
  return _internal_memory_usage_mb();
}
inline void PerformanceMetrics::_internal_set_memory_usage_mb(double value) {
  
  _impl_.memory_usage_mb_ = value;
}
inline void PerformanceMetrics::set_memory_usage_mb(double value) {
  _internal_set_memory_usage_mb(value);
  // @@protoc_insertion_point(field_set:radar.messages.PerformanceMetrics.memory_usage_mb)
}

// double input_latency_ms = 10;
inline void PerformanceMetrics::clear_input_latency_ms() {
  _impl_.input_latency_ms_ = 0;
}
inline double PerformanceMetrics::_internal_input_latency_ms() const {
  return _impl_.input_latency_ms_;
}
inline double PerformanceMetrics::input_latency_ms() const {
  // @@protoc_insertion_point(field_get:radar.messages.PerformanceMetrics.input_latency_ms)
  return _internal_input_latency_ms();
}
inline void PerformanceMetrics::_internal_set_input_latency_ms(double value) {
  
  _impl_.input_latency_ms_ = value;
}
inline void PerformanceMetrics::set_input_latency_ms(double value) {
  _internal_set_input_latency_ms(value);
  // @@protoc_insertion_point(field_set:radar.messages.PerformanceMetrics.input_latency_ms)
}

// double processing_latency_ms = 11;
inline void PerformanceMetrics::clear_processing_latency_ms() {
  _impl_.processing_latency_ms_ = 0;
}
inline double PerformanceMetrics::_internal_processing_latency_ms() const {
  return _impl_.processing_latency_ms_;
}
inline double PerformanceMetrics::processing_latency_ms() const {
  // @@protoc_insertion_point(field_get:radar.messages.PerformanceMetrics.processing_latency_ms)
  return _internal_processing_latency_ms();
}
inline void PerformanceMetrics::_internal_set_processing_latency_ms(double value) {
  
  _impl_.processing_latency_ms_ = value;
}
inline void PerformanceMetrics::set_processing_latency_ms(double value) {
  _internal_set_processing_latency_ms(value);
  // @@protoc_insertion_point(field_set:radar.messages.PerformanceMetrics.processing_latency_ms)
}

// double output_latency_ms = 12;
inline void PerformanceMetrics::clear_output_latency_ms() {
  _impl_.output_latency_ms_ = 0;
}
inline double PerformanceMetrics::_internal_output_latency_ms() const {
  return _impl_.output_latency_ms_;
}
inline double PerformanceMetrics::output_latency_ms() const {
  // @@protoc_insertion_point(field_get:radar.messages.PerformanceMetrics.output_latency_ms)
  return _internal_output_latency_ms();
}
inline void PerformanceMetrics::_internal_set_output_latency_ms(double value) {
  
  _impl_.output_latency_ms_ = value;
}
inline void PerformanceMetrics::set_output_latency_ms(double value) {
  _internal_set_output_latency_ms(value);
  // @@protoc_insertion_point(field_set:radar.messages.PerformanceMetrics.output_latency_ms)
}

// double total_latency_ms = 13;
inline void PerformanceMetrics::clear_total_latency_ms() {
  _impl_.total_latency_ms_ = 0;
}
inline double PerformanceMetrics::_internal_total_latency_ms() const {
  return _impl_.total_latency_ms_;
}
inline double PerformanceMetrics::total_latency_ms() const {
  // @@protoc_insertion_point(field_get:radar.messages.PerformanceMetrics.total_latency_ms)
  return _internal_total_latency_ms();
}
inline void PerformanceMetrics::_internal_set_total_latency_ms(double value) {
  
  _impl_.total_latency_ms_ = value;
}
inline void PerformanceMetrics::set_total_latency_ms(double value) {
  _internal_set_total_latency_ms(value);
  // @@protoc_insertion_point(field_set:radar.messages.PerformanceMetrics.total_latency_ms)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// SystemHealth

// .google.protobuf.Timestamp timestamp = 1;
inline bool SystemHealth::_internal_has_timestamp() const {
  return this != internal_default_instance() && _impl_.timestamp_ != nullptr;
}
inline bool SystemHealth::has_timestamp() const {
  return _internal_has_timestamp();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& SystemHealth::_internal_timestamp() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.timestamp_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& SystemHealth::timestamp() const {
  // @@protoc_insertion_point(field_get:radar.messages.SystemHealth.timestamp)
  return _internal_timestamp();
}
inline void SystemHealth::unsafe_arena_set_allocated_timestamp(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.timestamp_);
  }
  _impl_.timestamp_ = timestamp;
  if (timestamp) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:radar.messages.SystemHealth.timestamp)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* SystemHealth::release_timestamp() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.timestamp_;
  _impl_.timestamp_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* SystemHealth::unsafe_arena_release_timestamp() {
  // @@protoc_insertion_point(field_release:radar.messages.SystemHealth.timestamp)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.timestamp_;
  _impl_.timestamp_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* SystemHealth::_internal_mutable_timestamp() {
  
  if (_impl_.timestamp_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.timestamp_ = p;
  }
  return _impl_.timestamp_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* SystemHealth::mutable_timestamp() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_timestamp();
  // @@protoc_insertion_point(field_mutable:radar.messages.SystemHealth.timestamp)
  return _msg;
}
inline void SystemHealth::set_allocated_timestamp(::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.timestamp_);
  }
  if (timestamp) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(timestamp));
    if (message_arena != submessage_arena) {
      timestamp = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, timestamp, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.timestamp_ = timestamp;
  // @@protoc_insertion_point(field_set_allocated:radar.messages.SystemHealth.timestamp)
}

// .radar.messages.SystemHealth.HealthStatus overall_status = 2;
inline void SystemHealth::clear_overall_status() {
  _impl_.overall_status_ = 0;
}
inline ::radar::messages::SystemHealth_HealthStatus SystemHealth::_internal_overall_status() const {
  return static_cast< ::radar::messages::SystemHealth_HealthStatus >(_impl_.overall_status_);
}
inline ::radar::messages::SystemHealth_HealthStatus SystemHealth::overall_status() const {
  // @@protoc_insertion_point(field_get:radar.messages.SystemHealth.overall_status)
  return _internal_overall_status();
}
inline void SystemHealth::_internal_set_overall_status(::radar::messages::SystemHealth_HealthStatus value) {
  
  _impl_.overall_status_ = value;
}
inline void SystemHealth::set_overall_status(::radar::messages::SystemHealth_HealthStatus value) {
  _internal_set_overall_status(value);
  // @@protoc_insertion_point(field_set:radar.messages.SystemHealth.overall_status)
}

// map<string, .radar.messages.SystemHealth.HealthStatus> component_health = 3;
inline int SystemHealth::_internal_component_health_size() const {
  return _impl_.component_health_.size();
}
inline int SystemHealth::component_health_size() const {
  return _internal_component_health_size();
}
inline void SystemHealth::clear_component_health() {
  _impl_.component_health_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::radar::messages::SystemHealth_HealthStatus >&
SystemHealth::_internal_component_health() const {
  return _impl_.component_health_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::radar::messages::SystemHealth_HealthStatus >&
SystemHealth::component_health() const {
  // @@protoc_insertion_point(field_map:radar.messages.SystemHealth.component_health)
  return _internal_component_health();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::radar::messages::SystemHealth_HealthStatus >*
SystemHealth::_internal_mutable_component_health() {
  return _impl_.component_health_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::radar::messages::SystemHealth_HealthStatus >*
SystemHealth::mutable_component_health() {
  // @@protoc_insertion_point(field_mutable_map:radar.messages.SystemHealth.component_health)
  return _internal_mutable_component_health();
}

// double cpu_usage_percent = 4;
inline void SystemHealth::clear_cpu_usage_percent() {
  _impl_.cpu_usage_percent_ = 0;
}
inline double SystemHealth::_internal_cpu_usage_percent() const {
  return _impl_.cpu_usage_percent_;
}
inline double SystemHealth::cpu_usage_percent() const {
  // @@protoc_insertion_point(field_get:radar.messages.SystemHealth.cpu_usage_percent)
  return _internal_cpu_usage_percent();
}
inline void SystemHealth::_internal_set_cpu_usage_percent(double value) {
  
  _impl_.cpu_usage_percent_ = value;
}
inline void SystemHealth::set_cpu_usage_percent(double value) {
  _internal_set_cpu_usage_percent(value);
  // @@protoc_insertion_point(field_set:radar.messages.SystemHealth.cpu_usage_percent)
}

// double memory_usage_percent = 5;
inline void SystemHealth::clear_memory_usage_percent() {
  _impl_.memory_usage_percent_ = 0;
}
inline double SystemHealth::_internal_memory_usage_percent() const {
  return _impl_.memory_usage_percent_;
}
inline double SystemHealth::memory_usage_percent() const {
  // @@protoc_insertion_point(field_get:radar.messages.SystemHealth.memory_usage_percent)
  return _internal_memory_usage_percent();
}
inline void SystemHealth::_internal_set_memory_usage_percent(double value) {
  
  _impl_.memory_usage_percent_ = value;
}
inline void SystemHealth::set_memory_usage_percent(double value) {
  _internal_set_memory_usage_percent(value);
  // @@protoc_insertion_point(field_set:radar.messages.SystemHealth.memory_usage_percent)
}

// double disk_usage_percent = 6;
inline void SystemHealth::clear_disk_usage_percent() {
  _impl_.disk_usage_percent_ = 0;
}
inline double SystemHealth::_internal_disk_usage_percent() const {
  return _impl_.disk_usage_percent_;
}
inline double SystemHealth::disk_usage_percent() const {
  // @@protoc_insertion_point(field_get:radar.messages.SystemHealth.disk_usage_percent)
  return _internal_disk_usage_percent();
}
inline void SystemHealth::_internal_set_disk_usage_percent(double value) {
  
  _impl_.disk_usage_percent_ = value;
}
inline void SystemHealth::set_disk_usage_percent(double value) {
  _internal_set_disk_usage_percent(value);
  // @@protoc_insertion_point(field_set:radar.messages.SystemHealth.disk_usage_percent)
}

// double network_usage_mbps = 7;
inline void SystemHealth::clear_network_usage_mbps() {
  _impl_.network_usage_mbps_ = 0;
}
inline double SystemHealth::_internal_network_usage_mbps() const {
  return _impl_.network_usage_mbps_;
}
inline double SystemHealth::network_usage_mbps() const {
  // @@protoc_insertion_point(field_get:radar.messages.SystemHealth.network_usage_mbps)
  return _internal_network_usage_mbps();
}
inline void SystemHealth::_internal_set_network_usage_mbps(double value) {
  
  _impl_.network_usage_mbps_ = value;
}
inline void SystemHealth::set_network_usage_mbps(double value) {
  _internal_set_network_usage_mbps(value);
  // @@protoc_insertion_point(field_set:radar.messages.SystemHealth.network_usage_mbps)
}

// uint32 error_count_last_hour = 8;
inline void SystemHealth::clear_error_count_last_hour() {
  _impl_.error_count_last_hour_ = 0u;
}
inline uint32_t SystemHealth::_internal_error_count_last_hour() const {
  return _impl_.error_count_last_hour_;
}
inline uint32_t SystemHealth::error_count_last_hour() const {
  // @@protoc_insertion_point(field_get:radar.messages.SystemHealth.error_count_last_hour)
  return _internal_error_count_last_hour();
}
inline void SystemHealth::_internal_set_error_count_last_hour(uint32_t value) {
  
  _impl_.error_count_last_hour_ = value;
}
inline void SystemHealth::set_error_count_last_hour(uint32_t value) {
  _internal_set_error_count_last_hour(value);
  // @@protoc_insertion_point(field_set:radar.messages.SystemHealth.error_count_last_hour)
}

// uint32 warning_count_last_hour = 9;
inline void SystemHealth::clear_warning_count_last_hour() {
  _impl_.warning_count_last_hour_ = 0u;
}
inline uint32_t SystemHealth::_internal_warning_count_last_hour() const {
  return _impl_.warning_count_last_hour_;
}
inline uint32_t SystemHealth::warning_count_last_hour() const {
  // @@protoc_insertion_point(field_get:radar.messages.SystemHealth.warning_count_last_hour)
  return _internal_warning_count_last_hour();
}
inline void SystemHealth::_internal_set_warning_count_last_hour(uint32_t value) {
  
  _impl_.warning_count_last_hour_ = value;
}
inline void SystemHealth::set_warning_count_last_hour(uint32_t value) {
  _internal_set_warning_count_last_hour(value);
  // @@protoc_insertion_point(field_set:radar.messages.SystemHealth.warning_count_last_hour)
}

// repeated string recent_errors = 10;
inline int SystemHealth::_internal_recent_errors_size() const {
  return _impl_.recent_errors_.size();
}
inline int SystemHealth::recent_errors_size() const {
  return _internal_recent_errors_size();
}
inline void SystemHealth::clear_recent_errors() {
  _impl_.recent_errors_.Clear();
}
inline std::string* SystemHealth::add_recent_errors() {
  std::string* _s = _internal_add_recent_errors();
  // @@protoc_insertion_point(field_add_mutable:radar.messages.SystemHealth.recent_errors)
  return _s;
}
inline const std::string& SystemHealth::_internal_recent_errors(int index) const {
  return _impl_.recent_errors_.Get(index);
}
inline const std::string& SystemHealth::recent_errors(int index) const {
  // @@protoc_insertion_point(field_get:radar.messages.SystemHealth.recent_errors)
  return _internal_recent_errors(index);
}
inline std::string* SystemHealth::mutable_recent_errors(int index) {
  // @@protoc_insertion_point(field_mutable:radar.messages.SystemHealth.recent_errors)
  return _impl_.recent_errors_.Mutable(index);
}
inline void SystemHealth::set_recent_errors(int index, const std::string& value) {
  _impl_.recent_errors_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:radar.messages.SystemHealth.recent_errors)
}
inline void SystemHealth::set_recent_errors(int index, std::string&& value) {
  _impl_.recent_errors_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:radar.messages.SystemHealth.recent_errors)
}
inline void SystemHealth::set_recent_errors(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.recent_errors_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:radar.messages.SystemHealth.recent_errors)
}
inline void SystemHealth::set_recent_errors(int index, const char* value, size_t size) {
  _impl_.recent_errors_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:radar.messages.SystemHealth.recent_errors)
}
inline std::string* SystemHealth::_internal_add_recent_errors() {
  return _impl_.recent_errors_.Add();
}
inline void SystemHealth::add_recent_errors(const std::string& value) {
  _impl_.recent_errors_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:radar.messages.SystemHealth.recent_errors)
}
inline void SystemHealth::add_recent_errors(std::string&& value) {
  _impl_.recent_errors_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:radar.messages.SystemHealth.recent_errors)
}
inline void SystemHealth::add_recent_errors(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.recent_errors_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:radar.messages.SystemHealth.recent_errors)
}
inline void SystemHealth::add_recent_errors(const char* value, size_t size) {
  _impl_.recent_errors_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:radar.messages.SystemHealth.recent_errors)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
SystemHealth::recent_errors() const {
  // @@protoc_insertion_point(field_list:radar.messages.SystemHealth.recent_errors)
  return _impl_.recent_errors_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
SystemHealth::mutable_recent_errors() {
  // @@protoc_insertion_point(field_mutable_list:radar.messages.SystemHealth.recent_errors)
  return &_impl_.recent_errors_;
}

// repeated string recent_warnings = 11;
inline int SystemHealth::_internal_recent_warnings_size() const {
  return _impl_.recent_warnings_.size();
}
inline int SystemHealth::recent_warnings_size() const {
  return _internal_recent_warnings_size();
}
inline void SystemHealth::clear_recent_warnings() {
  _impl_.recent_warnings_.Clear();
}
inline std::string* SystemHealth::add_recent_warnings() {
  std::string* _s = _internal_add_recent_warnings();
  // @@protoc_insertion_point(field_add_mutable:radar.messages.SystemHealth.recent_warnings)
  return _s;
}
inline const std::string& SystemHealth::_internal_recent_warnings(int index) const {
  return _impl_.recent_warnings_.Get(index);
}
inline const std::string& SystemHealth::recent_warnings(int index) const {
  // @@protoc_insertion_point(field_get:radar.messages.SystemHealth.recent_warnings)
  return _internal_recent_warnings(index);
}
inline std::string* SystemHealth::mutable_recent_warnings(int index) {
  // @@protoc_insertion_point(field_mutable:radar.messages.SystemHealth.recent_warnings)
  return _impl_.recent_warnings_.Mutable(index);
}
inline void SystemHealth::set_recent_warnings(int index, const std::string& value) {
  _impl_.recent_warnings_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:radar.messages.SystemHealth.recent_warnings)
}
inline void SystemHealth::set_recent_warnings(int index, std::string&& value) {
  _impl_.recent_warnings_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:radar.messages.SystemHealth.recent_warnings)
}
inline void SystemHealth::set_recent_warnings(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.recent_warnings_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:radar.messages.SystemHealth.recent_warnings)
}
inline void SystemHealth::set_recent_warnings(int index, const char* value, size_t size) {
  _impl_.recent_warnings_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:radar.messages.SystemHealth.recent_warnings)
}
inline std::string* SystemHealth::_internal_add_recent_warnings() {
  return _impl_.recent_warnings_.Add();
}
inline void SystemHealth::add_recent_warnings(const std::string& value) {
  _impl_.recent_warnings_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:radar.messages.SystemHealth.recent_warnings)
}
inline void SystemHealth::add_recent_warnings(std::string&& value) {
  _impl_.recent_warnings_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:radar.messages.SystemHealth.recent_warnings)
}
inline void SystemHealth::add_recent_warnings(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.recent_warnings_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:radar.messages.SystemHealth.recent_warnings)
}
inline void SystemHealth::add_recent_warnings(const char* value, size_t size) {
  _impl_.recent_warnings_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:radar.messages.SystemHealth.recent_warnings)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
SystemHealth::recent_warnings() const {
  // @@protoc_insertion_point(field_list:radar.messages.SystemHealth.recent_warnings)
  return _impl_.recent_warnings_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
SystemHealth::mutable_recent_warnings() {
  // @@protoc_insertion_point(field_mutable_list:radar.messages.SystemHealth.recent_warnings)
  return &_impl_.recent_warnings_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace messages
}  // namespace radar

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::radar::messages::RadarCommand_CommandType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::radar::messages::RadarCommand_CommandType>() {
  return ::radar::messages::RadarCommand_CommandType_descriptor();
}
template <> struct is_proto_enum< ::radar::messages::RadarCommandResponse_ResponseStatus> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::radar::messages::RadarCommandResponse_ResponseStatus>() {
  return ::radar::messages::RadarCommandResponse_ResponseStatus_descriptor();
}
template <> struct is_proto_enum< ::radar::messages::SystemHealth_HealthStatus> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::radar::messages::SystemHealth_HealthStatus>() {
  return ::radar::messages::SystemHealth_HealthStatus_descriptor();
}
template <> struct is_proto_enum< ::radar::messages::CoordinateSystem> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::radar::messages::CoordinateSystem>() {
  return ::radar::messages::CoordinateSystem_descriptor();
}
template <> struct is_proto_enum< ::radar::messages::DetectionType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::radar::messages::DetectionType>() {
  return ::radar::messages::DetectionType_descriptor();
}
template <> struct is_proto_enum< ::radar::messages::MotionModel> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::radar::messages::MotionModel>() {
  return ::radar::messages::MotionModel_descriptor();
}
template <> struct is_proto_enum< ::radar::messages::TrackState> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::radar::messages::TrackState>() {
  return ::radar::messages::TrackState_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_radar_5fmessages_2eproto
