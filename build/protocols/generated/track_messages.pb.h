// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: track_messages.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_track_5fmessages_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_track_5fmessages_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include <google/protobuf/timestamp.pb.h>
#include "radar_messages.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_track_5fmessages_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_track_5fmessages_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_track_5fmessages_2eproto;
namespace radar {
namespace messages {
class Association;
struct AssociationDefaultTypeInternal;
extern AssociationDefaultTypeInternal _Association_default_instance_;
class DetectionCluster;
struct DetectionClusterDefaultTypeInternal;
extern DetectionClusterDefaultTypeInternal _DetectionCluster_default_instance_;
class DetectionCluster_AlgorithmParametersEntry_DoNotUse;
struct DetectionCluster_AlgorithmParametersEntry_DoNotUseDefaultTypeInternal;
extern DetectionCluster_AlgorithmParametersEntry_DoNotUseDefaultTypeInternal _DetectionCluster_AlgorithmParametersEntry_DoNotUse_default_instance_;
class FusionData;
struct FusionDataDefaultTypeInternal;
extern FusionDataDefaultTypeInternal _FusionData_default_instance_;
class FusionData_SensorWeightsEntry_DoNotUse;
struct FusionData_SensorWeightsEntry_DoNotUseDefaultTypeInternal;
extern FusionData_SensorWeightsEntry_DoNotUseDefaultTypeInternal _FusionData_SensorWeightsEntry_DoNotUse_default_instance_;
class SystemConfiguration;
struct SystemConfigurationDefaultTypeInternal;
extern SystemConfigurationDefaultTypeInternal _SystemConfiguration_default_instance_;
class SystemConfiguration_AssociationParamsEntry_DoNotUse;
struct SystemConfiguration_AssociationParamsEntry_DoNotUseDefaultTypeInternal;
extern SystemConfiguration_AssociationParamsEntry_DoNotUseDefaultTypeInternal _SystemConfiguration_AssociationParamsEntry_DoNotUse_default_instance_;
class SystemConfiguration_ClusteringParamsEntry_DoNotUse;
struct SystemConfiguration_ClusteringParamsEntry_DoNotUseDefaultTypeInternal;
extern SystemConfiguration_ClusteringParamsEntry_DoNotUseDefaultTypeInternal _SystemConfiguration_ClusteringParamsEntry_DoNotUse_default_instance_;
class SystemConfiguration_FilterParamsEntry_DoNotUse;
struct SystemConfiguration_FilterParamsEntry_DoNotUseDefaultTypeInternal;
extern SystemConfiguration_FilterParamsEntry_DoNotUseDefaultTypeInternal _SystemConfiguration_FilterParamsEntry_DoNotUse_default_instance_;
class ThreatAssessment;
struct ThreatAssessmentDefaultTypeInternal;
extern ThreatAssessmentDefaultTypeInternal _ThreatAssessment_default_instance_;
class Track;
struct TrackDefaultTypeInternal;
extern TrackDefaultTypeInternal _Track_default_instance_;
class TrackBatch;
struct TrackBatchDefaultTypeInternal;
extern TrackBatchDefaultTypeInternal _TrackBatch_default_instance_;
class TrackHistory;
struct TrackHistoryDefaultTypeInternal;
extern TrackHistoryDefaultTypeInternal _TrackHistory_default_instance_;
class TrackState;
struct TrackStateDefaultTypeInternal;
extern TrackStateDefaultTypeInternal _TrackState_default_instance_;
class TrackUpdate;
struct TrackUpdateDefaultTypeInternal;
extern TrackUpdateDefaultTypeInternal _TrackUpdate_default_instance_;
class TrackUpdate_UpdateDataEntry_DoNotUse;
struct TrackUpdate_UpdateDataEntry_DoNotUseDefaultTypeInternal;
extern TrackUpdate_UpdateDataEntry_DoNotUseDefaultTypeInternal _TrackUpdate_UpdateDataEntry_DoNotUse_default_instance_;
class Track_AttributesEntry_DoNotUse;
struct Track_AttributesEntry_DoNotUseDefaultTypeInternal;
extern Track_AttributesEntry_DoNotUseDefaultTypeInternal _Track_AttributesEntry_DoNotUse_default_instance_;
class Track_ClassificationScoresEntry_DoNotUse;
struct Track_ClassificationScoresEntry_DoNotUseDefaultTypeInternal;
extern Track_ClassificationScoresEntry_DoNotUseDefaultTypeInternal _Track_ClassificationScoresEntry_DoNotUse_default_instance_;
}  // namespace messages
}  // namespace radar
PROTOBUF_NAMESPACE_OPEN
template<> ::radar::messages::Association* Arena::CreateMaybeMessage<::radar::messages::Association>(Arena*);
template<> ::radar::messages::DetectionCluster* Arena::CreateMaybeMessage<::radar::messages::DetectionCluster>(Arena*);
template<> ::radar::messages::DetectionCluster_AlgorithmParametersEntry_DoNotUse* Arena::CreateMaybeMessage<::radar::messages::DetectionCluster_AlgorithmParametersEntry_DoNotUse>(Arena*);
template<> ::radar::messages::FusionData* Arena::CreateMaybeMessage<::radar::messages::FusionData>(Arena*);
template<> ::radar::messages::FusionData_SensorWeightsEntry_DoNotUse* Arena::CreateMaybeMessage<::radar::messages::FusionData_SensorWeightsEntry_DoNotUse>(Arena*);
template<> ::radar::messages::SystemConfiguration* Arena::CreateMaybeMessage<::radar::messages::SystemConfiguration>(Arena*);
template<> ::radar::messages::SystemConfiguration_AssociationParamsEntry_DoNotUse* Arena::CreateMaybeMessage<::radar::messages::SystemConfiguration_AssociationParamsEntry_DoNotUse>(Arena*);
template<> ::radar::messages::SystemConfiguration_ClusteringParamsEntry_DoNotUse* Arena::CreateMaybeMessage<::radar::messages::SystemConfiguration_ClusteringParamsEntry_DoNotUse>(Arena*);
template<> ::radar::messages::SystemConfiguration_FilterParamsEntry_DoNotUse* Arena::CreateMaybeMessage<::radar::messages::SystemConfiguration_FilterParamsEntry_DoNotUse>(Arena*);
template<> ::radar::messages::ThreatAssessment* Arena::CreateMaybeMessage<::radar::messages::ThreatAssessment>(Arena*);
template<> ::radar::messages::Track* Arena::CreateMaybeMessage<::radar::messages::Track>(Arena*);
template<> ::radar::messages::TrackBatch* Arena::CreateMaybeMessage<::radar::messages::TrackBatch>(Arena*);
template<> ::radar::messages::TrackHistory* Arena::CreateMaybeMessage<::radar::messages::TrackHistory>(Arena*);
template<> ::radar::messages::TrackState* Arena::CreateMaybeMessage<::radar::messages::TrackState>(Arena*);
template<> ::radar::messages::TrackUpdate* Arena::CreateMaybeMessage<::radar::messages::TrackUpdate>(Arena*);
template<> ::radar::messages::TrackUpdate_UpdateDataEntry_DoNotUse* Arena::CreateMaybeMessage<::radar::messages::TrackUpdate_UpdateDataEntry_DoNotUse>(Arena*);
template<> ::radar::messages::Track_AttributesEntry_DoNotUse* Arena::CreateMaybeMessage<::radar::messages::Track_AttributesEntry_DoNotUse>(Arena*);
template<> ::radar::messages::Track_ClassificationScoresEntry_DoNotUse* Arena::CreateMaybeMessage<::radar::messages::Track_ClassificationScoresEntry_DoNotUse>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace radar {
namespace messages {

enum TrackUpdate_UpdateType : int {
  TrackUpdate_UpdateType_UPDATE_TYPE_UNSPECIFIED = 0,
  TrackUpdate_UpdateType_BIRTH = 1,
  TrackUpdate_UpdateType_UPDATE = 2,
  TrackUpdate_UpdateType_PREDICT = 3,
  TrackUpdate_UpdateType_CONFIRM = 4,
  TrackUpdate_UpdateType_DELETE = 5,
  TrackUpdate_UpdateType_MERGE = 6,
  TrackUpdate_UpdateType_SPLIT = 7,
  TrackUpdate_UpdateType_TrackUpdate_UpdateType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  TrackUpdate_UpdateType_TrackUpdate_UpdateType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool TrackUpdate_UpdateType_IsValid(int value);
constexpr TrackUpdate_UpdateType TrackUpdate_UpdateType_UpdateType_MIN = TrackUpdate_UpdateType_UPDATE_TYPE_UNSPECIFIED;
constexpr TrackUpdate_UpdateType TrackUpdate_UpdateType_UpdateType_MAX = TrackUpdate_UpdateType_SPLIT;
constexpr int TrackUpdate_UpdateType_UpdateType_ARRAYSIZE = TrackUpdate_UpdateType_UpdateType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TrackUpdate_UpdateType_descriptor();
template<typename T>
inline const std::string& TrackUpdate_UpdateType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TrackUpdate_UpdateType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TrackUpdate_UpdateType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    TrackUpdate_UpdateType_descriptor(), enum_t_value);
}
inline bool TrackUpdate_UpdateType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TrackUpdate_UpdateType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<TrackUpdate_UpdateType>(
    TrackUpdate_UpdateType_descriptor(), name, value);
}
enum DetectionCluster_ClusteringAlgorithm : int {
  DetectionCluster_ClusteringAlgorithm_CLUSTERING_ALGORITHM_UNSPECIFIED = 0,
  DetectionCluster_ClusteringAlgorithm_DBSCAN = 1,
  DetectionCluster_ClusteringAlgorithm_KMEANS = 2,
  DetectionCluster_ClusteringAlgorithm_HIERARCHICAL = 3,
  DetectionCluster_ClusteringAlgorithm_CLUSTERING_CUSTOM = 4,
  DetectionCluster_ClusteringAlgorithm_DetectionCluster_ClusteringAlgorithm_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  DetectionCluster_ClusteringAlgorithm_DetectionCluster_ClusteringAlgorithm_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool DetectionCluster_ClusteringAlgorithm_IsValid(int value);
constexpr DetectionCluster_ClusteringAlgorithm DetectionCluster_ClusteringAlgorithm_ClusteringAlgorithm_MIN = DetectionCluster_ClusteringAlgorithm_CLUSTERING_ALGORITHM_UNSPECIFIED;
constexpr DetectionCluster_ClusteringAlgorithm DetectionCluster_ClusteringAlgorithm_ClusteringAlgorithm_MAX = DetectionCluster_ClusteringAlgorithm_CLUSTERING_CUSTOM;
constexpr int DetectionCluster_ClusteringAlgorithm_ClusteringAlgorithm_ARRAYSIZE = DetectionCluster_ClusteringAlgorithm_ClusteringAlgorithm_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* DetectionCluster_ClusteringAlgorithm_descriptor();
template<typename T>
inline const std::string& DetectionCluster_ClusteringAlgorithm_Name(T enum_t_value) {
  static_assert(::std::is_same<T, DetectionCluster_ClusteringAlgorithm>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function DetectionCluster_ClusteringAlgorithm_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    DetectionCluster_ClusteringAlgorithm_descriptor(), enum_t_value);
}
inline bool DetectionCluster_ClusteringAlgorithm_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, DetectionCluster_ClusteringAlgorithm* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<DetectionCluster_ClusteringAlgorithm>(
    DetectionCluster_ClusteringAlgorithm_descriptor(), name, value);
}
enum Association_AssociationAlgorithm : int {
  Association_AssociationAlgorithm_ASSOCIATION_ALGORITHM_UNSPECIFIED = 0,
  Association_AssociationAlgorithm_NEAREST_NEIGHBOR = 1,
  Association_AssociationAlgorithm_GLOBAL_NEAREST_NEIGHBOR = 2,
  Association_AssociationAlgorithm_JOINT_PROBABILISTIC = 3,
  Association_AssociationAlgorithm_MULTIPLE_HYPOTHESIS = 4,
  Association_AssociationAlgorithm_ASSOCIATION_CUSTOM = 5,
  Association_AssociationAlgorithm_Association_AssociationAlgorithm_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  Association_AssociationAlgorithm_Association_AssociationAlgorithm_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool Association_AssociationAlgorithm_IsValid(int value);
constexpr Association_AssociationAlgorithm Association_AssociationAlgorithm_AssociationAlgorithm_MIN = Association_AssociationAlgorithm_ASSOCIATION_ALGORITHM_UNSPECIFIED;
constexpr Association_AssociationAlgorithm Association_AssociationAlgorithm_AssociationAlgorithm_MAX = Association_AssociationAlgorithm_ASSOCIATION_CUSTOM;
constexpr int Association_AssociationAlgorithm_AssociationAlgorithm_ARRAYSIZE = Association_AssociationAlgorithm_AssociationAlgorithm_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Association_AssociationAlgorithm_descriptor();
template<typename T>
inline const std::string& Association_AssociationAlgorithm_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Association_AssociationAlgorithm>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Association_AssociationAlgorithm_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Association_AssociationAlgorithm_descriptor(), enum_t_value);
}
inline bool Association_AssociationAlgorithm_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Association_AssociationAlgorithm* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Association_AssociationAlgorithm>(
    Association_AssociationAlgorithm_descriptor(), name, value);
}
enum ThreatAssessment_ThreatLevel : int {
  ThreatAssessment_ThreatLevel_THREAT_LEVEL_UNSPECIFIED = 0,
  ThreatAssessment_ThreatLevel_LOW = 1,
  ThreatAssessment_ThreatLevel_MEDIUM = 2,
  ThreatAssessment_ThreatLevel_HIGH = 3,
  ThreatAssessment_ThreatLevel_CRITICAL = 4,
  ThreatAssessment_ThreatLevel_ThreatAssessment_ThreatLevel_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  ThreatAssessment_ThreatLevel_ThreatAssessment_ThreatLevel_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool ThreatAssessment_ThreatLevel_IsValid(int value);
constexpr ThreatAssessment_ThreatLevel ThreatAssessment_ThreatLevel_ThreatLevel_MIN = ThreatAssessment_ThreatLevel_THREAT_LEVEL_UNSPECIFIED;
constexpr ThreatAssessment_ThreatLevel ThreatAssessment_ThreatLevel_ThreatLevel_MAX = ThreatAssessment_ThreatLevel_CRITICAL;
constexpr int ThreatAssessment_ThreatLevel_ThreatLevel_ARRAYSIZE = ThreatAssessment_ThreatLevel_ThreatLevel_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ThreatAssessment_ThreatLevel_descriptor();
template<typename T>
inline const std::string& ThreatAssessment_ThreatLevel_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ThreatAssessment_ThreatLevel>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ThreatAssessment_ThreatLevel_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ThreatAssessment_ThreatLevel_descriptor(), enum_t_value);
}
inline bool ThreatAssessment_ThreatLevel_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ThreatAssessment_ThreatLevel* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ThreatAssessment_ThreatLevel>(
    ThreatAssessment_ThreatLevel_descriptor(), name, value);
}
enum FilterType : int {
  FILTER_TYPE_UNSPECIFIED = 0,
  KALMAN = 1,
  EXTENDED_KALMAN = 2,
  UNSCENTED_KALMAN = 3,
  IMM = 4,
  PARTICLE = 5,
  FILTER_CUSTOM = 6,
  FilterType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  FilterType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool FilterType_IsValid(int value);
constexpr FilterType FilterType_MIN = FILTER_TYPE_UNSPECIFIED;
constexpr FilterType FilterType_MAX = FILTER_CUSTOM;
constexpr int FilterType_ARRAYSIZE = FilterType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* FilterType_descriptor();
template<typename T>
inline const std::string& FilterType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, FilterType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function FilterType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    FilterType_descriptor(), enum_t_value);
}
inline bool FilterType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, FilterType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<FilterType>(
    FilterType_descriptor(), name, value);
}
// ===================================================================

class TrackState final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:radar.messages.TrackState) */ {
 public:
  inline TrackState() : TrackState(nullptr) {}
  ~TrackState() override;
  explicit PROTOBUF_CONSTEXPR TrackState(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TrackState(const TrackState& from);
  TrackState(TrackState&& from) noexcept
    : TrackState() {
    *this = ::std::move(from);
  }

  inline TrackState& operator=(const TrackState& from) {
    CopyFrom(from);
    return *this;
  }
  inline TrackState& operator=(TrackState&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TrackState& default_instance() {
    return *internal_default_instance();
  }
  static inline const TrackState* internal_default_instance() {
    return reinterpret_cast<const TrackState*>(
               &_TrackState_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(TrackState& a, TrackState& b) {
    a.Swap(&b);
  }
  inline void Swap(TrackState* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TrackState* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TrackState* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TrackState>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TrackState& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TrackState& from) {
    TrackState::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TrackState* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "radar.messages.TrackState";
  }
  protected:
  explicit TrackState(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStateFieldNumber = 1,
    kCovarianceFieldNumber = 2,
    kPositionFieldNumber = 5,
    kVelocityFieldNumber = 6,
    kAccelerationFieldNumber = 7,
    kStateSizeFieldNumber = 3,
    kMotionModelFieldNumber = 4,
  };
  // repeated double state = 1;
  int state_size() const;
  private:
  int _internal_state_size() const;
  public:
  void clear_state();
  private:
  double _internal_state(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
      _internal_state() const;
  void _internal_add_state(double value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
      _internal_mutable_state();
  public:
  double state(int index) const;
  void set_state(int index, double value);
  void add_state(double value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
      state() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
      mutable_state();

  // repeated double covariance = 2;
  int covariance_size() const;
  private:
  int _internal_covariance_size() const;
  public:
  void clear_covariance();
  private:
  double _internal_covariance(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
      _internal_covariance() const;
  void _internal_add_covariance(double value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
      _internal_mutable_covariance();
  public:
  double covariance(int index) const;
  void set_covariance(int index, double value);
  void add_covariance(double value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
      covariance() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
      mutable_covariance();

  // .radar.messages.Point3D position = 5;
  bool has_position() const;
  private:
  bool _internal_has_position() const;
  public:
  void clear_position();
  const ::radar::messages::Point3D& position() const;
  PROTOBUF_NODISCARD ::radar::messages::Point3D* release_position();
  ::radar::messages::Point3D* mutable_position();
  void set_allocated_position(::radar::messages::Point3D* position);
  private:
  const ::radar::messages::Point3D& _internal_position() const;
  ::radar::messages::Point3D* _internal_mutable_position();
  public:
  void unsafe_arena_set_allocated_position(
      ::radar::messages::Point3D* position);
  ::radar::messages::Point3D* unsafe_arena_release_position();

  // .radar.messages.Vector3D velocity = 6;
  bool has_velocity() const;
  private:
  bool _internal_has_velocity() const;
  public:
  void clear_velocity();
  const ::radar::messages::Vector3D& velocity() const;
  PROTOBUF_NODISCARD ::radar::messages::Vector3D* release_velocity();
  ::radar::messages::Vector3D* mutable_velocity();
  void set_allocated_velocity(::radar::messages::Vector3D* velocity);
  private:
  const ::radar::messages::Vector3D& _internal_velocity() const;
  ::radar::messages::Vector3D* _internal_mutable_velocity();
  public:
  void unsafe_arena_set_allocated_velocity(
      ::radar::messages::Vector3D* velocity);
  ::radar::messages::Vector3D* unsafe_arena_release_velocity();

  // .radar.messages.Vector3D acceleration = 7;
  bool has_acceleration() const;
  private:
  bool _internal_has_acceleration() const;
  public:
  void clear_acceleration();
  const ::radar::messages::Vector3D& acceleration() const;
  PROTOBUF_NODISCARD ::radar::messages::Vector3D* release_acceleration();
  ::radar::messages::Vector3D* mutable_acceleration();
  void set_allocated_acceleration(::radar::messages::Vector3D* acceleration);
  private:
  const ::radar::messages::Vector3D& _internal_acceleration() const;
  ::radar::messages::Vector3D* _internal_mutable_acceleration();
  public:
  void unsafe_arena_set_allocated_acceleration(
      ::radar::messages::Vector3D* acceleration);
  ::radar::messages::Vector3D* unsafe_arena_release_acceleration();

  // uint32 state_size = 3;
  void clear_state_size();
  uint32_t state_size() const;
  void set_state_size(uint32_t value);
  private:
  uint32_t _internal_state_size() const;
  void _internal_set_state_size(uint32_t value);
  public:

  // .radar.messages.MotionModel motion_model = 4;
  void clear_motion_model();
  ::radar::messages::MotionModel motion_model() const;
  void set_motion_model(::radar::messages::MotionModel value);
  private:
  ::radar::messages::MotionModel _internal_motion_model() const;
  void _internal_set_motion_model(::radar::messages::MotionModel value);
  public:

  // @@protoc_insertion_point(class_scope:radar.messages.TrackState)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< double > state_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< double > covariance_;
    ::radar::messages::Point3D* position_;
    ::radar::messages::Vector3D* velocity_;
    ::radar::messages::Vector3D* acceleration_;
    uint32_t state_size_;
    int motion_model_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_track_5fmessages_2eproto;
};
// -------------------------------------------------------------------

class Track_ClassificationScoresEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Track_ClassificationScoresEntry_DoNotUse, 
    std::string, double,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_DOUBLE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Track_ClassificationScoresEntry_DoNotUse, 
    std::string, double,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_DOUBLE> SuperType;
  Track_ClassificationScoresEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR Track_ClassificationScoresEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit Track_ClassificationScoresEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const Track_ClassificationScoresEntry_DoNotUse& other);
  static const Track_ClassificationScoresEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const Track_ClassificationScoresEntry_DoNotUse*>(&_Track_ClassificationScoresEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "radar.messages.Track.ClassificationScoresEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_track_5fmessages_2eproto;
};

// -------------------------------------------------------------------

class Track_AttributesEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Track_AttributesEntry_DoNotUse, 
    std::string, double,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_DOUBLE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Track_AttributesEntry_DoNotUse, 
    std::string, double,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_DOUBLE> SuperType;
  Track_AttributesEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR Track_AttributesEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit Track_AttributesEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const Track_AttributesEntry_DoNotUse& other);
  static const Track_AttributesEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const Track_AttributesEntry_DoNotUse*>(&_Track_AttributesEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "radar.messages.Track.AttributesEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_track_5fmessages_2eproto;
};

// -------------------------------------------------------------------

class Track final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:radar.messages.Track) */ {
 public:
  inline Track() : Track(nullptr) {}
  ~Track() override;
  explicit PROTOBUF_CONSTEXPR Track(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Track(const Track& from);
  Track(Track&& from) noexcept
    : Track() {
    *this = ::std::move(from);
  }

  inline Track& operator=(const Track& from) {
    CopyFrom(from);
    return *this;
  }
  inline Track& operator=(Track&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Track& default_instance() {
    return *internal_default_instance();
  }
  static inline const Track* internal_default_instance() {
    return reinterpret_cast<const Track*>(
               &_Track_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(Track& a, Track& b) {
    a.Swap(&b);
  }
  inline void Swap(Track* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Track* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Track* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Track>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Track& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Track& from) {
    Track::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Track* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "radar.messages.Track";
  }
  protected:
  explicit Track(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kClassificationScoresFieldNumber = 15,
    kAttributesFieldNumber = 25,
    kTargetClassFieldNumber = 14,
    kCreatedTimeFieldNumber = 3,
    kLastUpdateTimeFieldNumber = 4,
    kCurrentStateFieldNumber = 5,
    kPredictedStateFieldNumber = 6,
    kStateFieldNumber = 7,
    kIdFieldNumber = 1,
    kSensorIdFieldNumber = 2,
    kHitCountFieldNumber = 8,
    kMissCountFieldNumber = 9,
    kConfidenceFieldNumber = 11,
    kCoastCountFieldNumber = 10,
    kFilterTypeFieldNumber = 13,
    kLikelihoodFieldNumber = 12,
    kTrackQualityFieldNumber = 16,
    kInnovationMagnitudeFieldNumber = 17,
    kMahalanobisDistanceFieldNumber = 18,
    kSpeedFieldNumber = 19,
    kHeadingFieldNumber = 20,
    kTurnRateFieldNumber = 21,
    kRangeFieldNumber = 22,
    kBearingFieldNumber = 23,
    kElevationFieldNumber = 24,
  };
  // map<string, double> classification_scores = 15;
  int classification_scores_size() const;
  private:
  int _internal_classification_scores_size() const;
  public:
  void clear_classification_scores();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >&
      _internal_classification_scores() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >*
      _internal_mutable_classification_scores();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >&
      classification_scores() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >*
      mutable_classification_scores();

  // map<string, double> attributes = 25;
  int attributes_size() const;
  private:
  int _internal_attributes_size() const;
  public:
  void clear_attributes();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >&
      _internal_attributes() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >*
      _internal_mutable_attributes();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >&
      attributes() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >*
      mutable_attributes();

  // string target_class = 14;
  void clear_target_class();
  const std::string& target_class() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_target_class(ArgT0&& arg0, ArgT... args);
  std::string* mutable_target_class();
  PROTOBUF_NODISCARD std::string* release_target_class();
  void set_allocated_target_class(std::string* target_class);
  private:
  const std::string& _internal_target_class() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_target_class(const std::string& value);
  std::string* _internal_mutable_target_class();
  public:

  // .google.protobuf.Timestamp created_time = 3;
  bool has_created_time() const;
  private:
  bool _internal_has_created_time() const;
  public:
  void clear_created_time();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& created_time() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_created_time();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_created_time();
  void set_allocated_created_time(::PROTOBUF_NAMESPACE_ID::Timestamp* created_time);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_created_time() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_created_time();
  public:
  void unsafe_arena_set_allocated_created_time(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* created_time);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_created_time();

  // .google.protobuf.Timestamp last_update_time = 4;
  bool has_last_update_time() const;
  private:
  bool _internal_has_last_update_time() const;
  public:
  void clear_last_update_time();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& last_update_time() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_last_update_time();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_last_update_time();
  void set_allocated_last_update_time(::PROTOBUF_NAMESPACE_ID::Timestamp* last_update_time);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_last_update_time() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_last_update_time();
  public:
  void unsafe_arena_set_allocated_last_update_time(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* last_update_time);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_last_update_time();

  // .radar.messages.TrackState current_state = 5;
  bool has_current_state() const;
  private:
  bool _internal_has_current_state() const;
  public:
  void clear_current_state();
  const ::radar::messages::TrackState& current_state() const;
  PROTOBUF_NODISCARD ::radar::messages::TrackState* release_current_state();
  ::radar::messages::TrackState* mutable_current_state();
  void set_allocated_current_state(::radar::messages::TrackState* current_state);
  private:
  const ::radar::messages::TrackState& _internal_current_state() const;
  ::radar::messages::TrackState* _internal_mutable_current_state();
  public:
  void unsafe_arena_set_allocated_current_state(
      ::radar::messages::TrackState* current_state);
  ::radar::messages::TrackState* unsafe_arena_release_current_state();

  // .radar.messages.TrackState predicted_state = 6;
  bool has_predicted_state() const;
  private:
  bool _internal_has_predicted_state() const;
  public:
  void clear_predicted_state();
  const ::radar::messages::TrackState& predicted_state() const;
  PROTOBUF_NODISCARD ::radar::messages::TrackState* release_predicted_state();
  ::radar::messages::TrackState* mutable_predicted_state();
  void set_allocated_predicted_state(::radar::messages::TrackState* predicted_state);
  private:
  const ::radar::messages::TrackState& _internal_predicted_state() const;
  ::radar::messages::TrackState* _internal_mutable_predicted_state();
  public:
  void unsafe_arena_set_allocated_predicted_state(
      ::radar::messages::TrackState* predicted_state);
  ::radar::messages::TrackState* unsafe_arena_release_predicted_state();

  // .radar.messages.TrackState state = 7;
  bool has_state() const;
  private:
  bool _internal_has_state() const;
  public:
  void clear_state();
  const ::radar::messages::TrackState& state() const;
  PROTOBUF_NODISCARD ::radar::messages::TrackState* release_state();
  ::radar::messages::TrackState* mutable_state();
  void set_allocated_state(::radar::messages::TrackState* state);
  private:
  const ::radar::messages::TrackState& _internal_state() const;
  ::radar::messages::TrackState* _internal_mutable_state();
  public:
  void unsafe_arena_set_allocated_state(
      ::radar::messages::TrackState* state);
  ::radar::messages::TrackState* unsafe_arena_release_state();

  // uint32 id = 1;
  void clear_id();
  uint32_t id() const;
  void set_id(uint32_t value);
  private:
  uint32_t _internal_id() const;
  void _internal_set_id(uint32_t value);
  public:

  // uint32 sensor_id = 2;
  void clear_sensor_id();
  uint32_t sensor_id() const;
  void set_sensor_id(uint32_t value);
  private:
  uint32_t _internal_sensor_id() const;
  void _internal_set_sensor_id(uint32_t value);
  public:

  // uint32 hit_count = 8;
  void clear_hit_count();
  uint32_t hit_count() const;
  void set_hit_count(uint32_t value);
  private:
  uint32_t _internal_hit_count() const;
  void _internal_set_hit_count(uint32_t value);
  public:

  // uint32 miss_count = 9;
  void clear_miss_count();
  uint32_t miss_count() const;
  void set_miss_count(uint32_t value);
  private:
  uint32_t _internal_miss_count() const;
  void _internal_set_miss_count(uint32_t value);
  public:

  // double confidence = 11;
  void clear_confidence();
  double confidence() const;
  void set_confidence(double value);
  private:
  double _internal_confidence() const;
  void _internal_set_confidence(double value);
  public:

  // uint32 coast_count = 10;
  void clear_coast_count();
  uint32_t coast_count() const;
  void set_coast_count(uint32_t value);
  private:
  uint32_t _internal_coast_count() const;
  void _internal_set_coast_count(uint32_t value);
  public:

  // .radar.messages.FilterType filter_type = 13;
  void clear_filter_type();
  ::radar::messages::FilterType filter_type() const;
  void set_filter_type(::radar::messages::FilterType value);
  private:
  ::radar::messages::FilterType _internal_filter_type() const;
  void _internal_set_filter_type(::radar::messages::FilterType value);
  public:

  // double likelihood = 12;
  void clear_likelihood();
  double likelihood() const;
  void set_likelihood(double value);
  private:
  double _internal_likelihood() const;
  void _internal_set_likelihood(double value);
  public:

  // double track_quality = 16;
  void clear_track_quality();
  double track_quality() const;
  void set_track_quality(double value);
  private:
  double _internal_track_quality() const;
  void _internal_set_track_quality(double value);
  public:

  // double innovation_magnitude = 17;
  void clear_innovation_magnitude();
  double innovation_magnitude() const;
  void set_innovation_magnitude(double value);
  private:
  double _internal_innovation_magnitude() const;
  void _internal_set_innovation_magnitude(double value);
  public:

  // double mahalanobis_distance = 18;
  void clear_mahalanobis_distance();
  double mahalanobis_distance() const;
  void set_mahalanobis_distance(double value);
  private:
  double _internal_mahalanobis_distance() const;
  void _internal_set_mahalanobis_distance(double value);
  public:

  // double speed = 19;
  void clear_speed();
  double speed() const;
  void set_speed(double value);
  private:
  double _internal_speed() const;
  void _internal_set_speed(double value);
  public:

  // double heading = 20;
  void clear_heading();
  double heading() const;
  void set_heading(double value);
  private:
  double _internal_heading() const;
  void _internal_set_heading(double value);
  public:

  // double turn_rate = 21;
  void clear_turn_rate();
  double turn_rate() const;
  void set_turn_rate(double value);
  private:
  double _internal_turn_rate() const;
  void _internal_set_turn_rate(double value);
  public:

  // double range = 22;
  void clear_range();
  double range() const;
  void set_range(double value);
  private:
  double _internal_range() const;
  void _internal_set_range(double value);
  public:

  // double bearing = 23;
  void clear_bearing();
  double bearing() const;
  void set_bearing(double value);
  private:
  double _internal_bearing() const;
  void _internal_set_bearing(double value);
  public:

  // double elevation = 24;
  void clear_elevation();
  double elevation() const;
  void set_elevation(double value);
  private:
  double _internal_elevation() const;
  void _internal_set_elevation(double value);
  public:

  // @@protoc_insertion_point(class_scope:radar.messages.Track)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        Track_ClassificationScoresEntry_DoNotUse,
        std::string, double,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_DOUBLE> classification_scores_;
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        Track_AttributesEntry_DoNotUse,
        std::string, double,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_DOUBLE> attributes_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr target_class_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* created_time_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* last_update_time_;
    ::radar::messages::TrackState* current_state_;
    ::radar::messages::TrackState* predicted_state_;
    ::radar::messages::TrackState* state_;
    uint32_t id_;
    uint32_t sensor_id_;
    uint32_t hit_count_;
    uint32_t miss_count_;
    double confidence_;
    uint32_t coast_count_;
    int filter_type_;
    double likelihood_;
    double track_quality_;
    double innovation_magnitude_;
    double mahalanobis_distance_;
    double speed_;
    double heading_;
    double turn_rate_;
    double range_;
    double bearing_;
    double elevation_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_track_5fmessages_2eproto;
};
// -------------------------------------------------------------------

class TrackBatch final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:radar.messages.TrackBatch) */ {
 public:
  inline TrackBatch() : TrackBatch(nullptr) {}
  ~TrackBatch() override;
  explicit PROTOBUF_CONSTEXPR TrackBatch(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TrackBatch(const TrackBatch& from);
  TrackBatch(TrackBatch&& from) noexcept
    : TrackBatch() {
    *this = ::std::move(from);
  }

  inline TrackBatch& operator=(const TrackBatch& from) {
    CopyFrom(from);
    return *this;
  }
  inline TrackBatch& operator=(TrackBatch&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TrackBatch& default_instance() {
    return *internal_default_instance();
  }
  static inline const TrackBatch* internal_default_instance() {
    return reinterpret_cast<const TrackBatch*>(
               &_TrackBatch_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(TrackBatch& a, TrackBatch& b) {
    a.Swap(&b);
  }
  inline void Swap(TrackBatch* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TrackBatch* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TrackBatch* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TrackBatch>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TrackBatch& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TrackBatch& from) {
    TrackBatch::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TrackBatch* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "radar.messages.TrackBatch";
  }
  protected:
  explicit TrackBatch(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTracksFieldNumber = 1,
    kBatchTimestampFieldNumber = 2,
    kPerformanceFieldNumber = 14,
    kSensorIdFieldNumber = 3,
    kSequenceNumberFieldNumber = 4,
    kProcessingTimeMsFieldNumber = 5,
    kTotalTracksFieldNumber = 6,
    kConfirmedTracksFieldNumber = 7,
    kTentativeTracksFieldNumber = 8,
    kCoastingTracksFieldNumber = 9,
    kDeletedTracksFieldNumber = 10,
    kTotalAssociationsFieldNumber = 11,
    kAssociationRateFieldNumber = 13,
    kSuccessfulAssociationsFieldNumber = 12,
  };
  // repeated .radar.messages.Track tracks = 1;
  int tracks_size() const;
  private:
  int _internal_tracks_size() const;
  public:
  void clear_tracks();
  ::radar::messages::Track* mutable_tracks(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::radar::messages::Track >*
      mutable_tracks();
  private:
  const ::radar::messages::Track& _internal_tracks(int index) const;
  ::radar::messages::Track* _internal_add_tracks();
  public:
  const ::radar::messages::Track& tracks(int index) const;
  ::radar::messages::Track* add_tracks();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::radar::messages::Track >&
      tracks() const;

  // .google.protobuf.Timestamp batch_timestamp = 2;
  bool has_batch_timestamp() const;
  private:
  bool _internal_has_batch_timestamp() const;
  public:
  void clear_batch_timestamp();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& batch_timestamp() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_batch_timestamp();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_batch_timestamp();
  void set_allocated_batch_timestamp(::PROTOBUF_NAMESPACE_ID::Timestamp* batch_timestamp);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_batch_timestamp() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_batch_timestamp();
  public:
  void unsafe_arena_set_allocated_batch_timestamp(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* batch_timestamp);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_batch_timestamp();

  // .radar.messages.PerformanceMetrics performance = 14;
  bool has_performance() const;
  private:
  bool _internal_has_performance() const;
  public:
  void clear_performance();
  const ::radar::messages::PerformanceMetrics& performance() const;
  PROTOBUF_NODISCARD ::radar::messages::PerformanceMetrics* release_performance();
  ::radar::messages::PerformanceMetrics* mutable_performance();
  void set_allocated_performance(::radar::messages::PerformanceMetrics* performance);
  private:
  const ::radar::messages::PerformanceMetrics& _internal_performance() const;
  ::radar::messages::PerformanceMetrics* _internal_mutable_performance();
  public:
  void unsafe_arena_set_allocated_performance(
      ::radar::messages::PerformanceMetrics* performance);
  ::radar::messages::PerformanceMetrics* unsafe_arena_release_performance();

  // uint32 sensor_id = 3;
  void clear_sensor_id();
  uint32_t sensor_id() const;
  void set_sensor_id(uint32_t value);
  private:
  uint32_t _internal_sensor_id() const;
  void _internal_set_sensor_id(uint32_t value);
  public:

  // uint32 sequence_number = 4;
  void clear_sequence_number();
  uint32_t sequence_number() const;
  void set_sequence_number(uint32_t value);
  private:
  uint32_t _internal_sequence_number() const;
  void _internal_set_sequence_number(uint32_t value);
  public:

  // double processing_time_ms = 5;
  void clear_processing_time_ms();
  double processing_time_ms() const;
  void set_processing_time_ms(double value);
  private:
  double _internal_processing_time_ms() const;
  void _internal_set_processing_time_ms(double value);
  public:

  // uint32 total_tracks = 6;
  void clear_total_tracks();
  uint32_t total_tracks() const;
  void set_total_tracks(uint32_t value);
  private:
  uint32_t _internal_total_tracks() const;
  void _internal_set_total_tracks(uint32_t value);
  public:

  // uint32 confirmed_tracks = 7;
  void clear_confirmed_tracks();
  uint32_t confirmed_tracks() const;
  void set_confirmed_tracks(uint32_t value);
  private:
  uint32_t _internal_confirmed_tracks() const;
  void _internal_set_confirmed_tracks(uint32_t value);
  public:

  // uint32 tentative_tracks = 8;
  void clear_tentative_tracks();
  uint32_t tentative_tracks() const;
  void set_tentative_tracks(uint32_t value);
  private:
  uint32_t _internal_tentative_tracks() const;
  void _internal_set_tentative_tracks(uint32_t value);
  public:

  // uint32 coasting_tracks = 9;
  void clear_coasting_tracks();
  uint32_t coasting_tracks() const;
  void set_coasting_tracks(uint32_t value);
  private:
  uint32_t _internal_coasting_tracks() const;
  void _internal_set_coasting_tracks(uint32_t value);
  public:

  // uint32 deleted_tracks = 10;
  void clear_deleted_tracks();
  uint32_t deleted_tracks() const;
  void set_deleted_tracks(uint32_t value);
  private:
  uint32_t _internal_deleted_tracks() const;
  void _internal_set_deleted_tracks(uint32_t value);
  public:

  // uint32 total_associations = 11;
  void clear_total_associations();
  uint32_t total_associations() const;
  void set_total_associations(uint32_t value);
  private:
  uint32_t _internal_total_associations() const;
  void _internal_set_total_associations(uint32_t value);
  public:

  // double association_rate = 13;
  void clear_association_rate();
  double association_rate() const;
  void set_association_rate(double value);
  private:
  double _internal_association_rate() const;
  void _internal_set_association_rate(double value);
  public:

  // uint32 successful_associations = 12;
  void clear_successful_associations();
  uint32_t successful_associations() const;
  void set_successful_associations(uint32_t value);
  private:
  uint32_t _internal_successful_associations() const;
  void _internal_set_successful_associations(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:radar.messages.TrackBatch)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::radar::messages::Track > tracks_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* batch_timestamp_;
    ::radar::messages::PerformanceMetrics* performance_;
    uint32_t sensor_id_;
    uint32_t sequence_number_;
    double processing_time_ms_;
    uint32_t total_tracks_;
    uint32_t confirmed_tracks_;
    uint32_t tentative_tracks_;
    uint32_t coasting_tracks_;
    uint32_t deleted_tracks_;
    uint32_t total_associations_;
    double association_rate_;
    uint32_t successful_associations_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_track_5fmessages_2eproto;
};
// -------------------------------------------------------------------

class TrackUpdate_UpdateDataEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<TrackUpdate_UpdateDataEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<TrackUpdate_UpdateDataEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  TrackUpdate_UpdateDataEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR TrackUpdate_UpdateDataEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit TrackUpdate_UpdateDataEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const TrackUpdate_UpdateDataEntry_DoNotUse& other);
  static const TrackUpdate_UpdateDataEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const TrackUpdate_UpdateDataEntry_DoNotUse*>(&_TrackUpdate_UpdateDataEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "radar.messages.TrackUpdate.UpdateDataEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "radar.messages.TrackUpdate.UpdateDataEntry.value");
 }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_track_5fmessages_2eproto;
};

// -------------------------------------------------------------------

class TrackUpdate final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:radar.messages.TrackUpdate) */ {
 public:
  inline TrackUpdate() : TrackUpdate(nullptr) {}
  ~TrackUpdate() override;
  explicit PROTOBUF_CONSTEXPR TrackUpdate(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TrackUpdate(const TrackUpdate& from);
  TrackUpdate(TrackUpdate&& from) noexcept
    : TrackUpdate() {
    *this = ::std::move(from);
  }

  inline TrackUpdate& operator=(const TrackUpdate& from) {
    CopyFrom(from);
    return *this;
  }
  inline TrackUpdate& operator=(TrackUpdate&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TrackUpdate& default_instance() {
    return *internal_default_instance();
  }
  static inline const TrackUpdate* internal_default_instance() {
    return reinterpret_cast<const TrackUpdate*>(
               &_TrackUpdate_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(TrackUpdate& a, TrackUpdate& b) {
    a.Swap(&b);
  }
  inline void Swap(TrackUpdate* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TrackUpdate* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TrackUpdate* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TrackUpdate>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TrackUpdate& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TrackUpdate& from) {
    TrackUpdate::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TrackUpdate* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "radar.messages.TrackUpdate";
  }
  protected:
  explicit TrackUpdate(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  typedef TrackUpdate_UpdateType UpdateType;
  static constexpr UpdateType UPDATE_TYPE_UNSPECIFIED =
    TrackUpdate_UpdateType_UPDATE_TYPE_UNSPECIFIED;
  static constexpr UpdateType BIRTH =
    TrackUpdate_UpdateType_BIRTH;
  static constexpr UpdateType UPDATE =
    TrackUpdate_UpdateType_UPDATE;
  static constexpr UpdateType PREDICT =
    TrackUpdate_UpdateType_PREDICT;
  static constexpr UpdateType CONFIRM =
    TrackUpdate_UpdateType_CONFIRM;
  static constexpr UpdateType DELETE =
    TrackUpdate_UpdateType_DELETE;
  static constexpr UpdateType MERGE =
    TrackUpdate_UpdateType_MERGE;
  static constexpr UpdateType SPLIT =
    TrackUpdate_UpdateType_SPLIT;
  static inline bool UpdateType_IsValid(int value) {
    return TrackUpdate_UpdateType_IsValid(value);
  }
  static constexpr UpdateType UpdateType_MIN =
    TrackUpdate_UpdateType_UpdateType_MIN;
  static constexpr UpdateType UpdateType_MAX =
    TrackUpdate_UpdateType_UpdateType_MAX;
  static constexpr int UpdateType_ARRAYSIZE =
    TrackUpdate_UpdateType_UpdateType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  UpdateType_descriptor() {
    return TrackUpdate_UpdateType_descriptor();
  }
  template<typename T>
  static inline const std::string& UpdateType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, UpdateType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function UpdateType_Name.");
    return TrackUpdate_UpdateType_Name(enum_t_value);
  }
  static inline bool UpdateType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      UpdateType* value) {
    return TrackUpdate_UpdateType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kUpdateDataFieldNumber = 8,
    kTimestampFieldNumber = 3,
    kTrackFieldNumber = 5,
    kTrackIdFieldNumber = 1,
    kSensorIdFieldNumber = 2,
    kUpdateTypeFieldNumber = 4,
    kAssociatedDetectionIdFieldNumber = 6,
    kAssociationScoreFieldNumber = 7,
  };
  // map<string, string> update_data = 8;
  int update_data_size() const;
  private:
  int _internal_update_data_size() const;
  public:
  void clear_update_data();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_update_data() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_update_data();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      update_data() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_update_data();

  // .google.protobuf.Timestamp timestamp = 3;
  bool has_timestamp() const;
  private:
  bool _internal_has_timestamp() const;
  public:
  void clear_timestamp();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& timestamp() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_timestamp();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_timestamp();
  void set_allocated_timestamp(::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_timestamp() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_timestamp();
  public:
  void unsafe_arena_set_allocated_timestamp(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_timestamp();

  // .radar.messages.Track track = 5;
  bool has_track() const;
  private:
  bool _internal_has_track() const;
  public:
  void clear_track();
  const ::radar::messages::Track& track() const;
  PROTOBUF_NODISCARD ::radar::messages::Track* release_track();
  ::radar::messages::Track* mutable_track();
  void set_allocated_track(::radar::messages::Track* track);
  private:
  const ::radar::messages::Track& _internal_track() const;
  ::radar::messages::Track* _internal_mutable_track();
  public:
  void unsafe_arena_set_allocated_track(
      ::radar::messages::Track* track);
  ::radar::messages::Track* unsafe_arena_release_track();

  // uint32 track_id = 1;
  void clear_track_id();
  uint32_t track_id() const;
  void set_track_id(uint32_t value);
  private:
  uint32_t _internal_track_id() const;
  void _internal_set_track_id(uint32_t value);
  public:

  // uint32 sensor_id = 2;
  void clear_sensor_id();
  uint32_t sensor_id() const;
  void set_sensor_id(uint32_t value);
  private:
  uint32_t _internal_sensor_id() const;
  void _internal_set_sensor_id(uint32_t value);
  public:

  // .radar.messages.TrackUpdate.UpdateType update_type = 4;
  void clear_update_type();
  ::radar::messages::TrackUpdate_UpdateType update_type() const;
  void set_update_type(::radar::messages::TrackUpdate_UpdateType value);
  private:
  ::radar::messages::TrackUpdate_UpdateType _internal_update_type() const;
  void _internal_set_update_type(::radar::messages::TrackUpdate_UpdateType value);
  public:

  // uint32 associated_detection_id = 6;
  void clear_associated_detection_id();
  uint32_t associated_detection_id() const;
  void set_associated_detection_id(uint32_t value);
  private:
  uint32_t _internal_associated_detection_id() const;
  void _internal_set_associated_detection_id(uint32_t value);
  public:

  // double association_score = 7;
  void clear_association_score();
  double association_score() const;
  void set_association_score(double value);
  private:
  double _internal_association_score() const;
  void _internal_set_association_score(double value);
  public:

  // @@protoc_insertion_point(class_scope:radar.messages.TrackUpdate)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        TrackUpdate_UpdateDataEntry_DoNotUse,
        std::string, std::string,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> update_data_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp_;
    ::radar::messages::Track* track_;
    uint32_t track_id_;
    uint32_t sensor_id_;
    int update_type_;
    uint32_t associated_detection_id_;
    double association_score_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_track_5fmessages_2eproto;
};
// -------------------------------------------------------------------

class TrackHistory final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:radar.messages.TrackHistory) */ {
 public:
  inline TrackHistory() : TrackHistory(nullptr) {}
  ~TrackHistory() override;
  explicit PROTOBUF_CONSTEXPR TrackHistory(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TrackHistory(const TrackHistory& from);
  TrackHistory(TrackHistory&& from) noexcept
    : TrackHistory() {
    *this = ::std::move(from);
  }

  inline TrackHistory& operator=(const TrackHistory& from) {
    CopyFrom(from);
    return *this;
  }
  inline TrackHistory& operator=(TrackHistory&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TrackHistory& default_instance() {
    return *internal_default_instance();
  }
  static inline const TrackHistory* internal_default_instance() {
    return reinterpret_cast<const TrackHistory*>(
               &_TrackHistory_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(TrackHistory& a, TrackHistory& b) {
    a.Swap(&b);
  }
  inline void Swap(TrackHistory* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TrackHistory* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TrackHistory* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TrackHistory>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TrackHistory& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TrackHistory& from) {
    TrackHistory::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TrackHistory* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "radar.messages.TrackHistory";
  }
  protected:
  explicit TrackHistory(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStateHistoryFieldNumber = 3,
    kTimestampsFieldNumber = 4,
    kAssociatedDetectionsFieldNumber = 5,
    kConfidenceHistoryFieldNumber = 10,
    kLikelihoodHistoryFieldNumber = 11,
    kTrackIdFieldNumber = 1,
    kSensorIdFieldNumber = 2,
    kAverageSpeedFieldNumber = 6,
    kMaxSpeedFieldNumber = 7,
    kTotalDistanceFieldNumber = 8,
    kTotalTimeSecondsFieldNumber = 9,
  };
  // repeated .radar.messages.TrackState state_history = 3;
  int state_history_size() const;
  private:
  int _internal_state_history_size() const;
  public:
  void clear_state_history();
  ::radar::messages::TrackState* mutable_state_history(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::radar::messages::TrackState >*
      mutable_state_history();
  private:
  const ::radar::messages::TrackState& _internal_state_history(int index) const;
  ::radar::messages::TrackState* _internal_add_state_history();
  public:
  const ::radar::messages::TrackState& state_history(int index) const;
  ::radar::messages::TrackState* add_state_history();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::radar::messages::TrackState >&
      state_history() const;

  // repeated .google.protobuf.Timestamp timestamps = 4;
  int timestamps_size() const;
  private:
  int _internal_timestamps_size() const;
  public:
  void clear_timestamps();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_timestamps(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PROTOBUF_NAMESPACE_ID::Timestamp >*
      mutable_timestamps();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_timestamps(int index) const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_add_timestamps();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& timestamps(int index) const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* add_timestamps();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PROTOBUF_NAMESPACE_ID::Timestamp >&
      timestamps() const;

  // repeated .radar.messages.Detection associated_detections = 5;
  int associated_detections_size() const;
  private:
  int _internal_associated_detections_size() const;
  public:
  void clear_associated_detections();
  ::radar::messages::Detection* mutable_associated_detections(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::radar::messages::Detection >*
      mutable_associated_detections();
  private:
  const ::radar::messages::Detection& _internal_associated_detections(int index) const;
  ::radar::messages::Detection* _internal_add_associated_detections();
  public:
  const ::radar::messages::Detection& associated_detections(int index) const;
  ::radar::messages::Detection* add_associated_detections();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::radar::messages::Detection >&
      associated_detections() const;

  // repeated double confidence_history = 10;
  int confidence_history_size() const;
  private:
  int _internal_confidence_history_size() const;
  public:
  void clear_confidence_history();
  private:
  double _internal_confidence_history(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
      _internal_confidence_history() const;
  void _internal_add_confidence_history(double value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
      _internal_mutable_confidence_history();
  public:
  double confidence_history(int index) const;
  void set_confidence_history(int index, double value);
  void add_confidence_history(double value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
      confidence_history() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
      mutable_confidence_history();

  // repeated double likelihood_history = 11;
  int likelihood_history_size() const;
  private:
  int _internal_likelihood_history_size() const;
  public:
  void clear_likelihood_history();
  private:
  double _internal_likelihood_history(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
      _internal_likelihood_history() const;
  void _internal_add_likelihood_history(double value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
      _internal_mutable_likelihood_history();
  public:
  double likelihood_history(int index) const;
  void set_likelihood_history(int index, double value);
  void add_likelihood_history(double value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
      likelihood_history() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
      mutable_likelihood_history();

  // uint32 track_id = 1;
  void clear_track_id();
  uint32_t track_id() const;
  void set_track_id(uint32_t value);
  private:
  uint32_t _internal_track_id() const;
  void _internal_set_track_id(uint32_t value);
  public:

  // uint32 sensor_id = 2;
  void clear_sensor_id();
  uint32_t sensor_id() const;
  void set_sensor_id(uint32_t value);
  private:
  uint32_t _internal_sensor_id() const;
  void _internal_set_sensor_id(uint32_t value);
  public:

  // double average_speed = 6;
  void clear_average_speed();
  double average_speed() const;
  void set_average_speed(double value);
  private:
  double _internal_average_speed() const;
  void _internal_set_average_speed(double value);
  public:

  // double max_speed = 7;
  void clear_max_speed();
  double max_speed() const;
  void set_max_speed(double value);
  private:
  double _internal_max_speed() const;
  void _internal_set_max_speed(double value);
  public:

  // double total_distance = 8;
  void clear_total_distance();
  double total_distance() const;
  void set_total_distance(double value);
  private:
  double _internal_total_distance() const;
  void _internal_set_total_distance(double value);
  public:

  // double total_time_seconds = 9;
  void clear_total_time_seconds();
  double total_time_seconds() const;
  void set_total_time_seconds(double value);
  private:
  double _internal_total_time_seconds() const;
  void _internal_set_total_time_seconds(double value);
  public:

  // @@protoc_insertion_point(class_scope:radar.messages.TrackHistory)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::radar::messages::TrackState > state_history_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PROTOBUF_NAMESPACE_ID::Timestamp > timestamps_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::radar::messages::Detection > associated_detections_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< double > confidence_history_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< double > likelihood_history_;
    uint32_t track_id_;
    uint32_t sensor_id_;
    double average_speed_;
    double max_speed_;
    double total_distance_;
    double total_time_seconds_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_track_5fmessages_2eproto;
};
// -------------------------------------------------------------------

class DetectionCluster_AlgorithmParametersEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<DetectionCluster_AlgorithmParametersEntry_DoNotUse, 
    std::string, double,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_DOUBLE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<DetectionCluster_AlgorithmParametersEntry_DoNotUse, 
    std::string, double,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_DOUBLE> SuperType;
  DetectionCluster_AlgorithmParametersEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR DetectionCluster_AlgorithmParametersEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit DetectionCluster_AlgorithmParametersEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const DetectionCluster_AlgorithmParametersEntry_DoNotUse& other);
  static const DetectionCluster_AlgorithmParametersEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const DetectionCluster_AlgorithmParametersEntry_DoNotUse*>(&_DetectionCluster_AlgorithmParametersEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "radar.messages.DetectionCluster.AlgorithmParametersEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_track_5fmessages_2eproto;
};

// -------------------------------------------------------------------

class DetectionCluster final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:radar.messages.DetectionCluster) */ {
 public:
  inline DetectionCluster() : DetectionCluster(nullptr) {}
  ~DetectionCluster() override;
  explicit PROTOBUF_CONSTEXPR DetectionCluster(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DetectionCluster(const DetectionCluster& from);
  DetectionCluster(DetectionCluster&& from) noexcept
    : DetectionCluster() {
    *this = ::std::move(from);
  }

  inline DetectionCluster& operator=(const DetectionCluster& from) {
    CopyFrom(from);
    return *this;
  }
  inline DetectionCluster& operator=(DetectionCluster&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DetectionCluster& default_instance() {
    return *internal_default_instance();
  }
  static inline const DetectionCluster* internal_default_instance() {
    return reinterpret_cast<const DetectionCluster*>(
               &_DetectionCluster_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(DetectionCluster& a, DetectionCluster& b) {
    a.Swap(&b);
  }
  inline void Swap(DetectionCluster* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DetectionCluster* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DetectionCluster* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DetectionCluster>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DetectionCluster& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DetectionCluster& from) {
    DetectionCluster::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DetectionCluster* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "radar.messages.DetectionCluster";
  }
  protected:
  explicit DetectionCluster(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  typedef DetectionCluster_ClusteringAlgorithm ClusteringAlgorithm;
  static constexpr ClusteringAlgorithm CLUSTERING_ALGORITHM_UNSPECIFIED =
    DetectionCluster_ClusteringAlgorithm_CLUSTERING_ALGORITHM_UNSPECIFIED;
  static constexpr ClusteringAlgorithm DBSCAN =
    DetectionCluster_ClusteringAlgorithm_DBSCAN;
  static constexpr ClusteringAlgorithm KMEANS =
    DetectionCluster_ClusteringAlgorithm_KMEANS;
  static constexpr ClusteringAlgorithm HIERARCHICAL =
    DetectionCluster_ClusteringAlgorithm_HIERARCHICAL;
  static constexpr ClusteringAlgorithm CLUSTERING_CUSTOM =
    DetectionCluster_ClusteringAlgorithm_CLUSTERING_CUSTOM;
  static inline bool ClusteringAlgorithm_IsValid(int value) {
    return DetectionCluster_ClusteringAlgorithm_IsValid(value);
  }
  static constexpr ClusteringAlgorithm ClusteringAlgorithm_MIN =
    DetectionCluster_ClusteringAlgorithm_ClusteringAlgorithm_MIN;
  static constexpr ClusteringAlgorithm ClusteringAlgorithm_MAX =
    DetectionCluster_ClusteringAlgorithm_ClusteringAlgorithm_MAX;
  static constexpr int ClusteringAlgorithm_ARRAYSIZE =
    DetectionCluster_ClusteringAlgorithm_ClusteringAlgorithm_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  ClusteringAlgorithm_descriptor() {
    return DetectionCluster_ClusteringAlgorithm_descriptor();
  }
  template<typename T>
  static inline const std::string& ClusteringAlgorithm_Name(T enum_t_value) {
    static_assert(::std::is_same<T, ClusteringAlgorithm>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function ClusteringAlgorithm_Name.");
    return DetectionCluster_ClusteringAlgorithm_Name(enum_t_value);
  }
  static inline bool ClusteringAlgorithm_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      ClusteringAlgorithm* value) {
    return DetectionCluster_ClusteringAlgorithm_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kDetectionsFieldNumber = 2,
    kAlgorithmParametersFieldNumber = 11,
    kCentroidFieldNumber = 3,
    kCovarianceFieldNumber = 4,
    kTimestampFieldNumber = 5,
    kIdFieldNumber = 1,
    kAlgorithmFieldNumber = 6,
    kClusterRadiusFieldNumber = 8,
    kClusterDensityFieldNumber = 9,
    kProcessingTimeMsFieldNumber = 10,
    kDetectionCountFieldNumber = 7,
  };
  // repeated .radar.messages.Detection detections = 2;
  int detections_size() const;
  private:
  int _internal_detections_size() const;
  public:
  void clear_detections();
  ::radar::messages::Detection* mutable_detections(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::radar::messages::Detection >*
      mutable_detections();
  private:
  const ::radar::messages::Detection& _internal_detections(int index) const;
  ::radar::messages::Detection* _internal_add_detections();
  public:
  const ::radar::messages::Detection& detections(int index) const;
  ::radar::messages::Detection* add_detections();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::radar::messages::Detection >&
      detections() const;

  // map<string, double> algorithm_parameters = 11;
  int algorithm_parameters_size() const;
  private:
  int _internal_algorithm_parameters_size() const;
  public:
  void clear_algorithm_parameters();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >&
      _internal_algorithm_parameters() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >*
      _internal_mutable_algorithm_parameters();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >&
      algorithm_parameters() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >*
      mutable_algorithm_parameters();

  // .radar.messages.Point3D centroid = 3;
  bool has_centroid() const;
  private:
  bool _internal_has_centroid() const;
  public:
  void clear_centroid();
  const ::radar::messages::Point3D& centroid() const;
  PROTOBUF_NODISCARD ::radar::messages::Point3D* release_centroid();
  ::radar::messages::Point3D* mutable_centroid();
  void set_allocated_centroid(::radar::messages::Point3D* centroid);
  private:
  const ::radar::messages::Point3D& _internal_centroid() const;
  ::radar::messages::Point3D* _internal_mutable_centroid();
  public:
  void unsafe_arena_set_allocated_centroid(
      ::radar::messages::Point3D* centroid);
  ::radar::messages::Point3D* unsafe_arena_release_centroid();

  // .radar.messages.Matrix3D covariance = 4;
  bool has_covariance() const;
  private:
  bool _internal_has_covariance() const;
  public:
  void clear_covariance();
  const ::radar::messages::Matrix3D& covariance() const;
  PROTOBUF_NODISCARD ::radar::messages::Matrix3D* release_covariance();
  ::radar::messages::Matrix3D* mutable_covariance();
  void set_allocated_covariance(::radar::messages::Matrix3D* covariance);
  private:
  const ::radar::messages::Matrix3D& _internal_covariance() const;
  ::radar::messages::Matrix3D* _internal_mutable_covariance();
  public:
  void unsafe_arena_set_allocated_covariance(
      ::radar::messages::Matrix3D* covariance);
  ::radar::messages::Matrix3D* unsafe_arena_release_covariance();

  // .google.protobuf.Timestamp timestamp = 5;
  bool has_timestamp() const;
  private:
  bool _internal_has_timestamp() const;
  public:
  void clear_timestamp();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& timestamp() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_timestamp();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_timestamp();
  void set_allocated_timestamp(::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_timestamp() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_timestamp();
  public:
  void unsafe_arena_set_allocated_timestamp(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_timestamp();

  // uint32 id = 1;
  void clear_id();
  uint32_t id() const;
  void set_id(uint32_t value);
  private:
  uint32_t _internal_id() const;
  void _internal_set_id(uint32_t value);
  public:

  // .radar.messages.DetectionCluster.ClusteringAlgorithm algorithm = 6;
  void clear_algorithm();
  ::radar::messages::DetectionCluster_ClusteringAlgorithm algorithm() const;
  void set_algorithm(::radar::messages::DetectionCluster_ClusteringAlgorithm value);
  private:
  ::radar::messages::DetectionCluster_ClusteringAlgorithm _internal_algorithm() const;
  void _internal_set_algorithm(::radar::messages::DetectionCluster_ClusteringAlgorithm value);
  public:

  // double cluster_radius = 8;
  void clear_cluster_radius();
  double cluster_radius() const;
  void set_cluster_radius(double value);
  private:
  double _internal_cluster_radius() const;
  void _internal_set_cluster_radius(double value);
  public:

  // double cluster_density = 9;
  void clear_cluster_density();
  double cluster_density() const;
  void set_cluster_density(double value);
  private:
  double _internal_cluster_density() const;
  void _internal_set_cluster_density(double value);
  public:

  // double processing_time_ms = 10;
  void clear_processing_time_ms();
  double processing_time_ms() const;
  void set_processing_time_ms(double value);
  private:
  double _internal_processing_time_ms() const;
  void _internal_set_processing_time_ms(double value);
  public:

  // uint32 detection_count = 7;
  void clear_detection_count();
  uint32_t detection_count() const;
  void set_detection_count(uint32_t value);
  private:
  uint32_t _internal_detection_count() const;
  void _internal_set_detection_count(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:radar.messages.DetectionCluster)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::radar::messages::Detection > detections_;
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        DetectionCluster_AlgorithmParametersEntry_DoNotUse,
        std::string, double,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_DOUBLE> algorithm_parameters_;
    ::radar::messages::Point3D* centroid_;
    ::radar::messages::Matrix3D* covariance_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp_;
    uint32_t id_;
    int algorithm_;
    double cluster_radius_;
    double cluster_density_;
    double processing_time_ms_;
    uint32_t detection_count_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_track_5fmessages_2eproto;
};
// -------------------------------------------------------------------

class Association final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:radar.messages.Association) */ {
 public:
  inline Association() : Association(nullptr) {}
  ~Association() override;
  explicit PROTOBUF_CONSTEXPR Association(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Association(const Association& from);
  Association(Association&& from) noexcept
    : Association() {
    *this = ::std::move(from);
  }

  inline Association& operator=(const Association& from) {
    CopyFrom(from);
    return *this;
  }
  inline Association& operator=(Association&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Association& default_instance() {
    return *internal_default_instance();
  }
  static inline const Association* internal_default_instance() {
    return reinterpret_cast<const Association*>(
               &_Association_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(Association& a, Association& b) {
    a.Swap(&b);
  }
  inline void Swap(Association* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Association* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Association* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Association>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Association& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Association& from) {
    Association::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Association* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "radar.messages.Association";
  }
  protected:
  explicit Association(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Association_AssociationAlgorithm AssociationAlgorithm;
  static constexpr AssociationAlgorithm ASSOCIATION_ALGORITHM_UNSPECIFIED =
    Association_AssociationAlgorithm_ASSOCIATION_ALGORITHM_UNSPECIFIED;
  static constexpr AssociationAlgorithm NEAREST_NEIGHBOR =
    Association_AssociationAlgorithm_NEAREST_NEIGHBOR;
  static constexpr AssociationAlgorithm GLOBAL_NEAREST_NEIGHBOR =
    Association_AssociationAlgorithm_GLOBAL_NEAREST_NEIGHBOR;
  static constexpr AssociationAlgorithm JOINT_PROBABILISTIC =
    Association_AssociationAlgorithm_JOINT_PROBABILISTIC;
  static constexpr AssociationAlgorithm MULTIPLE_HYPOTHESIS =
    Association_AssociationAlgorithm_MULTIPLE_HYPOTHESIS;
  static constexpr AssociationAlgorithm ASSOCIATION_CUSTOM =
    Association_AssociationAlgorithm_ASSOCIATION_CUSTOM;
  static inline bool AssociationAlgorithm_IsValid(int value) {
    return Association_AssociationAlgorithm_IsValid(value);
  }
  static constexpr AssociationAlgorithm AssociationAlgorithm_MIN =
    Association_AssociationAlgorithm_AssociationAlgorithm_MIN;
  static constexpr AssociationAlgorithm AssociationAlgorithm_MAX =
    Association_AssociationAlgorithm_AssociationAlgorithm_MAX;
  static constexpr int AssociationAlgorithm_ARRAYSIZE =
    Association_AssociationAlgorithm_AssociationAlgorithm_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  AssociationAlgorithm_descriptor() {
    return Association_AssociationAlgorithm_descriptor();
  }
  template<typename T>
  static inline const std::string& AssociationAlgorithm_Name(T enum_t_value) {
    static_assert(::std::is_same<T, AssociationAlgorithm>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function AssociationAlgorithm_Name.");
    return Association_AssociationAlgorithm_Name(enum_t_value);
  }
  static inline bool AssociationAlgorithm_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      AssociationAlgorithm* value) {
    return Association_AssociationAlgorithm_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kInnovationFieldNumber = 6,
    kInnovationCovarianceFieldNumber = 7,
    kTrackIdFieldNumber = 1,
    kDetectionIdFieldNumber = 2,
    kScoreFieldNumber = 3,
    kDistanceFieldNumber = 4,
    kIsValidFieldNumber = 5,
    kAlgorithmFieldNumber = 9,
    kLikelihoodFieldNumber = 8,
  };
  // .radar.messages.Vector3D innovation = 6;
  bool has_innovation() const;
  private:
  bool _internal_has_innovation() const;
  public:
  void clear_innovation();
  const ::radar::messages::Vector3D& innovation() const;
  PROTOBUF_NODISCARD ::radar::messages::Vector3D* release_innovation();
  ::radar::messages::Vector3D* mutable_innovation();
  void set_allocated_innovation(::radar::messages::Vector3D* innovation);
  private:
  const ::radar::messages::Vector3D& _internal_innovation() const;
  ::radar::messages::Vector3D* _internal_mutable_innovation();
  public:
  void unsafe_arena_set_allocated_innovation(
      ::radar::messages::Vector3D* innovation);
  ::radar::messages::Vector3D* unsafe_arena_release_innovation();

  // .radar.messages.Matrix3D innovation_covariance = 7;
  bool has_innovation_covariance() const;
  private:
  bool _internal_has_innovation_covariance() const;
  public:
  void clear_innovation_covariance();
  const ::radar::messages::Matrix3D& innovation_covariance() const;
  PROTOBUF_NODISCARD ::radar::messages::Matrix3D* release_innovation_covariance();
  ::radar::messages::Matrix3D* mutable_innovation_covariance();
  void set_allocated_innovation_covariance(::radar::messages::Matrix3D* innovation_covariance);
  private:
  const ::radar::messages::Matrix3D& _internal_innovation_covariance() const;
  ::radar::messages::Matrix3D* _internal_mutable_innovation_covariance();
  public:
  void unsafe_arena_set_allocated_innovation_covariance(
      ::radar::messages::Matrix3D* innovation_covariance);
  ::radar::messages::Matrix3D* unsafe_arena_release_innovation_covariance();

  // uint32 track_id = 1;
  void clear_track_id();
  uint32_t track_id() const;
  void set_track_id(uint32_t value);
  private:
  uint32_t _internal_track_id() const;
  void _internal_set_track_id(uint32_t value);
  public:

  // uint32 detection_id = 2;
  void clear_detection_id();
  uint32_t detection_id() const;
  void set_detection_id(uint32_t value);
  private:
  uint32_t _internal_detection_id() const;
  void _internal_set_detection_id(uint32_t value);
  public:

  // double score = 3;
  void clear_score();
  double score() const;
  void set_score(double value);
  private:
  double _internal_score() const;
  void _internal_set_score(double value);
  public:

  // double distance = 4;
  void clear_distance();
  double distance() const;
  void set_distance(double value);
  private:
  double _internal_distance() const;
  void _internal_set_distance(double value);
  public:

  // bool is_valid = 5;
  void clear_is_valid();
  bool is_valid() const;
  void set_is_valid(bool value);
  private:
  bool _internal_is_valid() const;
  void _internal_set_is_valid(bool value);
  public:

  // .radar.messages.Association.AssociationAlgorithm algorithm = 9;
  void clear_algorithm();
  ::radar::messages::Association_AssociationAlgorithm algorithm() const;
  void set_algorithm(::radar::messages::Association_AssociationAlgorithm value);
  private:
  ::radar::messages::Association_AssociationAlgorithm _internal_algorithm() const;
  void _internal_set_algorithm(::radar::messages::Association_AssociationAlgorithm value);
  public:

  // double likelihood = 8;
  void clear_likelihood();
  double likelihood() const;
  void set_likelihood(double value);
  private:
  double _internal_likelihood() const;
  void _internal_set_likelihood(double value);
  public:

  // @@protoc_insertion_point(class_scope:radar.messages.Association)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::radar::messages::Vector3D* innovation_;
    ::radar::messages::Matrix3D* innovation_covariance_;
    uint32_t track_id_;
    uint32_t detection_id_;
    double score_;
    double distance_;
    bool is_valid_;
    int algorithm_;
    double likelihood_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_track_5fmessages_2eproto;
};
// -------------------------------------------------------------------

class FusionData_SensorWeightsEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<FusionData_SensorWeightsEntry_DoNotUse, 
    uint32_t, double,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_DOUBLE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<FusionData_SensorWeightsEntry_DoNotUse, 
    uint32_t, double,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_DOUBLE> SuperType;
  FusionData_SensorWeightsEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR FusionData_SensorWeightsEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit FusionData_SensorWeightsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const FusionData_SensorWeightsEntry_DoNotUse& other);
  static const FusionData_SensorWeightsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const FusionData_SensorWeightsEntry_DoNotUse*>(&_FusionData_SensorWeightsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(void*) { return true; }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_track_5fmessages_2eproto;
};

// -------------------------------------------------------------------

class FusionData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:radar.messages.FusionData) */ {
 public:
  inline FusionData() : FusionData(nullptr) {}
  ~FusionData() override;
  explicit PROTOBUF_CONSTEXPR FusionData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FusionData(const FusionData& from);
  FusionData(FusionData&& from) noexcept
    : FusionData() {
    *this = ::std::move(from);
  }

  inline FusionData& operator=(const FusionData& from) {
    CopyFrom(from);
    return *this;
  }
  inline FusionData& operator=(FusionData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FusionData& default_instance() {
    return *internal_default_instance();
  }
  static inline const FusionData* internal_default_instance() {
    return reinterpret_cast<const FusionData*>(
               &_FusionData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(FusionData& a, FusionData& b) {
    a.Swap(&b);
  }
  inline void Swap(FusionData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FusionData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FusionData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FusionData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FusionData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FusionData& from) {
    FusionData::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FusionData* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "radar.messages.FusionData";
  }
  protected:
  explicit FusionData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kFusedTracksFieldNumber = 3,
    kContributingSensorsFieldNumber = 4,
    kSensorWeightsFieldNumber = 5,
    kFusionAlgorithmFieldNumber = 13,
    kTimestampFieldNumber = 1,
    kFusionIdFieldNumber = 2,
    kRedundantTracksFieldNumber = 8,
    kFusionQualityFieldNumber = 6,
    kCrossCorrelationFieldNumber = 7,
    kPositionUncertaintyFieldNumber = 10,
    kVelocityUncertaintyFieldNumber = 11,
    kFusionTimeMsFieldNumber = 12,
    kUniqueTracksFieldNumber = 9,
  };
  // repeated .radar.messages.Track fused_tracks = 3;
  int fused_tracks_size() const;
  private:
  int _internal_fused_tracks_size() const;
  public:
  void clear_fused_tracks();
  ::radar::messages::Track* mutable_fused_tracks(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::radar::messages::Track >*
      mutable_fused_tracks();
  private:
  const ::radar::messages::Track& _internal_fused_tracks(int index) const;
  ::radar::messages::Track* _internal_add_fused_tracks();
  public:
  const ::radar::messages::Track& fused_tracks(int index) const;
  ::radar::messages::Track* add_fused_tracks();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::radar::messages::Track >&
      fused_tracks() const;

  // repeated uint32 contributing_sensors = 4;
  int contributing_sensors_size() const;
  private:
  int _internal_contributing_sensors_size() const;
  public:
  void clear_contributing_sensors();
  private:
  uint32_t _internal_contributing_sensors(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      _internal_contributing_sensors() const;
  void _internal_add_contributing_sensors(uint32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      _internal_mutable_contributing_sensors();
  public:
  uint32_t contributing_sensors(int index) const;
  void set_contributing_sensors(int index, uint32_t value);
  void add_contributing_sensors(uint32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      contributing_sensors() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      mutable_contributing_sensors();

  // map<uint32, double> sensor_weights = 5;
  int sensor_weights_size() const;
  private:
  int _internal_sensor_weights_size() const;
  public:
  void clear_sensor_weights();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< uint32_t, double >&
      _internal_sensor_weights() const;
  ::PROTOBUF_NAMESPACE_ID::Map< uint32_t, double >*
      _internal_mutable_sensor_weights();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< uint32_t, double >&
      sensor_weights() const;
  ::PROTOBUF_NAMESPACE_ID::Map< uint32_t, double >*
      mutable_sensor_weights();

  // string fusion_algorithm = 13;
  void clear_fusion_algorithm();
  const std::string& fusion_algorithm() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_fusion_algorithm(ArgT0&& arg0, ArgT... args);
  std::string* mutable_fusion_algorithm();
  PROTOBUF_NODISCARD std::string* release_fusion_algorithm();
  void set_allocated_fusion_algorithm(std::string* fusion_algorithm);
  private:
  const std::string& _internal_fusion_algorithm() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_fusion_algorithm(const std::string& value);
  std::string* _internal_mutable_fusion_algorithm();
  public:

  // .google.protobuf.Timestamp timestamp = 1;
  bool has_timestamp() const;
  private:
  bool _internal_has_timestamp() const;
  public:
  void clear_timestamp();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& timestamp() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_timestamp();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_timestamp();
  void set_allocated_timestamp(::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_timestamp() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_timestamp();
  public:
  void unsafe_arena_set_allocated_timestamp(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_timestamp();

  // uint32 fusion_id = 2;
  void clear_fusion_id();
  uint32_t fusion_id() const;
  void set_fusion_id(uint32_t value);
  private:
  uint32_t _internal_fusion_id() const;
  void _internal_set_fusion_id(uint32_t value);
  public:

  // uint32 redundant_tracks = 8;
  void clear_redundant_tracks();
  uint32_t redundant_tracks() const;
  void set_redundant_tracks(uint32_t value);
  private:
  uint32_t _internal_redundant_tracks() const;
  void _internal_set_redundant_tracks(uint32_t value);
  public:

  // double fusion_quality = 6;
  void clear_fusion_quality();
  double fusion_quality() const;
  void set_fusion_quality(double value);
  private:
  double _internal_fusion_quality() const;
  void _internal_set_fusion_quality(double value);
  public:

  // double cross_correlation = 7;
  void clear_cross_correlation();
  double cross_correlation() const;
  void set_cross_correlation(double value);
  private:
  double _internal_cross_correlation() const;
  void _internal_set_cross_correlation(double value);
  public:

  // double position_uncertainty = 10;
  void clear_position_uncertainty();
  double position_uncertainty() const;
  void set_position_uncertainty(double value);
  private:
  double _internal_position_uncertainty() const;
  void _internal_set_position_uncertainty(double value);
  public:

  // double velocity_uncertainty = 11;
  void clear_velocity_uncertainty();
  double velocity_uncertainty() const;
  void set_velocity_uncertainty(double value);
  private:
  double _internal_velocity_uncertainty() const;
  void _internal_set_velocity_uncertainty(double value);
  public:

  // double fusion_time_ms = 12;
  void clear_fusion_time_ms();
  double fusion_time_ms() const;
  void set_fusion_time_ms(double value);
  private:
  double _internal_fusion_time_ms() const;
  void _internal_set_fusion_time_ms(double value);
  public:

  // uint32 unique_tracks = 9;
  void clear_unique_tracks();
  uint32_t unique_tracks() const;
  void set_unique_tracks(uint32_t value);
  private:
  uint32_t _internal_unique_tracks() const;
  void _internal_set_unique_tracks(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:radar.messages.FusionData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::radar::messages::Track > fused_tracks_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t > contributing_sensors_;
    mutable std::atomic<int> _contributing_sensors_cached_byte_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        FusionData_SensorWeightsEntry_DoNotUse,
        uint32_t, double,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_DOUBLE> sensor_weights_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr fusion_algorithm_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp_;
    uint32_t fusion_id_;
    uint32_t redundant_tracks_;
    double fusion_quality_;
    double cross_correlation_;
    double position_uncertainty_;
    double velocity_uncertainty_;
    double fusion_time_ms_;
    uint32_t unique_tracks_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_track_5fmessages_2eproto;
};
// -------------------------------------------------------------------

class ThreatAssessment final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:radar.messages.ThreatAssessment) */ {
 public:
  inline ThreatAssessment() : ThreatAssessment(nullptr) {}
  ~ThreatAssessment() override;
  explicit PROTOBUF_CONSTEXPR ThreatAssessment(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ThreatAssessment(const ThreatAssessment& from);
  ThreatAssessment(ThreatAssessment&& from) noexcept
    : ThreatAssessment() {
    *this = ::std::move(from);
  }

  inline ThreatAssessment& operator=(const ThreatAssessment& from) {
    CopyFrom(from);
    return *this;
  }
  inline ThreatAssessment& operator=(ThreatAssessment&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ThreatAssessment& default_instance() {
    return *internal_default_instance();
  }
  static inline const ThreatAssessment* internal_default_instance() {
    return reinterpret_cast<const ThreatAssessment*>(
               &_ThreatAssessment_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(ThreatAssessment& a, ThreatAssessment& b) {
    a.Swap(&b);
  }
  inline void Swap(ThreatAssessment* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ThreatAssessment* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ThreatAssessment* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ThreatAssessment>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ThreatAssessment& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ThreatAssessment& from) {
    ThreatAssessment::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ThreatAssessment* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "radar.messages.ThreatAssessment";
  }
  protected:
  explicit ThreatAssessment(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ThreatAssessment_ThreatLevel ThreatLevel;
  static constexpr ThreatLevel THREAT_LEVEL_UNSPECIFIED =
    ThreatAssessment_ThreatLevel_THREAT_LEVEL_UNSPECIFIED;
  static constexpr ThreatLevel LOW =
    ThreatAssessment_ThreatLevel_LOW;
  static constexpr ThreatLevel MEDIUM =
    ThreatAssessment_ThreatLevel_MEDIUM;
  static constexpr ThreatLevel HIGH =
    ThreatAssessment_ThreatLevel_HIGH;
  static constexpr ThreatLevel CRITICAL =
    ThreatAssessment_ThreatLevel_CRITICAL;
  static inline bool ThreatLevel_IsValid(int value) {
    return ThreatAssessment_ThreatLevel_IsValid(value);
  }
  static constexpr ThreatLevel ThreatLevel_MIN =
    ThreatAssessment_ThreatLevel_ThreatLevel_MIN;
  static constexpr ThreatLevel ThreatLevel_MAX =
    ThreatAssessment_ThreatLevel_ThreatLevel_MAX;
  static constexpr int ThreatLevel_ARRAYSIZE =
    ThreatAssessment_ThreatLevel_ThreatLevel_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  ThreatLevel_descriptor() {
    return ThreatAssessment_ThreatLevel_descriptor();
  }
  template<typename T>
  static inline const std::string& ThreatLevel_Name(T enum_t_value) {
    static_assert(::std::is_same<T, ThreatLevel>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function ThreatLevel_Name.");
    return ThreatAssessment_ThreatLevel_Name(enum_t_value);
  }
  static inline bool ThreatLevel_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      ThreatLevel* value) {
    return ThreatAssessment_ThreatLevel_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kRecommendedActionsFieldNumber = 12,
    kPriorityFieldNumber = 13,
    kTimestampFieldNumber = 2,
    kPredictedInterceptFieldNumber = 9,
    kTrackIdFieldNumber = 1,
    kThreatLevelFieldNumber = 3,
    kThreatScoreFieldNumber = 4,
    kProximityFactorFieldNumber = 5,
    kVelocityFactorFieldNumber = 6,
    kTrajectoryFactorFieldNumber = 7,
    kClassificationFactorFieldNumber = 8,
    kTimeToInterceptSecondsFieldNumber = 10,
    kInterceptProbabilityFieldNumber = 11,
  };
  // repeated string recommended_actions = 12;
  int recommended_actions_size() const;
  private:
  int _internal_recommended_actions_size() const;
  public:
  void clear_recommended_actions();
  const std::string& recommended_actions(int index) const;
  std::string* mutable_recommended_actions(int index);
  void set_recommended_actions(int index, const std::string& value);
  void set_recommended_actions(int index, std::string&& value);
  void set_recommended_actions(int index, const char* value);
  void set_recommended_actions(int index, const char* value, size_t size);
  std::string* add_recommended_actions();
  void add_recommended_actions(const std::string& value);
  void add_recommended_actions(std::string&& value);
  void add_recommended_actions(const char* value);
  void add_recommended_actions(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& recommended_actions() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_recommended_actions();
  private:
  const std::string& _internal_recommended_actions(int index) const;
  std::string* _internal_add_recommended_actions();
  public:

  // string priority = 13;
  void clear_priority();
  const std::string& priority() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_priority(ArgT0&& arg0, ArgT... args);
  std::string* mutable_priority();
  PROTOBUF_NODISCARD std::string* release_priority();
  void set_allocated_priority(std::string* priority);
  private:
  const std::string& _internal_priority() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_priority(const std::string& value);
  std::string* _internal_mutable_priority();
  public:

  // .google.protobuf.Timestamp timestamp = 2;
  bool has_timestamp() const;
  private:
  bool _internal_has_timestamp() const;
  public:
  void clear_timestamp();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& timestamp() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_timestamp();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_timestamp();
  void set_allocated_timestamp(::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_timestamp() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_timestamp();
  public:
  void unsafe_arena_set_allocated_timestamp(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_timestamp();

  // .radar.messages.Point3D predicted_intercept = 9;
  bool has_predicted_intercept() const;
  private:
  bool _internal_has_predicted_intercept() const;
  public:
  void clear_predicted_intercept();
  const ::radar::messages::Point3D& predicted_intercept() const;
  PROTOBUF_NODISCARD ::radar::messages::Point3D* release_predicted_intercept();
  ::radar::messages::Point3D* mutable_predicted_intercept();
  void set_allocated_predicted_intercept(::radar::messages::Point3D* predicted_intercept);
  private:
  const ::radar::messages::Point3D& _internal_predicted_intercept() const;
  ::radar::messages::Point3D* _internal_mutable_predicted_intercept();
  public:
  void unsafe_arena_set_allocated_predicted_intercept(
      ::radar::messages::Point3D* predicted_intercept);
  ::radar::messages::Point3D* unsafe_arena_release_predicted_intercept();

  // uint32 track_id = 1;
  void clear_track_id();
  uint32_t track_id() const;
  void set_track_id(uint32_t value);
  private:
  uint32_t _internal_track_id() const;
  void _internal_set_track_id(uint32_t value);
  public:

  // .radar.messages.ThreatAssessment.ThreatLevel threat_level = 3;
  void clear_threat_level();
  ::radar::messages::ThreatAssessment_ThreatLevel threat_level() const;
  void set_threat_level(::radar::messages::ThreatAssessment_ThreatLevel value);
  private:
  ::radar::messages::ThreatAssessment_ThreatLevel _internal_threat_level() const;
  void _internal_set_threat_level(::radar::messages::ThreatAssessment_ThreatLevel value);
  public:

  // double threat_score = 4;
  void clear_threat_score();
  double threat_score() const;
  void set_threat_score(double value);
  private:
  double _internal_threat_score() const;
  void _internal_set_threat_score(double value);
  public:

  // double proximity_factor = 5;
  void clear_proximity_factor();
  double proximity_factor() const;
  void set_proximity_factor(double value);
  private:
  double _internal_proximity_factor() const;
  void _internal_set_proximity_factor(double value);
  public:

  // double velocity_factor = 6;
  void clear_velocity_factor();
  double velocity_factor() const;
  void set_velocity_factor(double value);
  private:
  double _internal_velocity_factor() const;
  void _internal_set_velocity_factor(double value);
  public:

  // double trajectory_factor = 7;
  void clear_trajectory_factor();
  double trajectory_factor() const;
  void set_trajectory_factor(double value);
  private:
  double _internal_trajectory_factor() const;
  void _internal_set_trajectory_factor(double value);
  public:

  // double classification_factor = 8;
  void clear_classification_factor();
  double classification_factor() const;
  void set_classification_factor(double value);
  private:
  double _internal_classification_factor() const;
  void _internal_set_classification_factor(double value);
  public:

  // double time_to_intercept_seconds = 10;
  void clear_time_to_intercept_seconds();
  double time_to_intercept_seconds() const;
  void set_time_to_intercept_seconds(double value);
  private:
  double _internal_time_to_intercept_seconds() const;
  void _internal_set_time_to_intercept_seconds(double value);
  public:

  // double intercept_probability = 11;
  void clear_intercept_probability();
  double intercept_probability() const;
  void set_intercept_probability(double value);
  private:
  double _internal_intercept_probability() const;
  void _internal_set_intercept_probability(double value);
  public:

  // @@protoc_insertion_point(class_scope:radar.messages.ThreatAssessment)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> recommended_actions_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr priority_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp_;
    ::radar::messages::Point3D* predicted_intercept_;
    uint32_t track_id_;
    int threat_level_;
    double threat_score_;
    double proximity_factor_;
    double velocity_factor_;
    double trajectory_factor_;
    double classification_factor_;
    double time_to_intercept_seconds_;
    double intercept_probability_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_track_5fmessages_2eproto;
};
// -------------------------------------------------------------------

class SystemConfiguration_ClusteringParamsEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<SystemConfiguration_ClusteringParamsEntry_DoNotUse, 
    std::string, double,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_DOUBLE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<SystemConfiguration_ClusteringParamsEntry_DoNotUse, 
    std::string, double,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_DOUBLE> SuperType;
  SystemConfiguration_ClusteringParamsEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR SystemConfiguration_ClusteringParamsEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit SystemConfiguration_ClusteringParamsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const SystemConfiguration_ClusteringParamsEntry_DoNotUse& other);
  static const SystemConfiguration_ClusteringParamsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const SystemConfiguration_ClusteringParamsEntry_DoNotUse*>(&_SystemConfiguration_ClusteringParamsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "radar.messages.SystemConfiguration.ClusteringParamsEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_track_5fmessages_2eproto;
};

// -------------------------------------------------------------------

class SystemConfiguration_AssociationParamsEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<SystemConfiguration_AssociationParamsEntry_DoNotUse, 
    std::string, double,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_DOUBLE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<SystemConfiguration_AssociationParamsEntry_DoNotUse, 
    std::string, double,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_DOUBLE> SuperType;
  SystemConfiguration_AssociationParamsEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR SystemConfiguration_AssociationParamsEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit SystemConfiguration_AssociationParamsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const SystemConfiguration_AssociationParamsEntry_DoNotUse& other);
  static const SystemConfiguration_AssociationParamsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const SystemConfiguration_AssociationParamsEntry_DoNotUse*>(&_SystemConfiguration_AssociationParamsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "radar.messages.SystemConfiguration.AssociationParamsEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_track_5fmessages_2eproto;
};

// -------------------------------------------------------------------

class SystemConfiguration_FilterParamsEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<SystemConfiguration_FilterParamsEntry_DoNotUse, 
    std::string, double,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_DOUBLE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<SystemConfiguration_FilterParamsEntry_DoNotUse, 
    std::string, double,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_DOUBLE> SuperType;
  SystemConfiguration_FilterParamsEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR SystemConfiguration_FilterParamsEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit SystemConfiguration_FilterParamsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const SystemConfiguration_FilterParamsEntry_DoNotUse& other);
  static const SystemConfiguration_FilterParamsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const SystemConfiguration_FilterParamsEntry_DoNotUse*>(&_SystemConfiguration_FilterParamsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "radar.messages.SystemConfiguration.FilterParamsEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_track_5fmessages_2eproto;
};

// -------------------------------------------------------------------

class SystemConfiguration final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:radar.messages.SystemConfiguration) */ {
 public:
  inline SystemConfiguration() : SystemConfiguration(nullptr) {}
  ~SystemConfiguration() override;
  explicit PROTOBUF_CONSTEXPR SystemConfiguration(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SystemConfiguration(const SystemConfiguration& from);
  SystemConfiguration(SystemConfiguration&& from) noexcept
    : SystemConfiguration() {
    *this = ::std::move(from);
  }

  inline SystemConfiguration& operator=(const SystemConfiguration& from) {
    CopyFrom(from);
    return *this;
  }
  inline SystemConfiguration& operator=(SystemConfiguration&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SystemConfiguration& default_instance() {
    return *internal_default_instance();
  }
  static inline const SystemConfiguration* internal_default_instance() {
    return reinterpret_cast<const SystemConfiguration*>(
               &_SystemConfiguration_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(SystemConfiguration& a, SystemConfiguration& b) {
    a.Swap(&b);
  }
  inline void Swap(SystemConfiguration* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SystemConfiguration* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SystemConfiguration* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SystemConfiguration>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SystemConfiguration& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SystemConfiguration& from) {
    SystemConfiguration::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SystemConfiguration* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "radar.messages.SystemConfiguration";
  }
  protected:
  explicit SystemConfiguration(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kClusteringParamsFieldNumber = 5,
    kAssociationParamsFieldNumber = 6,
    kFilterParamsFieldNumber = 7,
    kClusteringAlgorithmFieldNumber = 2,
    kAssociationAlgorithmFieldNumber = 3,
    kFilterAlgorithmFieldNumber = 4,
    kLogLevelFieldNumber = 16,
    kTimestampFieldNumber = 1,
    kUpdateRateHzFieldNumber = 8,
    kTrackTimeoutSecondsFieldNumber = 10,
    kConfirmationThresholdFieldNumber = 11,
    kDeletionThresholdFieldNumber = 12,
    kMaxTracksFieldNumber = 9,
    kEnableHmiOutputFieldNumber = 13,
    kEnableFusionOutputFieldNumber = 14,
    kEnableLoggingFieldNumber = 15,
  };
  // map<string, double> clustering_params = 5;
  int clustering_params_size() const;
  private:
  int _internal_clustering_params_size() const;
  public:
  void clear_clustering_params();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >&
      _internal_clustering_params() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >*
      _internal_mutable_clustering_params();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >&
      clustering_params() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >*
      mutable_clustering_params();

  // map<string, double> association_params = 6;
  int association_params_size() const;
  private:
  int _internal_association_params_size() const;
  public:
  void clear_association_params();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >&
      _internal_association_params() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >*
      _internal_mutable_association_params();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >&
      association_params() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >*
      mutable_association_params();

  // map<string, double> filter_params = 7;
  int filter_params_size() const;
  private:
  int _internal_filter_params_size() const;
  public:
  void clear_filter_params();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >&
      _internal_filter_params() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >*
      _internal_mutable_filter_params();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >&
      filter_params() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >*
      mutable_filter_params();

  // string clustering_algorithm = 2;
  void clear_clustering_algorithm();
  const std::string& clustering_algorithm() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_clustering_algorithm(ArgT0&& arg0, ArgT... args);
  std::string* mutable_clustering_algorithm();
  PROTOBUF_NODISCARD std::string* release_clustering_algorithm();
  void set_allocated_clustering_algorithm(std::string* clustering_algorithm);
  private:
  const std::string& _internal_clustering_algorithm() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_clustering_algorithm(const std::string& value);
  std::string* _internal_mutable_clustering_algorithm();
  public:

  // string association_algorithm = 3;
  void clear_association_algorithm();
  const std::string& association_algorithm() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_association_algorithm(ArgT0&& arg0, ArgT... args);
  std::string* mutable_association_algorithm();
  PROTOBUF_NODISCARD std::string* release_association_algorithm();
  void set_allocated_association_algorithm(std::string* association_algorithm);
  private:
  const std::string& _internal_association_algorithm() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_association_algorithm(const std::string& value);
  std::string* _internal_mutable_association_algorithm();
  public:

  // string filter_algorithm = 4;
  void clear_filter_algorithm();
  const std::string& filter_algorithm() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_filter_algorithm(ArgT0&& arg0, ArgT... args);
  std::string* mutable_filter_algorithm();
  PROTOBUF_NODISCARD std::string* release_filter_algorithm();
  void set_allocated_filter_algorithm(std::string* filter_algorithm);
  private:
  const std::string& _internal_filter_algorithm() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_filter_algorithm(const std::string& value);
  std::string* _internal_mutable_filter_algorithm();
  public:

  // string log_level = 16;
  void clear_log_level();
  const std::string& log_level() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_log_level(ArgT0&& arg0, ArgT... args);
  std::string* mutable_log_level();
  PROTOBUF_NODISCARD std::string* release_log_level();
  void set_allocated_log_level(std::string* log_level);
  private:
  const std::string& _internal_log_level() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_log_level(const std::string& value);
  std::string* _internal_mutable_log_level();
  public:

  // .google.protobuf.Timestamp timestamp = 1;
  bool has_timestamp() const;
  private:
  bool _internal_has_timestamp() const;
  public:
  void clear_timestamp();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& timestamp() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_timestamp();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_timestamp();
  void set_allocated_timestamp(::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_timestamp() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_timestamp();
  public:
  void unsafe_arena_set_allocated_timestamp(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_timestamp();

  // double update_rate_hz = 8;
  void clear_update_rate_hz();
  double update_rate_hz() const;
  void set_update_rate_hz(double value);
  private:
  double _internal_update_rate_hz() const;
  void _internal_set_update_rate_hz(double value);
  public:

  // double track_timeout_seconds = 10;
  void clear_track_timeout_seconds();
  double track_timeout_seconds() const;
  void set_track_timeout_seconds(double value);
  private:
  double _internal_track_timeout_seconds() const;
  void _internal_set_track_timeout_seconds(double value);
  public:

  // double confirmation_threshold = 11;
  void clear_confirmation_threshold();
  double confirmation_threshold() const;
  void set_confirmation_threshold(double value);
  private:
  double _internal_confirmation_threshold() const;
  void _internal_set_confirmation_threshold(double value);
  public:

  // double deletion_threshold = 12;
  void clear_deletion_threshold();
  double deletion_threshold() const;
  void set_deletion_threshold(double value);
  private:
  double _internal_deletion_threshold() const;
  void _internal_set_deletion_threshold(double value);
  public:

  // uint32 max_tracks = 9;
  void clear_max_tracks();
  uint32_t max_tracks() const;
  void set_max_tracks(uint32_t value);
  private:
  uint32_t _internal_max_tracks() const;
  void _internal_set_max_tracks(uint32_t value);
  public:

  // bool enable_hmi_output = 13;
  void clear_enable_hmi_output();
  bool enable_hmi_output() const;
  void set_enable_hmi_output(bool value);
  private:
  bool _internal_enable_hmi_output() const;
  void _internal_set_enable_hmi_output(bool value);
  public:

  // bool enable_fusion_output = 14;
  void clear_enable_fusion_output();
  bool enable_fusion_output() const;
  void set_enable_fusion_output(bool value);
  private:
  bool _internal_enable_fusion_output() const;
  void _internal_set_enable_fusion_output(bool value);
  public:

  // bool enable_logging = 15;
  void clear_enable_logging();
  bool enable_logging() const;
  void set_enable_logging(bool value);
  private:
  bool _internal_enable_logging() const;
  void _internal_set_enable_logging(bool value);
  public:

  // @@protoc_insertion_point(class_scope:radar.messages.SystemConfiguration)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        SystemConfiguration_ClusteringParamsEntry_DoNotUse,
        std::string, double,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_DOUBLE> clustering_params_;
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        SystemConfiguration_AssociationParamsEntry_DoNotUse,
        std::string, double,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_DOUBLE> association_params_;
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        SystemConfiguration_FilterParamsEntry_DoNotUse,
        std::string, double,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_DOUBLE> filter_params_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr clustering_algorithm_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr association_algorithm_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr filter_algorithm_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr log_level_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp_;
    double update_rate_hz_;
    double track_timeout_seconds_;
    double confirmation_threshold_;
    double deletion_threshold_;
    uint32_t max_tracks_;
    bool enable_hmi_output_;
    bool enable_fusion_output_;
    bool enable_logging_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_track_5fmessages_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// TrackState

// repeated double state = 1;
inline int TrackState::_internal_state_size() const {
  return _impl_.state_.size();
}
inline int TrackState::state_size() const {
  return _internal_state_size();
}
inline void TrackState::clear_state() {
  _impl_.state_.Clear();
}
inline double TrackState::_internal_state(int index) const {
  return _impl_.state_.Get(index);
}
inline double TrackState::state(int index) const {
  // @@protoc_insertion_point(field_get:radar.messages.TrackState.state)
  return _internal_state(index);
}
inline void TrackState::set_state(int index, double value) {
  _impl_.state_.Set(index, value);
  // @@protoc_insertion_point(field_set:radar.messages.TrackState.state)
}
inline void TrackState::_internal_add_state(double value) {
  _impl_.state_.Add(value);
}
inline void TrackState::add_state(double value) {
  _internal_add_state(value);
  // @@protoc_insertion_point(field_add:radar.messages.TrackState.state)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
TrackState::_internal_state() const {
  return _impl_.state_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
TrackState::state() const {
  // @@protoc_insertion_point(field_list:radar.messages.TrackState.state)
  return _internal_state();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
TrackState::_internal_mutable_state() {
  return &_impl_.state_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
TrackState::mutable_state() {
  // @@protoc_insertion_point(field_mutable_list:radar.messages.TrackState.state)
  return _internal_mutable_state();
}

// repeated double covariance = 2;
inline int TrackState::_internal_covariance_size() const {
  return _impl_.covariance_.size();
}
inline int TrackState::covariance_size() const {
  return _internal_covariance_size();
}
inline void TrackState::clear_covariance() {
  _impl_.covariance_.Clear();
}
inline double TrackState::_internal_covariance(int index) const {
  return _impl_.covariance_.Get(index);
}
inline double TrackState::covariance(int index) const {
  // @@protoc_insertion_point(field_get:radar.messages.TrackState.covariance)
  return _internal_covariance(index);
}
inline void TrackState::set_covariance(int index, double value) {
  _impl_.covariance_.Set(index, value);
  // @@protoc_insertion_point(field_set:radar.messages.TrackState.covariance)
}
inline void TrackState::_internal_add_covariance(double value) {
  _impl_.covariance_.Add(value);
}
inline void TrackState::add_covariance(double value) {
  _internal_add_covariance(value);
  // @@protoc_insertion_point(field_add:radar.messages.TrackState.covariance)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
TrackState::_internal_covariance() const {
  return _impl_.covariance_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
TrackState::covariance() const {
  // @@protoc_insertion_point(field_list:radar.messages.TrackState.covariance)
  return _internal_covariance();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
TrackState::_internal_mutable_covariance() {
  return &_impl_.covariance_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
TrackState::mutable_covariance() {
  // @@protoc_insertion_point(field_mutable_list:radar.messages.TrackState.covariance)
  return _internal_mutable_covariance();
}

// uint32 state_size = 3;
inline void TrackState::clear_state_size() {
  _impl_.state_size_ = 0u;
}
inline uint32_t TrackState::_internal_state_size() const {
  return _impl_.state_size_;
}
inline uint32_t TrackState::state_size() const {
  // @@protoc_insertion_point(field_get:radar.messages.TrackState.state_size)
  return _internal_state_size();
}
inline void TrackState::_internal_set_state_size(uint32_t value) {
  
  _impl_.state_size_ = value;
}
inline void TrackState::set_state_size(uint32_t value) {
  _internal_set_state_size(value);
  // @@protoc_insertion_point(field_set:radar.messages.TrackState.state_size)
}

// .radar.messages.MotionModel motion_model = 4;
inline void TrackState::clear_motion_model() {
  _impl_.motion_model_ = 0;
}
inline ::radar::messages::MotionModel TrackState::_internal_motion_model() const {
  return static_cast< ::radar::messages::MotionModel >(_impl_.motion_model_);
}
inline ::radar::messages::MotionModel TrackState::motion_model() const {
  // @@protoc_insertion_point(field_get:radar.messages.TrackState.motion_model)
  return _internal_motion_model();
}
inline void TrackState::_internal_set_motion_model(::radar::messages::MotionModel value) {
  
  _impl_.motion_model_ = value;
}
inline void TrackState::set_motion_model(::radar::messages::MotionModel value) {
  _internal_set_motion_model(value);
  // @@protoc_insertion_point(field_set:radar.messages.TrackState.motion_model)
}

// .radar.messages.Point3D position = 5;
inline bool TrackState::_internal_has_position() const {
  return this != internal_default_instance() && _impl_.position_ != nullptr;
}
inline bool TrackState::has_position() const {
  return _internal_has_position();
}
inline const ::radar::messages::Point3D& TrackState::_internal_position() const {
  const ::radar::messages::Point3D* p = _impl_.position_;
  return p != nullptr ? *p : reinterpret_cast<const ::radar::messages::Point3D&>(
      ::radar::messages::_Point3D_default_instance_);
}
inline const ::radar::messages::Point3D& TrackState::position() const {
  // @@protoc_insertion_point(field_get:radar.messages.TrackState.position)
  return _internal_position();
}
inline void TrackState::unsafe_arena_set_allocated_position(
    ::radar::messages::Point3D* position) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.position_);
  }
  _impl_.position_ = position;
  if (position) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:radar.messages.TrackState.position)
}
inline ::radar::messages::Point3D* TrackState::release_position() {
  
  ::radar::messages::Point3D* temp = _impl_.position_;
  _impl_.position_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::radar::messages::Point3D* TrackState::unsafe_arena_release_position() {
  // @@protoc_insertion_point(field_release:radar.messages.TrackState.position)
  
  ::radar::messages::Point3D* temp = _impl_.position_;
  _impl_.position_ = nullptr;
  return temp;
}
inline ::radar::messages::Point3D* TrackState::_internal_mutable_position() {
  
  if (_impl_.position_ == nullptr) {
    auto* p = CreateMaybeMessage<::radar::messages::Point3D>(GetArenaForAllocation());
    _impl_.position_ = p;
  }
  return _impl_.position_;
}
inline ::radar::messages::Point3D* TrackState::mutable_position() {
  ::radar::messages::Point3D* _msg = _internal_mutable_position();
  // @@protoc_insertion_point(field_mutable:radar.messages.TrackState.position)
  return _msg;
}
inline void TrackState::set_allocated_position(::radar::messages::Point3D* position) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.position_);
  }
  if (position) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(position));
    if (message_arena != submessage_arena) {
      position = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, position, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.position_ = position;
  // @@protoc_insertion_point(field_set_allocated:radar.messages.TrackState.position)
}

// .radar.messages.Vector3D velocity = 6;
inline bool TrackState::_internal_has_velocity() const {
  return this != internal_default_instance() && _impl_.velocity_ != nullptr;
}
inline bool TrackState::has_velocity() const {
  return _internal_has_velocity();
}
inline const ::radar::messages::Vector3D& TrackState::_internal_velocity() const {
  const ::radar::messages::Vector3D* p = _impl_.velocity_;
  return p != nullptr ? *p : reinterpret_cast<const ::radar::messages::Vector3D&>(
      ::radar::messages::_Vector3D_default_instance_);
}
inline const ::radar::messages::Vector3D& TrackState::velocity() const {
  // @@protoc_insertion_point(field_get:radar.messages.TrackState.velocity)
  return _internal_velocity();
}
inline void TrackState::unsafe_arena_set_allocated_velocity(
    ::radar::messages::Vector3D* velocity) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.velocity_);
  }
  _impl_.velocity_ = velocity;
  if (velocity) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:radar.messages.TrackState.velocity)
}
inline ::radar::messages::Vector3D* TrackState::release_velocity() {
  
  ::radar::messages::Vector3D* temp = _impl_.velocity_;
  _impl_.velocity_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::radar::messages::Vector3D* TrackState::unsafe_arena_release_velocity() {
  // @@protoc_insertion_point(field_release:radar.messages.TrackState.velocity)
  
  ::radar::messages::Vector3D* temp = _impl_.velocity_;
  _impl_.velocity_ = nullptr;
  return temp;
}
inline ::radar::messages::Vector3D* TrackState::_internal_mutable_velocity() {
  
  if (_impl_.velocity_ == nullptr) {
    auto* p = CreateMaybeMessage<::radar::messages::Vector3D>(GetArenaForAllocation());
    _impl_.velocity_ = p;
  }
  return _impl_.velocity_;
}
inline ::radar::messages::Vector3D* TrackState::mutable_velocity() {
  ::radar::messages::Vector3D* _msg = _internal_mutable_velocity();
  // @@protoc_insertion_point(field_mutable:radar.messages.TrackState.velocity)
  return _msg;
}
inline void TrackState::set_allocated_velocity(::radar::messages::Vector3D* velocity) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.velocity_);
  }
  if (velocity) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(velocity));
    if (message_arena != submessage_arena) {
      velocity = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, velocity, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.velocity_ = velocity;
  // @@protoc_insertion_point(field_set_allocated:radar.messages.TrackState.velocity)
}

// .radar.messages.Vector3D acceleration = 7;
inline bool TrackState::_internal_has_acceleration() const {
  return this != internal_default_instance() && _impl_.acceleration_ != nullptr;
}
inline bool TrackState::has_acceleration() const {
  return _internal_has_acceleration();
}
inline const ::radar::messages::Vector3D& TrackState::_internal_acceleration() const {
  const ::radar::messages::Vector3D* p = _impl_.acceleration_;
  return p != nullptr ? *p : reinterpret_cast<const ::radar::messages::Vector3D&>(
      ::radar::messages::_Vector3D_default_instance_);
}
inline const ::radar::messages::Vector3D& TrackState::acceleration() const {
  // @@protoc_insertion_point(field_get:radar.messages.TrackState.acceleration)
  return _internal_acceleration();
}
inline void TrackState::unsafe_arena_set_allocated_acceleration(
    ::radar::messages::Vector3D* acceleration) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.acceleration_);
  }
  _impl_.acceleration_ = acceleration;
  if (acceleration) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:radar.messages.TrackState.acceleration)
}
inline ::radar::messages::Vector3D* TrackState::release_acceleration() {
  
  ::radar::messages::Vector3D* temp = _impl_.acceleration_;
  _impl_.acceleration_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::radar::messages::Vector3D* TrackState::unsafe_arena_release_acceleration() {
  // @@protoc_insertion_point(field_release:radar.messages.TrackState.acceleration)
  
  ::radar::messages::Vector3D* temp = _impl_.acceleration_;
  _impl_.acceleration_ = nullptr;
  return temp;
}
inline ::radar::messages::Vector3D* TrackState::_internal_mutable_acceleration() {
  
  if (_impl_.acceleration_ == nullptr) {
    auto* p = CreateMaybeMessage<::radar::messages::Vector3D>(GetArenaForAllocation());
    _impl_.acceleration_ = p;
  }
  return _impl_.acceleration_;
}
inline ::radar::messages::Vector3D* TrackState::mutable_acceleration() {
  ::radar::messages::Vector3D* _msg = _internal_mutable_acceleration();
  // @@protoc_insertion_point(field_mutable:radar.messages.TrackState.acceleration)
  return _msg;
}
inline void TrackState::set_allocated_acceleration(::radar::messages::Vector3D* acceleration) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.acceleration_);
  }
  if (acceleration) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(acceleration));
    if (message_arena != submessage_arena) {
      acceleration = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, acceleration, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.acceleration_ = acceleration;
  // @@protoc_insertion_point(field_set_allocated:radar.messages.TrackState.acceleration)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// Track

// uint32 id = 1;
inline void Track::clear_id() {
  _impl_.id_ = 0u;
}
inline uint32_t Track::_internal_id() const {
  return _impl_.id_;
}
inline uint32_t Track::id() const {
  // @@protoc_insertion_point(field_get:radar.messages.Track.id)
  return _internal_id();
}
inline void Track::_internal_set_id(uint32_t value) {
  
  _impl_.id_ = value;
}
inline void Track::set_id(uint32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:radar.messages.Track.id)
}

// uint32 sensor_id = 2;
inline void Track::clear_sensor_id() {
  _impl_.sensor_id_ = 0u;
}
inline uint32_t Track::_internal_sensor_id() const {
  return _impl_.sensor_id_;
}
inline uint32_t Track::sensor_id() const {
  // @@protoc_insertion_point(field_get:radar.messages.Track.sensor_id)
  return _internal_sensor_id();
}
inline void Track::_internal_set_sensor_id(uint32_t value) {
  
  _impl_.sensor_id_ = value;
}
inline void Track::set_sensor_id(uint32_t value) {
  _internal_set_sensor_id(value);
  // @@protoc_insertion_point(field_set:radar.messages.Track.sensor_id)
}

// .google.protobuf.Timestamp created_time = 3;
inline bool Track::_internal_has_created_time() const {
  return this != internal_default_instance() && _impl_.created_time_ != nullptr;
}
inline bool Track::has_created_time() const {
  return _internal_has_created_time();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& Track::_internal_created_time() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.created_time_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& Track::created_time() const {
  // @@protoc_insertion_point(field_get:radar.messages.Track.created_time)
  return _internal_created_time();
}
inline void Track::unsafe_arena_set_allocated_created_time(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* created_time) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.created_time_);
  }
  _impl_.created_time_ = created_time;
  if (created_time) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:radar.messages.Track.created_time)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Track::release_created_time() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.created_time_;
  _impl_.created_time_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Track::unsafe_arena_release_created_time() {
  // @@protoc_insertion_point(field_release:radar.messages.Track.created_time)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.created_time_;
  _impl_.created_time_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Track::_internal_mutable_created_time() {
  
  if (_impl_.created_time_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.created_time_ = p;
  }
  return _impl_.created_time_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Track::mutable_created_time() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_created_time();
  // @@protoc_insertion_point(field_mutable:radar.messages.Track.created_time)
  return _msg;
}
inline void Track::set_allocated_created_time(::PROTOBUF_NAMESPACE_ID::Timestamp* created_time) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.created_time_);
  }
  if (created_time) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(created_time));
    if (message_arena != submessage_arena) {
      created_time = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, created_time, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.created_time_ = created_time;
  // @@protoc_insertion_point(field_set_allocated:radar.messages.Track.created_time)
}

// .google.protobuf.Timestamp last_update_time = 4;
inline bool Track::_internal_has_last_update_time() const {
  return this != internal_default_instance() && _impl_.last_update_time_ != nullptr;
}
inline bool Track::has_last_update_time() const {
  return _internal_has_last_update_time();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& Track::_internal_last_update_time() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.last_update_time_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& Track::last_update_time() const {
  // @@protoc_insertion_point(field_get:radar.messages.Track.last_update_time)
  return _internal_last_update_time();
}
inline void Track::unsafe_arena_set_allocated_last_update_time(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* last_update_time) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.last_update_time_);
  }
  _impl_.last_update_time_ = last_update_time;
  if (last_update_time) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:radar.messages.Track.last_update_time)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Track::release_last_update_time() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.last_update_time_;
  _impl_.last_update_time_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Track::unsafe_arena_release_last_update_time() {
  // @@protoc_insertion_point(field_release:radar.messages.Track.last_update_time)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.last_update_time_;
  _impl_.last_update_time_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Track::_internal_mutable_last_update_time() {
  
  if (_impl_.last_update_time_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.last_update_time_ = p;
  }
  return _impl_.last_update_time_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Track::mutable_last_update_time() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_last_update_time();
  // @@protoc_insertion_point(field_mutable:radar.messages.Track.last_update_time)
  return _msg;
}
inline void Track::set_allocated_last_update_time(::PROTOBUF_NAMESPACE_ID::Timestamp* last_update_time) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.last_update_time_);
  }
  if (last_update_time) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(last_update_time));
    if (message_arena != submessage_arena) {
      last_update_time = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, last_update_time, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.last_update_time_ = last_update_time;
  // @@protoc_insertion_point(field_set_allocated:radar.messages.Track.last_update_time)
}

// .radar.messages.TrackState current_state = 5;
inline bool Track::_internal_has_current_state() const {
  return this != internal_default_instance() && _impl_.current_state_ != nullptr;
}
inline bool Track::has_current_state() const {
  return _internal_has_current_state();
}
inline void Track::clear_current_state() {
  if (GetArenaForAllocation() == nullptr && _impl_.current_state_ != nullptr) {
    delete _impl_.current_state_;
  }
  _impl_.current_state_ = nullptr;
}
inline const ::radar::messages::TrackState& Track::_internal_current_state() const {
  const ::radar::messages::TrackState* p = _impl_.current_state_;
  return p != nullptr ? *p : reinterpret_cast<const ::radar::messages::TrackState&>(
      ::radar::messages::_TrackState_default_instance_);
}
inline const ::radar::messages::TrackState& Track::current_state() const {
  // @@protoc_insertion_point(field_get:radar.messages.Track.current_state)
  return _internal_current_state();
}
inline void Track::unsafe_arena_set_allocated_current_state(
    ::radar::messages::TrackState* current_state) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.current_state_);
  }
  _impl_.current_state_ = current_state;
  if (current_state) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:radar.messages.Track.current_state)
}
inline ::radar::messages::TrackState* Track::release_current_state() {
  
  ::radar::messages::TrackState* temp = _impl_.current_state_;
  _impl_.current_state_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::radar::messages::TrackState* Track::unsafe_arena_release_current_state() {
  // @@protoc_insertion_point(field_release:radar.messages.Track.current_state)
  
  ::radar::messages::TrackState* temp = _impl_.current_state_;
  _impl_.current_state_ = nullptr;
  return temp;
}
inline ::radar::messages::TrackState* Track::_internal_mutable_current_state() {
  
  if (_impl_.current_state_ == nullptr) {
    auto* p = CreateMaybeMessage<::radar::messages::TrackState>(GetArenaForAllocation());
    _impl_.current_state_ = p;
  }
  return _impl_.current_state_;
}
inline ::radar::messages::TrackState* Track::mutable_current_state() {
  ::radar::messages::TrackState* _msg = _internal_mutable_current_state();
  // @@protoc_insertion_point(field_mutable:radar.messages.Track.current_state)
  return _msg;
}
inline void Track::set_allocated_current_state(::radar::messages::TrackState* current_state) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.current_state_;
  }
  if (current_state) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(current_state);
    if (message_arena != submessage_arena) {
      current_state = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, current_state, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.current_state_ = current_state;
  // @@protoc_insertion_point(field_set_allocated:radar.messages.Track.current_state)
}

// .radar.messages.TrackState predicted_state = 6;
inline bool Track::_internal_has_predicted_state() const {
  return this != internal_default_instance() && _impl_.predicted_state_ != nullptr;
}
inline bool Track::has_predicted_state() const {
  return _internal_has_predicted_state();
}
inline void Track::clear_predicted_state() {
  if (GetArenaForAllocation() == nullptr && _impl_.predicted_state_ != nullptr) {
    delete _impl_.predicted_state_;
  }
  _impl_.predicted_state_ = nullptr;
}
inline const ::radar::messages::TrackState& Track::_internal_predicted_state() const {
  const ::radar::messages::TrackState* p = _impl_.predicted_state_;
  return p != nullptr ? *p : reinterpret_cast<const ::radar::messages::TrackState&>(
      ::radar::messages::_TrackState_default_instance_);
}
inline const ::radar::messages::TrackState& Track::predicted_state() const {
  // @@protoc_insertion_point(field_get:radar.messages.Track.predicted_state)
  return _internal_predicted_state();
}
inline void Track::unsafe_arena_set_allocated_predicted_state(
    ::radar::messages::TrackState* predicted_state) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.predicted_state_);
  }
  _impl_.predicted_state_ = predicted_state;
  if (predicted_state) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:radar.messages.Track.predicted_state)
}
inline ::radar::messages::TrackState* Track::release_predicted_state() {
  
  ::radar::messages::TrackState* temp = _impl_.predicted_state_;
  _impl_.predicted_state_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::radar::messages::TrackState* Track::unsafe_arena_release_predicted_state() {
  // @@protoc_insertion_point(field_release:radar.messages.Track.predicted_state)
  
  ::radar::messages::TrackState* temp = _impl_.predicted_state_;
  _impl_.predicted_state_ = nullptr;
  return temp;
}
inline ::radar::messages::TrackState* Track::_internal_mutable_predicted_state() {
  
  if (_impl_.predicted_state_ == nullptr) {
    auto* p = CreateMaybeMessage<::radar::messages::TrackState>(GetArenaForAllocation());
    _impl_.predicted_state_ = p;
  }
  return _impl_.predicted_state_;
}
inline ::radar::messages::TrackState* Track::mutable_predicted_state() {
  ::radar::messages::TrackState* _msg = _internal_mutable_predicted_state();
  // @@protoc_insertion_point(field_mutable:radar.messages.Track.predicted_state)
  return _msg;
}
inline void Track::set_allocated_predicted_state(::radar::messages::TrackState* predicted_state) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.predicted_state_;
  }
  if (predicted_state) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(predicted_state);
    if (message_arena != submessage_arena) {
      predicted_state = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, predicted_state, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.predicted_state_ = predicted_state;
  // @@protoc_insertion_point(field_set_allocated:radar.messages.Track.predicted_state)
}

// .radar.messages.TrackState state = 7;
inline bool Track::_internal_has_state() const {
  return this != internal_default_instance() && _impl_.state_ != nullptr;
}
inline bool Track::has_state() const {
  return _internal_has_state();
}
inline void Track::clear_state() {
  if (GetArenaForAllocation() == nullptr && _impl_.state_ != nullptr) {
    delete _impl_.state_;
  }
  _impl_.state_ = nullptr;
}
inline const ::radar::messages::TrackState& Track::_internal_state() const {
  const ::radar::messages::TrackState* p = _impl_.state_;
  return p != nullptr ? *p : reinterpret_cast<const ::radar::messages::TrackState&>(
      ::radar::messages::_TrackState_default_instance_);
}
inline const ::radar::messages::TrackState& Track::state() const {
  // @@protoc_insertion_point(field_get:radar.messages.Track.state)
  return _internal_state();
}
inline void Track::unsafe_arena_set_allocated_state(
    ::radar::messages::TrackState* state) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.state_);
  }
  _impl_.state_ = state;
  if (state) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:radar.messages.Track.state)
}
inline ::radar::messages::TrackState* Track::release_state() {
  
  ::radar::messages::TrackState* temp = _impl_.state_;
  _impl_.state_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::radar::messages::TrackState* Track::unsafe_arena_release_state() {
  // @@protoc_insertion_point(field_release:radar.messages.Track.state)
  
  ::radar::messages::TrackState* temp = _impl_.state_;
  _impl_.state_ = nullptr;
  return temp;
}
inline ::radar::messages::TrackState* Track::_internal_mutable_state() {
  
  if (_impl_.state_ == nullptr) {
    auto* p = CreateMaybeMessage<::radar::messages::TrackState>(GetArenaForAllocation());
    _impl_.state_ = p;
  }
  return _impl_.state_;
}
inline ::radar::messages::TrackState* Track::mutable_state() {
  ::radar::messages::TrackState* _msg = _internal_mutable_state();
  // @@protoc_insertion_point(field_mutable:radar.messages.Track.state)
  return _msg;
}
inline void Track::set_allocated_state(::radar::messages::TrackState* state) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.state_;
  }
  if (state) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(state);
    if (message_arena != submessage_arena) {
      state = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, state, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.state_ = state;
  // @@protoc_insertion_point(field_set_allocated:radar.messages.Track.state)
}

// uint32 hit_count = 8;
inline void Track::clear_hit_count() {
  _impl_.hit_count_ = 0u;
}
inline uint32_t Track::_internal_hit_count() const {
  return _impl_.hit_count_;
}
inline uint32_t Track::hit_count() const {
  // @@protoc_insertion_point(field_get:radar.messages.Track.hit_count)
  return _internal_hit_count();
}
inline void Track::_internal_set_hit_count(uint32_t value) {
  
  _impl_.hit_count_ = value;
}
inline void Track::set_hit_count(uint32_t value) {
  _internal_set_hit_count(value);
  // @@protoc_insertion_point(field_set:radar.messages.Track.hit_count)
}

// uint32 miss_count = 9;
inline void Track::clear_miss_count() {
  _impl_.miss_count_ = 0u;
}
inline uint32_t Track::_internal_miss_count() const {
  return _impl_.miss_count_;
}
inline uint32_t Track::miss_count() const {
  // @@protoc_insertion_point(field_get:radar.messages.Track.miss_count)
  return _internal_miss_count();
}
inline void Track::_internal_set_miss_count(uint32_t value) {
  
  _impl_.miss_count_ = value;
}
inline void Track::set_miss_count(uint32_t value) {
  _internal_set_miss_count(value);
  // @@protoc_insertion_point(field_set:radar.messages.Track.miss_count)
}

// uint32 coast_count = 10;
inline void Track::clear_coast_count() {
  _impl_.coast_count_ = 0u;
}
inline uint32_t Track::_internal_coast_count() const {
  return _impl_.coast_count_;
}
inline uint32_t Track::coast_count() const {
  // @@protoc_insertion_point(field_get:radar.messages.Track.coast_count)
  return _internal_coast_count();
}
inline void Track::_internal_set_coast_count(uint32_t value) {
  
  _impl_.coast_count_ = value;
}
inline void Track::set_coast_count(uint32_t value) {
  _internal_set_coast_count(value);
  // @@protoc_insertion_point(field_set:radar.messages.Track.coast_count)
}

// double confidence = 11;
inline void Track::clear_confidence() {
  _impl_.confidence_ = 0;
}
inline double Track::_internal_confidence() const {
  return _impl_.confidence_;
}
inline double Track::confidence() const {
  // @@protoc_insertion_point(field_get:radar.messages.Track.confidence)
  return _internal_confidence();
}
inline void Track::_internal_set_confidence(double value) {
  
  _impl_.confidence_ = value;
}
inline void Track::set_confidence(double value) {
  _internal_set_confidence(value);
  // @@protoc_insertion_point(field_set:radar.messages.Track.confidence)
}

// double likelihood = 12;
inline void Track::clear_likelihood() {
  _impl_.likelihood_ = 0;
}
inline double Track::_internal_likelihood() const {
  return _impl_.likelihood_;
}
inline double Track::likelihood() const {
  // @@protoc_insertion_point(field_get:radar.messages.Track.likelihood)
  return _internal_likelihood();
}
inline void Track::_internal_set_likelihood(double value) {
  
  _impl_.likelihood_ = value;
}
inline void Track::set_likelihood(double value) {
  _internal_set_likelihood(value);
  // @@protoc_insertion_point(field_set:radar.messages.Track.likelihood)
}

// .radar.messages.FilterType filter_type = 13;
inline void Track::clear_filter_type() {
  _impl_.filter_type_ = 0;
}
inline ::radar::messages::FilterType Track::_internal_filter_type() const {
  return static_cast< ::radar::messages::FilterType >(_impl_.filter_type_);
}
inline ::radar::messages::FilterType Track::filter_type() const {
  // @@protoc_insertion_point(field_get:radar.messages.Track.filter_type)
  return _internal_filter_type();
}
inline void Track::_internal_set_filter_type(::radar::messages::FilterType value) {
  
  _impl_.filter_type_ = value;
}
inline void Track::set_filter_type(::radar::messages::FilterType value) {
  _internal_set_filter_type(value);
  // @@protoc_insertion_point(field_set:radar.messages.Track.filter_type)
}

// string target_class = 14;
inline void Track::clear_target_class() {
  _impl_.target_class_.ClearToEmpty();
}
inline const std::string& Track::target_class() const {
  // @@protoc_insertion_point(field_get:radar.messages.Track.target_class)
  return _internal_target_class();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Track::set_target_class(ArgT0&& arg0, ArgT... args) {
 
 _impl_.target_class_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:radar.messages.Track.target_class)
}
inline std::string* Track::mutable_target_class() {
  std::string* _s = _internal_mutable_target_class();
  // @@protoc_insertion_point(field_mutable:radar.messages.Track.target_class)
  return _s;
}
inline const std::string& Track::_internal_target_class() const {
  return _impl_.target_class_.Get();
}
inline void Track::_internal_set_target_class(const std::string& value) {
  
  _impl_.target_class_.Set(value, GetArenaForAllocation());
}
inline std::string* Track::_internal_mutable_target_class() {
  
  return _impl_.target_class_.Mutable(GetArenaForAllocation());
}
inline std::string* Track::release_target_class() {
  // @@protoc_insertion_point(field_release:radar.messages.Track.target_class)
  return _impl_.target_class_.Release();
}
inline void Track::set_allocated_target_class(std::string* target_class) {
  if (target_class != nullptr) {
    
  } else {
    
  }
  _impl_.target_class_.SetAllocated(target_class, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.target_class_.IsDefault()) {
    _impl_.target_class_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:radar.messages.Track.target_class)
}

// map<string, double> classification_scores = 15;
inline int Track::_internal_classification_scores_size() const {
  return _impl_.classification_scores_.size();
}
inline int Track::classification_scores_size() const {
  return _internal_classification_scores_size();
}
inline void Track::clear_classification_scores() {
  _impl_.classification_scores_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >&
Track::_internal_classification_scores() const {
  return _impl_.classification_scores_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >&
Track::classification_scores() const {
  // @@protoc_insertion_point(field_map:radar.messages.Track.classification_scores)
  return _internal_classification_scores();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >*
Track::_internal_mutable_classification_scores() {
  return _impl_.classification_scores_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >*
Track::mutable_classification_scores() {
  // @@protoc_insertion_point(field_mutable_map:radar.messages.Track.classification_scores)
  return _internal_mutable_classification_scores();
}

// double track_quality = 16;
inline void Track::clear_track_quality() {
  _impl_.track_quality_ = 0;
}
inline double Track::_internal_track_quality() const {
  return _impl_.track_quality_;
}
inline double Track::track_quality() const {
  // @@protoc_insertion_point(field_get:radar.messages.Track.track_quality)
  return _internal_track_quality();
}
inline void Track::_internal_set_track_quality(double value) {
  
  _impl_.track_quality_ = value;
}
inline void Track::set_track_quality(double value) {
  _internal_set_track_quality(value);
  // @@protoc_insertion_point(field_set:radar.messages.Track.track_quality)
}

// double innovation_magnitude = 17;
inline void Track::clear_innovation_magnitude() {
  _impl_.innovation_magnitude_ = 0;
}
inline double Track::_internal_innovation_magnitude() const {
  return _impl_.innovation_magnitude_;
}
inline double Track::innovation_magnitude() const {
  // @@protoc_insertion_point(field_get:radar.messages.Track.innovation_magnitude)
  return _internal_innovation_magnitude();
}
inline void Track::_internal_set_innovation_magnitude(double value) {
  
  _impl_.innovation_magnitude_ = value;
}
inline void Track::set_innovation_magnitude(double value) {
  _internal_set_innovation_magnitude(value);
  // @@protoc_insertion_point(field_set:radar.messages.Track.innovation_magnitude)
}

// double mahalanobis_distance = 18;
inline void Track::clear_mahalanobis_distance() {
  _impl_.mahalanobis_distance_ = 0;
}
inline double Track::_internal_mahalanobis_distance() const {
  return _impl_.mahalanobis_distance_;
}
inline double Track::mahalanobis_distance() const {
  // @@protoc_insertion_point(field_get:radar.messages.Track.mahalanobis_distance)
  return _internal_mahalanobis_distance();
}
inline void Track::_internal_set_mahalanobis_distance(double value) {
  
  _impl_.mahalanobis_distance_ = value;
}
inline void Track::set_mahalanobis_distance(double value) {
  _internal_set_mahalanobis_distance(value);
  // @@protoc_insertion_point(field_set:radar.messages.Track.mahalanobis_distance)
}

// double speed = 19;
inline void Track::clear_speed() {
  _impl_.speed_ = 0;
}
inline double Track::_internal_speed() const {
  return _impl_.speed_;
}
inline double Track::speed() const {
  // @@protoc_insertion_point(field_get:radar.messages.Track.speed)
  return _internal_speed();
}
inline void Track::_internal_set_speed(double value) {
  
  _impl_.speed_ = value;
}
inline void Track::set_speed(double value) {
  _internal_set_speed(value);
  // @@protoc_insertion_point(field_set:radar.messages.Track.speed)
}

// double heading = 20;
inline void Track::clear_heading() {
  _impl_.heading_ = 0;
}
inline double Track::_internal_heading() const {
  return _impl_.heading_;
}
inline double Track::heading() const {
  // @@protoc_insertion_point(field_get:radar.messages.Track.heading)
  return _internal_heading();
}
inline void Track::_internal_set_heading(double value) {
  
  _impl_.heading_ = value;
}
inline void Track::set_heading(double value) {
  _internal_set_heading(value);
  // @@protoc_insertion_point(field_set:radar.messages.Track.heading)
}

// double turn_rate = 21;
inline void Track::clear_turn_rate() {
  _impl_.turn_rate_ = 0;
}
inline double Track::_internal_turn_rate() const {
  return _impl_.turn_rate_;
}
inline double Track::turn_rate() const {
  // @@protoc_insertion_point(field_get:radar.messages.Track.turn_rate)
  return _internal_turn_rate();
}
inline void Track::_internal_set_turn_rate(double value) {
  
  _impl_.turn_rate_ = value;
}
inline void Track::set_turn_rate(double value) {
  _internal_set_turn_rate(value);
  // @@protoc_insertion_point(field_set:radar.messages.Track.turn_rate)
}

// double range = 22;
inline void Track::clear_range() {
  _impl_.range_ = 0;
}
inline double Track::_internal_range() const {
  return _impl_.range_;
}
inline double Track::range() const {
  // @@protoc_insertion_point(field_get:radar.messages.Track.range)
  return _internal_range();
}
inline void Track::_internal_set_range(double value) {
  
  _impl_.range_ = value;
}
inline void Track::set_range(double value) {
  _internal_set_range(value);
  // @@protoc_insertion_point(field_set:radar.messages.Track.range)
}

// double bearing = 23;
inline void Track::clear_bearing() {
  _impl_.bearing_ = 0;
}
inline double Track::_internal_bearing() const {
  return _impl_.bearing_;
}
inline double Track::bearing() const {
  // @@protoc_insertion_point(field_get:radar.messages.Track.bearing)
  return _internal_bearing();
}
inline void Track::_internal_set_bearing(double value) {
  
  _impl_.bearing_ = value;
}
inline void Track::set_bearing(double value) {
  _internal_set_bearing(value);
  // @@protoc_insertion_point(field_set:radar.messages.Track.bearing)
}

// double elevation = 24;
inline void Track::clear_elevation() {
  _impl_.elevation_ = 0;
}
inline double Track::_internal_elevation() const {
  return _impl_.elevation_;
}
inline double Track::elevation() const {
  // @@protoc_insertion_point(field_get:radar.messages.Track.elevation)
  return _internal_elevation();
}
inline void Track::_internal_set_elevation(double value) {
  
  _impl_.elevation_ = value;
}
inline void Track::set_elevation(double value) {
  _internal_set_elevation(value);
  // @@protoc_insertion_point(field_set:radar.messages.Track.elevation)
}

// map<string, double> attributes = 25;
inline int Track::_internal_attributes_size() const {
  return _impl_.attributes_.size();
}
inline int Track::attributes_size() const {
  return _internal_attributes_size();
}
inline void Track::clear_attributes() {
  _impl_.attributes_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >&
Track::_internal_attributes() const {
  return _impl_.attributes_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >&
Track::attributes() const {
  // @@protoc_insertion_point(field_map:radar.messages.Track.attributes)
  return _internal_attributes();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >*
Track::_internal_mutable_attributes() {
  return _impl_.attributes_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >*
Track::mutable_attributes() {
  // @@protoc_insertion_point(field_mutable_map:radar.messages.Track.attributes)
  return _internal_mutable_attributes();
}

// -------------------------------------------------------------------

// TrackBatch

// repeated .radar.messages.Track tracks = 1;
inline int TrackBatch::_internal_tracks_size() const {
  return _impl_.tracks_.size();
}
inline int TrackBatch::tracks_size() const {
  return _internal_tracks_size();
}
inline void TrackBatch::clear_tracks() {
  _impl_.tracks_.Clear();
}
inline ::radar::messages::Track* TrackBatch::mutable_tracks(int index) {
  // @@protoc_insertion_point(field_mutable:radar.messages.TrackBatch.tracks)
  return _impl_.tracks_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::radar::messages::Track >*
TrackBatch::mutable_tracks() {
  // @@protoc_insertion_point(field_mutable_list:radar.messages.TrackBatch.tracks)
  return &_impl_.tracks_;
}
inline const ::radar::messages::Track& TrackBatch::_internal_tracks(int index) const {
  return _impl_.tracks_.Get(index);
}
inline const ::radar::messages::Track& TrackBatch::tracks(int index) const {
  // @@protoc_insertion_point(field_get:radar.messages.TrackBatch.tracks)
  return _internal_tracks(index);
}
inline ::radar::messages::Track* TrackBatch::_internal_add_tracks() {
  return _impl_.tracks_.Add();
}
inline ::radar::messages::Track* TrackBatch::add_tracks() {
  ::radar::messages::Track* _add = _internal_add_tracks();
  // @@protoc_insertion_point(field_add:radar.messages.TrackBatch.tracks)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::radar::messages::Track >&
TrackBatch::tracks() const {
  // @@protoc_insertion_point(field_list:radar.messages.TrackBatch.tracks)
  return _impl_.tracks_;
}

// .google.protobuf.Timestamp batch_timestamp = 2;
inline bool TrackBatch::_internal_has_batch_timestamp() const {
  return this != internal_default_instance() && _impl_.batch_timestamp_ != nullptr;
}
inline bool TrackBatch::has_batch_timestamp() const {
  return _internal_has_batch_timestamp();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& TrackBatch::_internal_batch_timestamp() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.batch_timestamp_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& TrackBatch::batch_timestamp() const {
  // @@protoc_insertion_point(field_get:radar.messages.TrackBatch.batch_timestamp)
  return _internal_batch_timestamp();
}
inline void TrackBatch::unsafe_arena_set_allocated_batch_timestamp(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* batch_timestamp) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.batch_timestamp_);
  }
  _impl_.batch_timestamp_ = batch_timestamp;
  if (batch_timestamp) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:radar.messages.TrackBatch.batch_timestamp)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* TrackBatch::release_batch_timestamp() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.batch_timestamp_;
  _impl_.batch_timestamp_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* TrackBatch::unsafe_arena_release_batch_timestamp() {
  // @@protoc_insertion_point(field_release:radar.messages.TrackBatch.batch_timestamp)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.batch_timestamp_;
  _impl_.batch_timestamp_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* TrackBatch::_internal_mutable_batch_timestamp() {
  
  if (_impl_.batch_timestamp_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.batch_timestamp_ = p;
  }
  return _impl_.batch_timestamp_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* TrackBatch::mutable_batch_timestamp() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_batch_timestamp();
  // @@protoc_insertion_point(field_mutable:radar.messages.TrackBatch.batch_timestamp)
  return _msg;
}
inline void TrackBatch::set_allocated_batch_timestamp(::PROTOBUF_NAMESPACE_ID::Timestamp* batch_timestamp) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.batch_timestamp_);
  }
  if (batch_timestamp) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(batch_timestamp));
    if (message_arena != submessage_arena) {
      batch_timestamp = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, batch_timestamp, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.batch_timestamp_ = batch_timestamp;
  // @@protoc_insertion_point(field_set_allocated:radar.messages.TrackBatch.batch_timestamp)
}

// uint32 sensor_id = 3;
inline void TrackBatch::clear_sensor_id() {
  _impl_.sensor_id_ = 0u;
}
inline uint32_t TrackBatch::_internal_sensor_id() const {
  return _impl_.sensor_id_;
}
inline uint32_t TrackBatch::sensor_id() const {
  // @@protoc_insertion_point(field_get:radar.messages.TrackBatch.sensor_id)
  return _internal_sensor_id();
}
inline void TrackBatch::_internal_set_sensor_id(uint32_t value) {
  
  _impl_.sensor_id_ = value;
}
inline void TrackBatch::set_sensor_id(uint32_t value) {
  _internal_set_sensor_id(value);
  // @@protoc_insertion_point(field_set:radar.messages.TrackBatch.sensor_id)
}

// uint32 sequence_number = 4;
inline void TrackBatch::clear_sequence_number() {
  _impl_.sequence_number_ = 0u;
}
inline uint32_t TrackBatch::_internal_sequence_number() const {
  return _impl_.sequence_number_;
}
inline uint32_t TrackBatch::sequence_number() const {
  // @@protoc_insertion_point(field_get:radar.messages.TrackBatch.sequence_number)
  return _internal_sequence_number();
}
inline void TrackBatch::_internal_set_sequence_number(uint32_t value) {
  
  _impl_.sequence_number_ = value;
}
inline void TrackBatch::set_sequence_number(uint32_t value) {
  _internal_set_sequence_number(value);
  // @@protoc_insertion_point(field_set:radar.messages.TrackBatch.sequence_number)
}

// double processing_time_ms = 5;
inline void TrackBatch::clear_processing_time_ms() {
  _impl_.processing_time_ms_ = 0;
}
inline double TrackBatch::_internal_processing_time_ms() const {
  return _impl_.processing_time_ms_;
}
inline double TrackBatch::processing_time_ms() const {
  // @@protoc_insertion_point(field_get:radar.messages.TrackBatch.processing_time_ms)
  return _internal_processing_time_ms();
}
inline void TrackBatch::_internal_set_processing_time_ms(double value) {
  
  _impl_.processing_time_ms_ = value;
}
inline void TrackBatch::set_processing_time_ms(double value) {
  _internal_set_processing_time_ms(value);
  // @@protoc_insertion_point(field_set:radar.messages.TrackBatch.processing_time_ms)
}

// uint32 total_tracks = 6;
inline void TrackBatch::clear_total_tracks() {
  _impl_.total_tracks_ = 0u;
}
inline uint32_t TrackBatch::_internal_total_tracks() const {
  return _impl_.total_tracks_;
}
inline uint32_t TrackBatch::total_tracks() const {
  // @@protoc_insertion_point(field_get:radar.messages.TrackBatch.total_tracks)
  return _internal_total_tracks();
}
inline void TrackBatch::_internal_set_total_tracks(uint32_t value) {
  
  _impl_.total_tracks_ = value;
}
inline void TrackBatch::set_total_tracks(uint32_t value) {
  _internal_set_total_tracks(value);
  // @@protoc_insertion_point(field_set:radar.messages.TrackBatch.total_tracks)
}

// uint32 confirmed_tracks = 7;
inline void TrackBatch::clear_confirmed_tracks() {
  _impl_.confirmed_tracks_ = 0u;
}
inline uint32_t TrackBatch::_internal_confirmed_tracks() const {
  return _impl_.confirmed_tracks_;
}
inline uint32_t TrackBatch::confirmed_tracks() const {
  // @@protoc_insertion_point(field_get:radar.messages.TrackBatch.confirmed_tracks)
  return _internal_confirmed_tracks();
}
inline void TrackBatch::_internal_set_confirmed_tracks(uint32_t value) {
  
  _impl_.confirmed_tracks_ = value;
}
inline void TrackBatch::set_confirmed_tracks(uint32_t value) {
  _internal_set_confirmed_tracks(value);
  // @@protoc_insertion_point(field_set:radar.messages.TrackBatch.confirmed_tracks)
}

// uint32 tentative_tracks = 8;
inline void TrackBatch::clear_tentative_tracks() {
  _impl_.tentative_tracks_ = 0u;
}
inline uint32_t TrackBatch::_internal_tentative_tracks() const {
  return _impl_.tentative_tracks_;
}
inline uint32_t TrackBatch::tentative_tracks() const {
  // @@protoc_insertion_point(field_get:radar.messages.TrackBatch.tentative_tracks)
  return _internal_tentative_tracks();
}
inline void TrackBatch::_internal_set_tentative_tracks(uint32_t value) {
  
  _impl_.tentative_tracks_ = value;
}
inline void TrackBatch::set_tentative_tracks(uint32_t value) {
  _internal_set_tentative_tracks(value);
  // @@protoc_insertion_point(field_set:radar.messages.TrackBatch.tentative_tracks)
}

// uint32 coasting_tracks = 9;
inline void TrackBatch::clear_coasting_tracks() {
  _impl_.coasting_tracks_ = 0u;
}
inline uint32_t TrackBatch::_internal_coasting_tracks() const {
  return _impl_.coasting_tracks_;
}
inline uint32_t TrackBatch::coasting_tracks() const {
  // @@protoc_insertion_point(field_get:radar.messages.TrackBatch.coasting_tracks)
  return _internal_coasting_tracks();
}
inline void TrackBatch::_internal_set_coasting_tracks(uint32_t value) {
  
  _impl_.coasting_tracks_ = value;
}
inline void TrackBatch::set_coasting_tracks(uint32_t value) {
  _internal_set_coasting_tracks(value);
  // @@protoc_insertion_point(field_set:radar.messages.TrackBatch.coasting_tracks)
}

// uint32 deleted_tracks = 10;
inline void TrackBatch::clear_deleted_tracks() {
  _impl_.deleted_tracks_ = 0u;
}
inline uint32_t TrackBatch::_internal_deleted_tracks() const {
  return _impl_.deleted_tracks_;
}
inline uint32_t TrackBatch::deleted_tracks() const {
  // @@protoc_insertion_point(field_get:radar.messages.TrackBatch.deleted_tracks)
  return _internal_deleted_tracks();
}
inline void TrackBatch::_internal_set_deleted_tracks(uint32_t value) {
  
  _impl_.deleted_tracks_ = value;
}
inline void TrackBatch::set_deleted_tracks(uint32_t value) {
  _internal_set_deleted_tracks(value);
  // @@protoc_insertion_point(field_set:radar.messages.TrackBatch.deleted_tracks)
}

// uint32 total_associations = 11;
inline void TrackBatch::clear_total_associations() {
  _impl_.total_associations_ = 0u;
}
inline uint32_t TrackBatch::_internal_total_associations() const {
  return _impl_.total_associations_;
}
inline uint32_t TrackBatch::total_associations() const {
  // @@protoc_insertion_point(field_get:radar.messages.TrackBatch.total_associations)
  return _internal_total_associations();
}
inline void TrackBatch::_internal_set_total_associations(uint32_t value) {
  
  _impl_.total_associations_ = value;
}
inline void TrackBatch::set_total_associations(uint32_t value) {
  _internal_set_total_associations(value);
  // @@protoc_insertion_point(field_set:radar.messages.TrackBatch.total_associations)
}

// uint32 successful_associations = 12;
inline void TrackBatch::clear_successful_associations() {
  _impl_.successful_associations_ = 0u;
}
inline uint32_t TrackBatch::_internal_successful_associations() const {
  return _impl_.successful_associations_;
}
inline uint32_t TrackBatch::successful_associations() const {
  // @@protoc_insertion_point(field_get:radar.messages.TrackBatch.successful_associations)
  return _internal_successful_associations();
}
inline void TrackBatch::_internal_set_successful_associations(uint32_t value) {
  
  _impl_.successful_associations_ = value;
}
inline void TrackBatch::set_successful_associations(uint32_t value) {
  _internal_set_successful_associations(value);
  // @@protoc_insertion_point(field_set:radar.messages.TrackBatch.successful_associations)
}

// double association_rate = 13;
inline void TrackBatch::clear_association_rate() {
  _impl_.association_rate_ = 0;
}
inline double TrackBatch::_internal_association_rate() const {
  return _impl_.association_rate_;
}
inline double TrackBatch::association_rate() const {
  // @@protoc_insertion_point(field_get:radar.messages.TrackBatch.association_rate)
  return _internal_association_rate();
}
inline void TrackBatch::_internal_set_association_rate(double value) {
  
  _impl_.association_rate_ = value;
}
inline void TrackBatch::set_association_rate(double value) {
  _internal_set_association_rate(value);
  // @@protoc_insertion_point(field_set:radar.messages.TrackBatch.association_rate)
}

// .radar.messages.PerformanceMetrics performance = 14;
inline bool TrackBatch::_internal_has_performance() const {
  return this != internal_default_instance() && _impl_.performance_ != nullptr;
}
inline bool TrackBatch::has_performance() const {
  return _internal_has_performance();
}
inline const ::radar::messages::PerformanceMetrics& TrackBatch::_internal_performance() const {
  const ::radar::messages::PerformanceMetrics* p = _impl_.performance_;
  return p != nullptr ? *p : reinterpret_cast<const ::radar::messages::PerformanceMetrics&>(
      ::radar::messages::_PerformanceMetrics_default_instance_);
}
inline const ::radar::messages::PerformanceMetrics& TrackBatch::performance() const {
  // @@protoc_insertion_point(field_get:radar.messages.TrackBatch.performance)
  return _internal_performance();
}
inline void TrackBatch::unsafe_arena_set_allocated_performance(
    ::radar::messages::PerformanceMetrics* performance) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.performance_);
  }
  _impl_.performance_ = performance;
  if (performance) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:radar.messages.TrackBatch.performance)
}
inline ::radar::messages::PerformanceMetrics* TrackBatch::release_performance() {
  
  ::radar::messages::PerformanceMetrics* temp = _impl_.performance_;
  _impl_.performance_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::radar::messages::PerformanceMetrics* TrackBatch::unsafe_arena_release_performance() {
  // @@protoc_insertion_point(field_release:radar.messages.TrackBatch.performance)
  
  ::radar::messages::PerformanceMetrics* temp = _impl_.performance_;
  _impl_.performance_ = nullptr;
  return temp;
}
inline ::radar::messages::PerformanceMetrics* TrackBatch::_internal_mutable_performance() {
  
  if (_impl_.performance_ == nullptr) {
    auto* p = CreateMaybeMessage<::radar::messages::PerformanceMetrics>(GetArenaForAllocation());
    _impl_.performance_ = p;
  }
  return _impl_.performance_;
}
inline ::radar::messages::PerformanceMetrics* TrackBatch::mutable_performance() {
  ::radar::messages::PerformanceMetrics* _msg = _internal_mutable_performance();
  // @@protoc_insertion_point(field_mutable:radar.messages.TrackBatch.performance)
  return _msg;
}
inline void TrackBatch::set_allocated_performance(::radar::messages::PerformanceMetrics* performance) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.performance_);
  }
  if (performance) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(performance));
    if (message_arena != submessage_arena) {
      performance = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, performance, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.performance_ = performance;
  // @@protoc_insertion_point(field_set_allocated:radar.messages.TrackBatch.performance)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// TrackUpdate

// uint32 track_id = 1;
inline void TrackUpdate::clear_track_id() {
  _impl_.track_id_ = 0u;
}
inline uint32_t TrackUpdate::_internal_track_id() const {
  return _impl_.track_id_;
}
inline uint32_t TrackUpdate::track_id() const {
  // @@protoc_insertion_point(field_get:radar.messages.TrackUpdate.track_id)
  return _internal_track_id();
}
inline void TrackUpdate::_internal_set_track_id(uint32_t value) {
  
  _impl_.track_id_ = value;
}
inline void TrackUpdate::set_track_id(uint32_t value) {
  _internal_set_track_id(value);
  // @@protoc_insertion_point(field_set:radar.messages.TrackUpdate.track_id)
}

// uint32 sensor_id = 2;
inline void TrackUpdate::clear_sensor_id() {
  _impl_.sensor_id_ = 0u;
}
inline uint32_t TrackUpdate::_internal_sensor_id() const {
  return _impl_.sensor_id_;
}
inline uint32_t TrackUpdate::sensor_id() const {
  // @@protoc_insertion_point(field_get:radar.messages.TrackUpdate.sensor_id)
  return _internal_sensor_id();
}
inline void TrackUpdate::_internal_set_sensor_id(uint32_t value) {
  
  _impl_.sensor_id_ = value;
}
inline void TrackUpdate::set_sensor_id(uint32_t value) {
  _internal_set_sensor_id(value);
  // @@protoc_insertion_point(field_set:radar.messages.TrackUpdate.sensor_id)
}

// .google.protobuf.Timestamp timestamp = 3;
inline bool TrackUpdate::_internal_has_timestamp() const {
  return this != internal_default_instance() && _impl_.timestamp_ != nullptr;
}
inline bool TrackUpdate::has_timestamp() const {
  return _internal_has_timestamp();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& TrackUpdate::_internal_timestamp() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.timestamp_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& TrackUpdate::timestamp() const {
  // @@protoc_insertion_point(field_get:radar.messages.TrackUpdate.timestamp)
  return _internal_timestamp();
}
inline void TrackUpdate::unsafe_arena_set_allocated_timestamp(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.timestamp_);
  }
  _impl_.timestamp_ = timestamp;
  if (timestamp) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:radar.messages.TrackUpdate.timestamp)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* TrackUpdate::release_timestamp() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.timestamp_;
  _impl_.timestamp_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* TrackUpdate::unsafe_arena_release_timestamp() {
  // @@protoc_insertion_point(field_release:radar.messages.TrackUpdate.timestamp)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.timestamp_;
  _impl_.timestamp_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* TrackUpdate::_internal_mutable_timestamp() {
  
  if (_impl_.timestamp_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.timestamp_ = p;
  }
  return _impl_.timestamp_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* TrackUpdate::mutable_timestamp() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_timestamp();
  // @@protoc_insertion_point(field_mutable:radar.messages.TrackUpdate.timestamp)
  return _msg;
}
inline void TrackUpdate::set_allocated_timestamp(::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.timestamp_);
  }
  if (timestamp) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(timestamp));
    if (message_arena != submessage_arena) {
      timestamp = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, timestamp, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.timestamp_ = timestamp;
  // @@protoc_insertion_point(field_set_allocated:radar.messages.TrackUpdate.timestamp)
}

// .radar.messages.TrackUpdate.UpdateType update_type = 4;
inline void TrackUpdate::clear_update_type() {
  _impl_.update_type_ = 0;
}
inline ::radar::messages::TrackUpdate_UpdateType TrackUpdate::_internal_update_type() const {
  return static_cast< ::radar::messages::TrackUpdate_UpdateType >(_impl_.update_type_);
}
inline ::radar::messages::TrackUpdate_UpdateType TrackUpdate::update_type() const {
  // @@protoc_insertion_point(field_get:radar.messages.TrackUpdate.update_type)
  return _internal_update_type();
}
inline void TrackUpdate::_internal_set_update_type(::radar::messages::TrackUpdate_UpdateType value) {
  
  _impl_.update_type_ = value;
}
inline void TrackUpdate::set_update_type(::radar::messages::TrackUpdate_UpdateType value) {
  _internal_set_update_type(value);
  // @@protoc_insertion_point(field_set:radar.messages.TrackUpdate.update_type)
}

// .radar.messages.Track track = 5;
inline bool TrackUpdate::_internal_has_track() const {
  return this != internal_default_instance() && _impl_.track_ != nullptr;
}
inline bool TrackUpdate::has_track() const {
  return _internal_has_track();
}
inline void TrackUpdate::clear_track() {
  if (GetArenaForAllocation() == nullptr && _impl_.track_ != nullptr) {
    delete _impl_.track_;
  }
  _impl_.track_ = nullptr;
}
inline const ::radar::messages::Track& TrackUpdate::_internal_track() const {
  const ::radar::messages::Track* p = _impl_.track_;
  return p != nullptr ? *p : reinterpret_cast<const ::radar::messages::Track&>(
      ::radar::messages::_Track_default_instance_);
}
inline const ::radar::messages::Track& TrackUpdate::track() const {
  // @@protoc_insertion_point(field_get:radar.messages.TrackUpdate.track)
  return _internal_track();
}
inline void TrackUpdate::unsafe_arena_set_allocated_track(
    ::radar::messages::Track* track) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.track_);
  }
  _impl_.track_ = track;
  if (track) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:radar.messages.TrackUpdate.track)
}
inline ::radar::messages::Track* TrackUpdate::release_track() {
  
  ::radar::messages::Track* temp = _impl_.track_;
  _impl_.track_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::radar::messages::Track* TrackUpdate::unsafe_arena_release_track() {
  // @@protoc_insertion_point(field_release:radar.messages.TrackUpdate.track)
  
  ::radar::messages::Track* temp = _impl_.track_;
  _impl_.track_ = nullptr;
  return temp;
}
inline ::radar::messages::Track* TrackUpdate::_internal_mutable_track() {
  
  if (_impl_.track_ == nullptr) {
    auto* p = CreateMaybeMessage<::radar::messages::Track>(GetArenaForAllocation());
    _impl_.track_ = p;
  }
  return _impl_.track_;
}
inline ::radar::messages::Track* TrackUpdate::mutable_track() {
  ::radar::messages::Track* _msg = _internal_mutable_track();
  // @@protoc_insertion_point(field_mutable:radar.messages.TrackUpdate.track)
  return _msg;
}
inline void TrackUpdate::set_allocated_track(::radar::messages::Track* track) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.track_;
  }
  if (track) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(track);
    if (message_arena != submessage_arena) {
      track = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, track, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.track_ = track;
  // @@protoc_insertion_point(field_set_allocated:radar.messages.TrackUpdate.track)
}

// uint32 associated_detection_id = 6;
inline void TrackUpdate::clear_associated_detection_id() {
  _impl_.associated_detection_id_ = 0u;
}
inline uint32_t TrackUpdate::_internal_associated_detection_id() const {
  return _impl_.associated_detection_id_;
}
inline uint32_t TrackUpdate::associated_detection_id() const {
  // @@protoc_insertion_point(field_get:radar.messages.TrackUpdate.associated_detection_id)
  return _internal_associated_detection_id();
}
inline void TrackUpdate::_internal_set_associated_detection_id(uint32_t value) {
  
  _impl_.associated_detection_id_ = value;
}
inline void TrackUpdate::set_associated_detection_id(uint32_t value) {
  _internal_set_associated_detection_id(value);
  // @@protoc_insertion_point(field_set:radar.messages.TrackUpdate.associated_detection_id)
}

// double association_score = 7;
inline void TrackUpdate::clear_association_score() {
  _impl_.association_score_ = 0;
}
inline double TrackUpdate::_internal_association_score() const {
  return _impl_.association_score_;
}
inline double TrackUpdate::association_score() const {
  // @@protoc_insertion_point(field_get:radar.messages.TrackUpdate.association_score)
  return _internal_association_score();
}
inline void TrackUpdate::_internal_set_association_score(double value) {
  
  _impl_.association_score_ = value;
}
inline void TrackUpdate::set_association_score(double value) {
  _internal_set_association_score(value);
  // @@protoc_insertion_point(field_set:radar.messages.TrackUpdate.association_score)
}

// map<string, string> update_data = 8;
inline int TrackUpdate::_internal_update_data_size() const {
  return _impl_.update_data_.size();
}
inline int TrackUpdate::update_data_size() const {
  return _internal_update_data_size();
}
inline void TrackUpdate::clear_update_data() {
  _impl_.update_data_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
TrackUpdate::_internal_update_data() const {
  return _impl_.update_data_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
TrackUpdate::update_data() const {
  // @@protoc_insertion_point(field_map:radar.messages.TrackUpdate.update_data)
  return _internal_update_data();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
TrackUpdate::_internal_mutable_update_data() {
  return _impl_.update_data_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
TrackUpdate::mutable_update_data() {
  // @@protoc_insertion_point(field_mutable_map:radar.messages.TrackUpdate.update_data)
  return _internal_mutable_update_data();
}

// -------------------------------------------------------------------

// TrackHistory

// uint32 track_id = 1;
inline void TrackHistory::clear_track_id() {
  _impl_.track_id_ = 0u;
}
inline uint32_t TrackHistory::_internal_track_id() const {
  return _impl_.track_id_;
}
inline uint32_t TrackHistory::track_id() const {
  // @@protoc_insertion_point(field_get:radar.messages.TrackHistory.track_id)
  return _internal_track_id();
}
inline void TrackHistory::_internal_set_track_id(uint32_t value) {
  
  _impl_.track_id_ = value;
}
inline void TrackHistory::set_track_id(uint32_t value) {
  _internal_set_track_id(value);
  // @@protoc_insertion_point(field_set:radar.messages.TrackHistory.track_id)
}

// uint32 sensor_id = 2;
inline void TrackHistory::clear_sensor_id() {
  _impl_.sensor_id_ = 0u;
}
inline uint32_t TrackHistory::_internal_sensor_id() const {
  return _impl_.sensor_id_;
}
inline uint32_t TrackHistory::sensor_id() const {
  // @@protoc_insertion_point(field_get:radar.messages.TrackHistory.sensor_id)
  return _internal_sensor_id();
}
inline void TrackHistory::_internal_set_sensor_id(uint32_t value) {
  
  _impl_.sensor_id_ = value;
}
inline void TrackHistory::set_sensor_id(uint32_t value) {
  _internal_set_sensor_id(value);
  // @@protoc_insertion_point(field_set:radar.messages.TrackHistory.sensor_id)
}

// repeated .radar.messages.TrackState state_history = 3;
inline int TrackHistory::_internal_state_history_size() const {
  return _impl_.state_history_.size();
}
inline int TrackHistory::state_history_size() const {
  return _internal_state_history_size();
}
inline void TrackHistory::clear_state_history() {
  _impl_.state_history_.Clear();
}
inline ::radar::messages::TrackState* TrackHistory::mutable_state_history(int index) {
  // @@protoc_insertion_point(field_mutable:radar.messages.TrackHistory.state_history)
  return _impl_.state_history_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::radar::messages::TrackState >*
TrackHistory::mutable_state_history() {
  // @@protoc_insertion_point(field_mutable_list:radar.messages.TrackHistory.state_history)
  return &_impl_.state_history_;
}
inline const ::radar::messages::TrackState& TrackHistory::_internal_state_history(int index) const {
  return _impl_.state_history_.Get(index);
}
inline const ::radar::messages::TrackState& TrackHistory::state_history(int index) const {
  // @@protoc_insertion_point(field_get:radar.messages.TrackHistory.state_history)
  return _internal_state_history(index);
}
inline ::radar::messages::TrackState* TrackHistory::_internal_add_state_history() {
  return _impl_.state_history_.Add();
}
inline ::radar::messages::TrackState* TrackHistory::add_state_history() {
  ::radar::messages::TrackState* _add = _internal_add_state_history();
  // @@protoc_insertion_point(field_add:radar.messages.TrackHistory.state_history)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::radar::messages::TrackState >&
TrackHistory::state_history() const {
  // @@protoc_insertion_point(field_list:radar.messages.TrackHistory.state_history)
  return _impl_.state_history_;
}

// repeated .google.protobuf.Timestamp timestamps = 4;
inline int TrackHistory::_internal_timestamps_size() const {
  return _impl_.timestamps_.size();
}
inline int TrackHistory::timestamps_size() const {
  return _internal_timestamps_size();
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* TrackHistory::mutable_timestamps(int index) {
  // @@protoc_insertion_point(field_mutable:radar.messages.TrackHistory.timestamps)
  return _impl_.timestamps_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PROTOBUF_NAMESPACE_ID::Timestamp >*
TrackHistory::mutable_timestamps() {
  // @@protoc_insertion_point(field_mutable_list:radar.messages.TrackHistory.timestamps)
  return &_impl_.timestamps_;
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& TrackHistory::_internal_timestamps(int index) const {
  return _impl_.timestamps_.Get(index);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& TrackHistory::timestamps(int index) const {
  // @@protoc_insertion_point(field_get:radar.messages.TrackHistory.timestamps)
  return _internal_timestamps(index);
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* TrackHistory::_internal_add_timestamps() {
  return _impl_.timestamps_.Add();
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* TrackHistory::add_timestamps() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _add = _internal_add_timestamps();
  // @@protoc_insertion_point(field_add:radar.messages.TrackHistory.timestamps)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PROTOBUF_NAMESPACE_ID::Timestamp >&
TrackHistory::timestamps() const {
  // @@protoc_insertion_point(field_list:radar.messages.TrackHistory.timestamps)
  return _impl_.timestamps_;
}

// repeated .radar.messages.Detection associated_detections = 5;
inline int TrackHistory::_internal_associated_detections_size() const {
  return _impl_.associated_detections_.size();
}
inline int TrackHistory::associated_detections_size() const {
  return _internal_associated_detections_size();
}
inline ::radar::messages::Detection* TrackHistory::mutable_associated_detections(int index) {
  // @@protoc_insertion_point(field_mutable:radar.messages.TrackHistory.associated_detections)
  return _impl_.associated_detections_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::radar::messages::Detection >*
TrackHistory::mutable_associated_detections() {
  // @@protoc_insertion_point(field_mutable_list:radar.messages.TrackHistory.associated_detections)
  return &_impl_.associated_detections_;
}
inline const ::radar::messages::Detection& TrackHistory::_internal_associated_detections(int index) const {
  return _impl_.associated_detections_.Get(index);
}
inline const ::radar::messages::Detection& TrackHistory::associated_detections(int index) const {
  // @@protoc_insertion_point(field_get:radar.messages.TrackHistory.associated_detections)
  return _internal_associated_detections(index);
}
inline ::radar::messages::Detection* TrackHistory::_internal_add_associated_detections() {
  return _impl_.associated_detections_.Add();
}
inline ::radar::messages::Detection* TrackHistory::add_associated_detections() {
  ::radar::messages::Detection* _add = _internal_add_associated_detections();
  // @@protoc_insertion_point(field_add:radar.messages.TrackHistory.associated_detections)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::radar::messages::Detection >&
TrackHistory::associated_detections() const {
  // @@protoc_insertion_point(field_list:radar.messages.TrackHistory.associated_detections)
  return _impl_.associated_detections_;
}

// double average_speed = 6;
inline void TrackHistory::clear_average_speed() {
  _impl_.average_speed_ = 0;
}
inline double TrackHistory::_internal_average_speed() const {
  return _impl_.average_speed_;
}
inline double TrackHistory::average_speed() const {
  // @@protoc_insertion_point(field_get:radar.messages.TrackHistory.average_speed)
  return _internal_average_speed();
}
inline void TrackHistory::_internal_set_average_speed(double value) {
  
  _impl_.average_speed_ = value;
}
inline void TrackHistory::set_average_speed(double value) {
  _internal_set_average_speed(value);
  // @@protoc_insertion_point(field_set:radar.messages.TrackHistory.average_speed)
}

// double max_speed = 7;
inline void TrackHistory::clear_max_speed() {
  _impl_.max_speed_ = 0;
}
inline double TrackHistory::_internal_max_speed() const {
  return _impl_.max_speed_;
}
inline double TrackHistory::max_speed() const {
  // @@protoc_insertion_point(field_get:radar.messages.TrackHistory.max_speed)
  return _internal_max_speed();
}
inline void TrackHistory::_internal_set_max_speed(double value) {
  
  _impl_.max_speed_ = value;
}
inline void TrackHistory::set_max_speed(double value) {
  _internal_set_max_speed(value);
  // @@protoc_insertion_point(field_set:radar.messages.TrackHistory.max_speed)
}

// double total_distance = 8;
inline void TrackHistory::clear_total_distance() {
  _impl_.total_distance_ = 0;
}
inline double TrackHistory::_internal_total_distance() const {
  return _impl_.total_distance_;
}
inline double TrackHistory::total_distance() const {
  // @@protoc_insertion_point(field_get:radar.messages.TrackHistory.total_distance)
  return _internal_total_distance();
}
inline void TrackHistory::_internal_set_total_distance(double value) {
  
  _impl_.total_distance_ = value;
}
inline void TrackHistory::set_total_distance(double value) {
  _internal_set_total_distance(value);
  // @@protoc_insertion_point(field_set:radar.messages.TrackHistory.total_distance)
}

// double total_time_seconds = 9;
inline void TrackHistory::clear_total_time_seconds() {
  _impl_.total_time_seconds_ = 0;
}
inline double TrackHistory::_internal_total_time_seconds() const {
  return _impl_.total_time_seconds_;
}
inline double TrackHistory::total_time_seconds() const {
  // @@protoc_insertion_point(field_get:radar.messages.TrackHistory.total_time_seconds)
  return _internal_total_time_seconds();
}
inline void TrackHistory::_internal_set_total_time_seconds(double value) {
  
  _impl_.total_time_seconds_ = value;
}
inline void TrackHistory::set_total_time_seconds(double value) {
  _internal_set_total_time_seconds(value);
  // @@protoc_insertion_point(field_set:radar.messages.TrackHistory.total_time_seconds)
}

// repeated double confidence_history = 10;
inline int TrackHistory::_internal_confidence_history_size() const {
  return _impl_.confidence_history_.size();
}
inline int TrackHistory::confidence_history_size() const {
  return _internal_confidence_history_size();
}
inline void TrackHistory::clear_confidence_history() {
  _impl_.confidence_history_.Clear();
}
inline double TrackHistory::_internal_confidence_history(int index) const {
  return _impl_.confidence_history_.Get(index);
}
inline double TrackHistory::confidence_history(int index) const {
  // @@protoc_insertion_point(field_get:radar.messages.TrackHistory.confidence_history)
  return _internal_confidence_history(index);
}
inline void TrackHistory::set_confidence_history(int index, double value) {
  _impl_.confidence_history_.Set(index, value);
  // @@protoc_insertion_point(field_set:radar.messages.TrackHistory.confidence_history)
}
inline void TrackHistory::_internal_add_confidence_history(double value) {
  _impl_.confidence_history_.Add(value);
}
inline void TrackHistory::add_confidence_history(double value) {
  _internal_add_confidence_history(value);
  // @@protoc_insertion_point(field_add:radar.messages.TrackHistory.confidence_history)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
TrackHistory::_internal_confidence_history() const {
  return _impl_.confidence_history_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
TrackHistory::confidence_history() const {
  // @@protoc_insertion_point(field_list:radar.messages.TrackHistory.confidence_history)
  return _internal_confidence_history();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
TrackHistory::_internal_mutable_confidence_history() {
  return &_impl_.confidence_history_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
TrackHistory::mutable_confidence_history() {
  // @@protoc_insertion_point(field_mutable_list:radar.messages.TrackHistory.confidence_history)
  return _internal_mutable_confidence_history();
}

// repeated double likelihood_history = 11;
inline int TrackHistory::_internal_likelihood_history_size() const {
  return _impl_.likelihood_history_.size();
}
inline int TrackHistory::likelihood_history_size() const {
  return _internal_likelihood_history_size();
}
inline void TrackHistory::clear_likelihood_history() {
  _impl_.likelihood_history_.Clear();
}
inline double TrackHistory::_internal_likelihood_history(int index) const {
  return _impl_.likelihood_history_.Get(index);
}
inline double TrackHistory::likelihood_history(int index) const {
  // @@protoc_insertion_point(field_get:radar.messages.TrackHistory.likelihood_history)
  return _internal_likelihood_history(index);
}
inline void TrackHistory::set_likelihood_history(int index, double value) {
  _impl_.likelihood_history_.Set(index, value);
  // @@protoc_insertion_point(field_set:radar.messages.TrackHistory.likelihood_history)
}
inline void TrackHistory::_internal_add_likelihood_history(double value) {
  _impl_.likelihood_history_.Add(value);
}
inline void TrackHistory::add_likelihood_history(double value) {
  _internal_add_likelihood_history(value);
  // @@protoc_insertion_point(field_add:radar.messages.TrackHistory.likelihood_history)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
TrackHistory::_internal_likelihood_history() const {
  return _impl_.likelihood_history_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
TrackHistory::likelihood_history() const {
  // @@protoc_insertion_point(field_list:radar.messages.TrackHistory.likelihood_history)
  return _internal_likelihood_history();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
TrackHistory::_internal_mutable_likelihood_history() {
  return &_impl_.likelihood_history_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
TrackHistory::mutable_likelihood_history() {
  // @@protoc_insertion_point(field_mutable_list:radar.messages.TrackHistory.likelihood_history)
  return _internal_mutable_likelihood_history();
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// DetectionCluster

// uint32 id = 1;
inline void DetectionCluster::clear_id() {
  _impl_.id_ = 0u;
}
inline uint32_t DetectionCluster::_internal_id() const {
  return _impl_.id_;
}
inline uint32_t DetectionCluster::id() const {
  // @@protoc_insertion_point(field_get:radar.messages.DetectionCluster.id)
  return _internal_id();
}
inline void DetectionCluster::_internal_set_id(uint32_t value) {
  
  _impl_.id_ = value;
}
inline void DetectionCluster::set_id(uint32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:radar.messages.DetectionCluster.id)
}

// repeated .radar.messages.Detection detections = 2;
inline int DetectionCluster::_internal_detections_size() const {
  return _impl_.detections_.size();
}
inline int DetectionCluster::detections_size() const {
  return _internal_detections_size();
}
inline ::radar::messages::Detection* DetectionCluster::mutable_detections(int index) {
  // @@protoc_insertion_point(field_mutable:radar.messages.DetectionCluster.detections)
  return _impl_.detections_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::radar::messages::Detection >*
DetectionCluster::mutable_detections() {
  // @@protoc_insertion_point(field_mutable_list:radar.messages.DetectionCluster.detections)
  return &_impl_.detections_;
}
inline const ::radar::messages::Detection& DetectionCluster::_internal_detections(int index) const {
  return _impl_.detections_.Get(index);
}
inline const ::radar::messages::Detection& DetectionCluster::detections(int index) const {
  // @@protoc_insertion_point(field_get:radar.messages.DetectionCluster.detections)
  return _internal_detections(index);
}
inline ::radar::messages::Detection* DetectionCluster::_internal_add_detections() {
  return _impl_.detections_.Add();
}
inline ::radar::messages::Detection* DetectionCluster::add_detections() {
  ::radar::messages::Detection* _add = _internal_add_detections();
  // @@protoc_insertion_point(field_add:radar.messages.DetectionCluster.detections)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::radar::messages::Detection >&
DetectionCluster::detections() const {
  // @@protoc_insertion_point(field_list:radar.messages.DetectionCluster.detections)
  return _impl_.detections_;
}

// .radar.messages.Point3D centroid = 3;
inline bool DetectionCluster::_internal_has_centroid() const {
  return this != internal_default_instance() && _impl_.centroid_ != nullptr;
}
inline bool DetectionCluster::has_centroid() const {
  return _internal_has_centroid();
}
inline const ::radar::messages::Point3D& DetectionCluster::_internal_centroid() const {
  const ::radar::messages::Point3D* p = _impl_.centroid_;
  return p != nullptr ? *p : reinterpret_cast<const ::radar::messages::Point3D&>(
      ::radar::messages::_Point3D_default_instance_);
}
inline const ::radar::messages::Point3D& DetectionCluster::centroid() const {
  // @@protoc_insertion_point(field_get:radar.messages.DetectionCluster.centroid)
  return _internal_centroid();
}
inline void DetectionCluster::unsafe_arena_set_allocated_centroid(
    ::radar::messages::Point3D* centroid) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.centroid_);
  }
  _impl_.centroid_ = centroid;
  if (centroid) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:radar.messages.DetectionCluster.centroid)
}
inline ::radar::messages::Point3D* DetectionCluster::release_centroid() {
  
  ::radar::messages::Point3D* temp = _impl_.centroid_;
  _impl_.centroid_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::radar::messages::Point3D* DetectionCluster::unsafe_arena_release_centroid() {
  // @@protoc_insertion_point(field_release:radar.messages.DetectionCluster.centroid)
  
  ::radar::messages::Point3D* temp = _impl_.centroid_;
  _impl_.centroid_ = nullptr;
  return temp;
}
inline ::radar::messages::Point3D* DetectionCluster::_internal_mutable_centroid() {
  
  if (_impl_.centroid_ == nullptr) {
    auto* p = CreateMaybeMessage<::radar::messages::Point3D>(GetArenaForAllocation());
    _impl_.centroid_ = p;
  }
  return _impl_.centroid_;
}
inline ::radar::messages::Point3D* DetectionCluster::mutable_centroid() {
  ::radar::messages::Point3D* _msg = _internal_mutable_centroid();
  // @@protoc_insertion_point(field_mutable:radar.messages.DetectionCluster.centroid)
  return _msg;
}
inline void DetectionCluster::set_allocated_centroid(::radar::messages::Point3D* centroid) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.centroid_);
  }
  if (centroid) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(centroid));
    if (message_arena != submessage_arena) {
      centroid = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, centroid, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.centroid_ = centroid;
  // @@protoc_insertion_point(field_set_allocated:radar.messages.DetectionCluster.centroid)
}

// .radar.messages.Matrix3D covariance = 4;
inline bool DetectionCluster::_internal_has_covariance() const {
  return this != internal_default_instance() && _impl_.covariance_ != nullptr;
}
inline bool DetectionCluster::has_covariance() const {
  return _internal_has_covariance();
}
inline const ::radar::messages::Matrix3D& DetectionCluster::_internal_covariance() const {
  const ::radar::messages::Matrix3D* p = _impl_.covariance_;
  return p != nullptr ? *p : reinterpret_cast<const ::radar::messages::Matrix3D&>(
      ::radar::messages::_Matrix3D_default_instance_);
}
inline const ::radar::messages::Matrix3D& DetectionCluster::covariance() const {
  // @@protoc_insertion_point(field_get:radar.messages.DetectionCluster.covariance)
  return _internal_covariance();
}
inline void DetectionCluster::unsafe_arena_set_allocated_covariance(
    ::radar::messages::Matrix3D* covariance) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.covariance_);
  }
  _impl_.covariance_ = covariance;
  if (covariance) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:radar.messages.DetectionCluster.covariance)
}
inline ::radar::messages::Matrix3D* DetectionCluster::release_covariance() {
  
  ::radar::messages::Matrix3D* temp = _impl_.covariance_;
  _impl_.covariance_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::radar::messages::Matrix3D* DetectionCluster::unsafe_arena_release_covariance() {
  // @@protoc_insertion_point(field_release:radar.messages.DetectionCluster.covariance)
  
  ::radar::messages::Matrix3D* temp = _impl_.covariance_;
  _impl_.covariance_ = nullptr;
  return temp;
}
inline ::radar::messages::Matrix3D* DetectionCluster::_internal_mutable_covariance() {
  
  if (_impl_.covariance_ == nullptr) {
    auto* p = CreateMaybeMessage<::radar::messages::Matrix3D>(GetArenaForAllocation());
    _impl_.covariance_ = p;
  }
  return _impl_.covariance_;
}
inline ::radar::messages::Matrix3D* DetectionCluster::mutable_covariance() {
  ::radar::messages::Matrix3D* _msg = _internal_mutable_covariance();
  // @@protoc_insertion_point(field_mutable:radar.messages.DetectionCluster.covariance)
  return _msg;
}
inline void DetectionCluster::set_allocated_covariance(::radar::messages::Matrix3D* covariance) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.covariance_);
  }
  if (covariance) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(covariance));
    if (message_arena != submessage_arena) {
      covariance = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, covariance, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.covariance_ = covariance;
  // @@protoc_insertion_point(field_set_allocated:radar.messages.DetectionCluster.covariance)
}

// .google.protobuf.Timestamp timestamp = 5;
inline bool DetectionCluster::_internal_has_timestamp() const {
  return this != internal_default_instance() && _impl_.timestamp_ != nullptr;
}
inline bool DetectionCluster::has_timestamp() const {
  return _internal_has_timestamp();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& DetectionCluster::_internal_timestamp() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.timestamp_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& DetectionCluster::timestamp() const {
  // @@protoc_insertion_point(field_get:radar.messages.DetectionCluster.timestamp)
  return _internal_timestamp();
}
inline void DetectionCluster::unsafe_arena_set_allocated_timestamp(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.timestamp_);
  }
  _impl_.timestamp_ = timestamp;
  if (timestamp) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:radar.messages.DetectionCluster.timestamp)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* DetectionCluster::release_timestamp() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.timestamp_;
  _impl_.timestamp_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* DetectionCluster::unsafe_arena_release_timestamp() {
  // @@protoc_insertion_point(field_release:radar.messages.DetectionCluster.timestamp)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.timestamp_;
  _impl_.timestamp_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* DetectionCluster::_internal_mutable_timestamp() {
  
  if (_impl_.timestamp_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.timestamp_ = p;
  }
  return _impl_.timestamp_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* DetectionCluster::mutable_timestamp() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_timestamp();
  // @@protoc_insertion_point(field_mutable:radar.messages.DetectionCluster.timestamp)
  return _msg;
}
inline void DetectionCluster::set_allocated_timestamp(::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.timestamp_);
  }
  if (timestamp) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(timestamp));
    if (message_arena != submessage_arena) {
      timestamp = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, timestamp, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.timestamp_ = timestamp;
  // @@protoc_insertion_point(field_set_allocated:radar.messages.DetectionCluster.timestamp)
}

// .radar.messages.DetectionCluster.ClusteringAlgorithm algorithm = 6;
inline void DetectionCluster::clear_algorithm() {
  _impl_.algorithm_ = 0;
}
inline ::radar::messages::DetectionCluster_ClusteringAlgorithm DetectionCluster::_internal_algorithm() const {
  return static_cast< ::radar::messages::DetectionCluster_ClusteringAlgorithm >(_impl_.algorithm_);
}
inline ::radar::messages::DetectionCluster_ClusteringAlgorithm DetectionCluster::algorithm() const {
  // @@protoc_insertion_point(field_get:radar.messages.DetectionCluster.algorithm)
  return _internal_algorithm();
}
inline void DetectionCluster::_internal_set_algorithm(::radar::messages::DetectionCluster_ClusteringAlgorithm value) {
  
  _impl_.algorithm_ = value;
}
inline void DetectionCluster::set_algorithm(::radar::messages::DetectionCluster_ClusteringAlgorithm value) {
  _internal_set_algorithm(value);
  // @@protoc_insertion_point(field_set:radar.messages.DetectionCluster.algorithm)
}

// uint32 detection_count = 7;
inline void DetectionCluster::clear_detection_count() {
  _impl_.detection_count_ = 0u;
}
inline uint32_t DetectionCluster::_internal_detection_count() const {
  return _impl_.detection_count_;
}
inline uint32_t DetectionCluster::detection_count() const {
  // @@protoc_insertion_point(field_get:radar.messages.DetectionCluster.detection_count)
  return _internal_detection_count();
}
inline void DetectionCluster::_internal_set_detection_count(uint32_t value) {
  
  _impl_.detection_count_ = value;
}
inline void DetectionCluster::set_detection_count(uint32_t value) {
  _internal_set_detection_count(value);
  // @@protoc_insertion_point(field_set:radar.messages.DetectionCluster.detection_count)
}

// double cluster_radius = 8;
inline void DetectionCluster::clear_cluster_radius() {
  _impl_.cluster_radius_ = 0;
}
inline double DetectionCluster::_internal_cluster_radius() const {
  return _impl_.cluster_radius_;
}
inline double DetectionCluster::cluster_radius() const {
  // @@protoc_insertion_point(field_get:radar.messages.DetectionCluster.cluster_radius)
  return _internal_cluster_radius();
}
inline void DetectionCluster::_internal_set_cluster_radius(double value) {
  
  _impl_.cluster_radius_ = value;
}
inline void DetectionCluster::set_cluster_radius(double value) {
  _internal_set_cluster_radius(value);
  // @@protoc_insertion_point(field_set:radar.messages.DetectionCluster.cluster_radius)
}

// double cluster_density = 9;
inline void DetectionCluster::clear_cluster_density() {
  _impl_.cluster_density_ = 0;
}
inline double DetectionCluster::_internal_cluster_density() const {
  return _impl_.cluster_density_;
}
inline double DetectionCluster::cluster_density() const {
  // @@protoc_insertion_point(field_get:radar.messages.DetectionCluster.cluster_density)
  return _internal_cluster_density();
}
inline void DetectionCluster::_internal_set_cluster_density(double value) {
  
  _impl_.cluster_density_ = value;
}
inline void DetectionCluster::set_cluster_density(double value) {
  _internal_set_cluster_density(value);
  // @@protoc_insertion_point(field_set:radar.messages.DetectionCluster.cluster_density)
}

// double processing_time_ms = 10;
inline void DetectionCluster::clear_processing_time_ms() {
  _impl_.processing_time_ms_ = 0;
}
inline double DetectionCluster::_internal_processing_time_ms() const {
  return _impl_.processing_time_ms_;
}
inline double DetectionCluster::processing_time_ms() const {
  // @@protoc_insertion_point(field_get:radar.messages.DetectionCluster.processing_time_ms)
  return _internal_processing_time_ms();
}
inline void DetectionCluster::_internal_set_processing_time_ms(double value) {
  
  _impl_.processing_time_ms_ = value;
}
inline void DetectionCluster::set_processing_time_ms(double value) {
  _internal_set_processing_time_ms(value);
  // @@protoc_insertion_point(field_set:radar.messages.DetectionCluster.processing_time_ms)
}

// map<string, double> algorithm_parameters = 11;
inline int DetectionCluster::_internal_algorithm_parameters_size() const {
  return _impl_.algorithm_parameters_.size();
}
inline int DetectionCluster::algorithm_parameters_size() const {
  return _internal_algorithm_parameters_size();
}
inline void DetectionCluster::clear_algorithm_parameters() {
  _impl_.algorithm_parameters_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >&
DetectionCluster::_internal_algorithm_parameters() const {
  return _impl_.algorithm_parameters_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >&
DetectionCluster::algorithm_parameters() const {
  // @@protoc_insertion_point(field_map:radar.messages.DetectionCluster.algorithm_parameters)
  return _internal_algorithm_parameters();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >*
DetectionCluster::_internal_mutable_algorithm_parameters() {
  return _impl_.algorithm_parameters_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >*
DetectionCluster::mutable_algorithm_parameters() {
  // @@protoc_insertion_point(field_mutable_map:radar.messages.DetectionCluster.algorithm_parameters)
  return _internal_mutable_algorithm_parameters();
}

// -------------------------------------------------------------------

// Association

// uint32 track_id = 1;
inline void Association::clear_track_id() {
  _impl_.track_id_ = 0u;
}
inline uint32_t Association::_internal_track_id() const {
  return _impl_.track_id_;
}
inline uint32_t Association::track_id() const {
  // @@protoc_insertion_point(field_get:radar.messages.Association.track_id)
  return _internal_track_id();
}
inline void Association::_internal_set_track_id(uint32_t value) {
  
  _impl_.track_id_ = value;
}
inline void Association::set_track_id(uint32_t value) {
  _internal_set_track_id(value);
  // @@protoc_insertion_point(field_set:radar.messages.Association.track_id)
}

// uint32 detection_id = 2;
inline void Association::clear_detection_id() {
  _impl_.detection_id_ = 0u;
}
inline uint32_t Association::_internal_detection_id() const {
  return _impl_.detection_id_;
}
inline uint32_t Association::detection_id() const {
  // @@protoc_insertion_point(field_get:radar.messages.Association.detection_id)
  return _internal_detection_id();
}
inline void Association::_internal_set_detection_id(uint32_t value) {
  
  _impl_.detection_id_ = value;
}
inline void Association::set_detection_id(uint32_t value) {
  _internal_set_detection_id(value);
  // @@protoc_insertion_point(field_set:radar.messages.Association.detection_id)
}

// double score = 3;
inline void Association::clear_score() {
  _impl_.score_ = 0;
}
inline double Association::_internal_score() const {
  return _impl_.score_;
}
inline double Association::score() const {
  // @@protoc_insertion_point(field_get:radar.messages.Association.score)
  return _internal_score();
}
inline void Association::_internal_set_score(double value) {
  
  _impl_.score_ = value;
}
inline void Association::set_score(double value) {
  _internal_set_score(value);
  // @@protoc_insertion_point(field_set:radar.messages.Association.score)
}

// double distance = 4;
inline void Association::clear_distance() {
  _impl_.distance_ = 0;
}
inline double Association::_internal_distance() const {
  return _impl_.distance_;
}
inline double Association::distance() const {
  // @@protoc_insertion_point(field_get:radar.messages.Association.distance)
  return _internal_distance();
}
inline void Association::_internal_set_distance(double value) {
  
  _impl_.distance_ = value;
}
inline void Association::set_distance(double value) {
  _internal_set_distance(value);
  // @@protoc_insertion_point(field_set:radar.messages.Association.distance)
}

// bool is_valid = 5;
inline void Association::clear_is_valid() {
  _impl_.is_valid_ = false;
}
inline bool Association::_internal_is_valid() const {
  return _impl_.is_valid_;
}
inline bool Association::is_valid() const {
  // @@protoc_insertion_point(field_get:radar.messages.Association.is_valid)
  return _internal_is_valid();
}
inline void Association::_internal_set_is_valid(bool value) {
  
  _impl_.is_valid_ = value;
}
inline void Association::set_is_valid(bool value) {
  _internal_set_is_valid(value);
  // @@protoc_insertion_point(field_set:radar.messages.Association.is_valid)
}

// .radar.messages.Vector3D innovation = 6;
inline bool Association::_internal_has_innovation() const {
  return this != internal_default_instance() && _impl_.innovation_ != nullptr;
}
inline bool Association::has_innovation() const {
  return _internal_has_innovation();
}
inline const ::radar::messages::Vector3D& Association::_internal_innovation() const {
  const ::radar::messages::Vector3D* p = _impl_.innovation_;
  return p != nullptr ? *p : reinterpret_cast<const ::radar::messages::Vector3D&>(
      ::radar::messages::_Vector3D_default_instance_);
}
inline const ::radar::messages::Vector3D& Association::innovation() const {
  // @@protoc_insertion_point(field_get:radar.messages.Association.innovation)
  return _internal_innovation();
}
inline void Association::unsafe_arena_set_allocated_innovation(
    ::radar::messages::Vector3D* innovation) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.innovation_);
  }
  _impl_.innovation_ = innovation;
  if (innovation) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:radar.messages.Association.innovation)
}
inline ::radar::messages::Vector3D* Association::release_innovation() {
  
  ::radar::messages::Vector3D* temp = _impl_.innovation_;
  _impl_.innovation_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::radar::messages::Vector3D* Association::unsafe_arena_release_innovation() {
  // @@protoc_insertion_point(field_release:radar.messages.Association.innovation)
  
  ::radar::messages::Vector3D* temp = _impl_.innovation_;
  _impl_.innovation_ = nullptr;
  return temp;
}
inline ::radar::messages::Vector3D* Association::_internal_mutable_innovation() {
  
  if (_impl_.innovation_ == nullptr) {
    auto* p = CreateMaybeMessage<::radar::messages::Vector3D>(GetArenaForAllocation());
    _impl_.innovation_ = p;
  }
  return _impl_.innovation_;
}
inline ::radar::messages::Vector3D* Association::mutable_innovation() {
  ::radar::messages::Vector3D* _msg = _internal_mutable_innovation();
  // @@protoc_insertion_point(field_mutable:radar.messages.Association.innovation)
  return _msg;
}
inline void Association::set_allocated_innovation(::radar::messages::Vector3D* innovation) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.innovation_);
  }
  if (innovation) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(innovation));
    if (message_arena != submessage_arena) {
      innovation = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, innovation, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.innovation_ = innovation;
  // @@protoc_insertion_point(field_set_allocated:radar.messages.Association.innovation)
}

// .radar.messages.Matrix3D innovation_covariance = 7;
inline bool Association::_internal_has_innovation_covariance() const {
  return this != internal_default_instance() && _impl_.innovation_covariance_ != nullptr;
}
inline bool Association::has_innovation_covariance() const {
  return _internal_has_innovation_covariance();
}
inline const ::radar::messages::Matrix3D& Association::_internal_innovation_covariance() const {
  const ::radar::messages::Matrix3D* p = _impl_.innovation_covariance_;
  return p != nullptr ? *p : reinterpret_cast<const ::radar::messages::Matrix3D&>(
      ::radar::messages::_Matrix3D_default_instance_);
}
inline const ::radar::messages::Matrix3D& Association::innovation_covariance() const {
  // @@protoc_insertion_point(field_get:radar.messages.Association.innovation_covariance)
  return _internal_innovation_covariance();
}
inline void Association::unsafe_arena_set_allocated_innovation_covariance(
    ::radar::messages::Matrix3D* innovation_covariance) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.innovation_covariance_);
  }
  _impl_.innovation_covariance_ = innovation_covariance;
  if (innovation_covariance) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:radar.messages.Association.innovation_covariance)
}
inline ::radar::messages::Matrix3D* Association::release_innovation_covariance() {
  
  ::radar::messages::Matrix3D* temp = _impl_.innovation_covariance_;
  _impl_.innovation_covariance_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::radar::messages::Matrix3D* Association::unsafe_arena_release_innovation_covariance() {
  // @@protoc_insertion_point(field_release:radar.messages.Association.innovation_covariance)
  
  ::radar::messages::Matrix3D* temp = _impl_.innovation_covariance_;
  _impl_.innovation_covariance_ = nullptr;
  return temp;
}
inline ::radar::messages::Matrix3D* Association::_internal_mutable_innovation_covariance() {
  
  if (_impl_.innovation_covariance_ == nullptr) {
    auto* p = CreateMaybeMessage<::radar::messages::Matrix3D>(GetArenaForAllocation());
    _impl_.innovation_covariance_ = p;
  }
  return _impl_.innovation_covariance_;
}
inline ::radar::messages::Matrix3D* Association::mutable_innovation_covariance() {
  ::radar::messages::Matrix3D* _msg = _internal_mutable_innovation_covariance();
  // @@protoc_insertion_point(field_mutable:radar.messages.Association.innovation_covariance)
  return _msg;
}
inline void Association::set_allocated_innovation_covariance(::radar::messages::Matrix3D* innovation_covariance) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.innovation_covariance_);
  }
  if (innovation_covariance) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(innovation_covariance));
    if (message_arena != submessage_arena) {
      innovation_covariance = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, innovation_covariance, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.innovation_covariance_ = innovation_covariance;
  // @@protoc_insertion_point(field_set_allocated:radar.messages.Association.innovation_covariance)
}

// double likelihood = 8;
inline void Association::clear_likelihood() {
  _impl_.likelihood_ = 0;
}
inline double Association::_internal_likelihood() const {
  return _impl_.likelihood_;
}
inline double Association::likelihood() const {
  // @@protoc_insertion_point(field_get:radar.messages.Association.likelihood)
  return _internal_likelihood();
}
inline void Association::_internal_set_likelihood(double value) {
  
  _impl_.likelihood_ = value;
}
inline void Association::set_likelihood(double value) {
  _internal_set_likelihood(value);
  // @@protoc_insertion_point(field_set:radar.messages.Association.likelihood)
}

// .radar.messages.Association.AssociationAlgorithm algorithm = 9;
inline void Association::clear_algorithm() {
  _impl_.algorithm_ = 0;
}
inline ::radar::messages::Association_AssociationAlgorithm Association::_internal_algorithm() const {
  return static_cast< ::radar::messages::Association_AssociationAlgorithm >(_impl_.algorithm_);
}
inline ::radar::messages::Association_AssociationAlgorithm Association::algorithm() const {
  // @@protoc_insertion_point(field_get:radar.messages.Association.algorithm)
  return _internal_algorithm();
}
inline void Association::_internal_set_algorithm(::radar::messages::Association_AssociationAlgorithm value) {
  
  _impl_.algorithm_ = value;
}
inline void Association::set_algorithm(::radar::messages::Association_AssociationAlgorithm value) {
  _internal_set_algorithm(value);
  // @@protoc_insertion_point(field_set:radar.messages.Association.algorithm)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// FusionData

// .google.protobuf.Timestamp timestamp = 1;
inline bool FusionData::_internal_has_timestamp() const {
  return this != internal_default_instance() && _impl_.timestamp_ != nullptr;
}
inline bool FusionData::has_timestamp() const {
  return _internal_has_timestamp();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& FusionData::_internal_timestamp() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.timestamp_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& FusionData::timestamp() const {
  // @@protoc_insertion_point(field_get:radar.messages.FusionData.timestamp)
  return _internal_timestamp();
}
inline void FusionData::unsafe_arena_set_allocated_timestamp(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.timestamp_);
  }
  _impl_.timestamp_ = timestamp;
  if (timestamp) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:radar.messages.FusionData.timestamp)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* FusionData::release_timestamp() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.timestamp_;
  _impl_.timestamp_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* FusionData::unsafe_arena_release_timestamp() {
  // @@protoc_insertion_point(field_release:radar.messages.FusionData.timestamp)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.timestamp_;
  _impl_.timestamp_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* FusionData::_internal_mutable_timestamp() {
  
  if (_impl_.timestamp_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.timestamp_ = p;
  }
  return _impl_.timestamp_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* FusionData::mutable_timestamp() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_timestamp();
  // @@protoc_insertion_point(field_mutable:radar.messages.FusionData.timestamp)
  return _msg;
}
inline void FusionData::set_allocated_timestamp(::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.timestamp_);
  }
  if (timestamp) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(timestamp));
    if (message_arena != submessage_arena) {
      timestamp = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, timestamp, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.timestamp_ = timestamp;
  // @@protoc_insertion_point(field_set_allocated:radar.messages.FusionData.timestamp)
}

// uint32 fusion_id = 2;
inline void FusionData::clear_fusion_id() {
  _impl_.fusion_id_ = 0u;
}
inline uint32_t FusionData::_internal_fusion_id() const {
  return _impl_.fusion_id_;
}
inline uint32_t FusionData::fusion_id() const {
  // @@protoc_insertion_point(field_get:radar.messages.FusionData.fusion_id)
  return _internal_fusion_id();
}
inline void FusionData::_internal_set_fusion_id(uint32_t value) {
  
  _impl_.fusion_id_ = value;
}
inline void FusionData::set_fusion_id(uint32_t value) {
  _internal_set_fusion_id(value);
  // @@protoc_insertion_point(field_set:radar.messages.FusionData.fusion_id)
}

// repeated .radar.messages.Track fused_tracks = 3;
inline int FusionData::_internal_fused_tracks_size() const {
  return _impl_.fused_tracks_.size();
}
inline int FusionData::fused_tracks_size() const {
  return _internal_fused_tracks_size();
}
inline void FusionData::clear_fused_tracks() {
  _impl_.fused_tracks_.Clear();
}
inline ::radar::messages::Track* FusionData::mutable_fused_tracks(int index) {
  // @@protoc_insertion_point(field_mutable:radar.messages.FusionData.fused_tracks)
  return _impl_.fused_tracks_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::radar::messages::Track >*
FusionData::mutable_fused_tracks() {
  // @@protoc_insertion_point(field_mutable_list:radar.messages.FusionData.fused_tracks)
  return &_impl_.fused_tracks_;
}
inline const ::radar::messages::Track& FusionData::_internal_fused_tracks(int index) const {
  return _impl_.fused_tracks_.Get(index);
}
inline const ::radar::messages::Track& FusionData::fused_tracks(int index) const {
  // @@protoc_insertion_point(field_get:radar.messages.FusionData.fused_tracks)
  return _internal_fused_tracks(index);
}
inline ::radar::messages::Track* FusionData::_internal_add_fused_tracks() {
  return _impl_.fused_tracks_.Add();
}
inline ::radar::messages::Track* FusionData::add_fused_tracks() {
  ::radar::messages::Track* _add = _internal_add_fused_tracks();
  // @@protoc_insertion_point(field_add:radar.messages.FusionData.fused_tracks)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::radar::messages::Track >&
FusionData::fused_tracks() const {
  // @@protoc_insertion_point(field_list:radar.messages.FusionData.fused_tracks)
  return _impl_.fused_tracks_;
}

// repeated uint32 contributing_sensors = 4;
inline int FusionData::_internal_contributing_sensors_size() const {
  return _impl_.contributing_sensors_.size();
}
inline int FusionData::contributing_sensors_size() const {
  return _internal_contributing_sensors_size();
}
inline void FusionData::clear_contributing_sensors() {
  _impl_.contributing_sensors_.Clear();
}
inline uint32_t FusionData::_internal_contributing_sensors(int index) const {
  return _impl_.contributing_sensors_.Get(index);
}
inline uint32_t FusionData::contributing_sensors(int index) const {
  // @@protoc_insertion_point(field_get:radar.messages.FusionData.contributing_sensors)
  return _internal_contributing_sensors(index);
}
inline void FusionData::set_contributing_sensors(int index, uint32_t value) {
  _impl_.contributing_sensors_.Set(index, value);
  // @@protoc_insertion_point(field_set:radar.messages.FusionData.contributing_sensors)
}
inline void FusionData::_internal_add_contributing_sensors(uint32_t value) {
  _impl_.contributing_sensors_.Add(value);
}
inline void FusionData::add_contributing_sensors(uint32_t value) {
  _internal_add_contributing_sensors(value);
  // @@protoc_insertion_point(field_add:radar.messages.FusionData.contributing_sensors)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
FusionData::_internal_contributing_sensors() const {
  return _impl_.contributing_sensors_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
FusionData::contributing_sensors() const {
  // @@protoc_insertion_point(field_list:radar.messages.FusionData.contributing_sensors)
  return _internal_contributing_sensors();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
FusionData::_internal_mutable_contributing_sensors() {
  return &_impl_.contributing_sensors_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
FusionData::mutable_contributing_sensors() {
  // @@protoc_insertion_point(field_mutable_list:radar.messages.FusionData.contributing_sensors)
  return _internal_mutable_contributing_sensors();
}

// map<uint32, double> sensor_weights = 5;
inline int FusionData::_internal_sensor_weights_size() const {
  return _impl_.sensor_weights_.size();
}
inline int FusionData::sensor_weights_size() const {
  return _internal_sensor_weights_size();
}
inline void FusionData::clear_sensor_weights() {
  _impl_.sensor_weights_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< uint32_t, double >&
FusionData::_internal_sensor_weights() const {
  return _impl_.sensor_weights_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< uint32_t, double >&
FusionData::sensor_weights() const {
  // @@protoc_insertion_point(field_map:radar.messages.FusionData.sensor_weights)
  return _internal_sensor_weights();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< uint32_t, double >*
FusionData::_internal_mutable_sensor_weights() {
  return _impl_.sensor_weights_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< uint32_t, double >*
FusionData::mutable_sensor_weights() {
  // @@protoc_insertion_point(field_mutable_map:radar.messages.FusionData.sensor_weights)
  return _internal_mutable_sensor_weights();
}

// double fusion_quality = 6;
inline void FusionData::clear_fusion_quality() {
  _impl_.fusion_quality_ = 0;
}
inline double FusionData::_internal_fusion_quality() const {
  return _impl_.fusion_quality_;
}
inline double FusionData::fusion_quality() const {
  // @@protoc_insertion_point(field_get:radar.messages.FusionData.fusion_quality)
  return _internal_fusion_quality();
}
inline void FusionData::_internal_set_fusion_quality(double value) {
  
  _impl_.fusion_quality_ = value;
}
inline void FusionData::set_fusion_quality(double value) {
  _internal_set_fusion_quality(value);
  // @@protoc_insertion_point(field_set:radar.messages.FusionData.fusion_quality)
}

// double cross_correlation = 7;
inline void FusionData::clear_cross_correlation() {
  _impl_.cross_correlation_ = 0;
}
inline double FusionData::_internal_cross_correlation() const {
  return _impl_.cross_correlation_;
}
inline double FusionData::cross_correlation() const {
  // @@protoc_insertion_point(field_get:radar.messages.FusionData.cross_correlation)
  return _internal_cross_correlation();
}
inline void FusionData::_internal_set_cross_correlation(double value) {
  
  _impl_.cross_correlation_ = value;
}
inline void FusionData::set_cross_correlation(double value) {
  _internal_set_cross_correlation(value);
  // @@protoc_insertion_point(field_set:radar.messages.FusionData.cross_correlation)
}

// uint32 redundant_tracks = 8;
inline void FusionData::clear_redundant_tracks() {
  _impl_.redundant_tracks_ = 0u;
}
inline uint32_t FusionData::_internal_redundant_tracks() const {
  return _impl_.redundant_tracks_;
}
inline uint32_t FusionData::redundant_tracks() const {
  // @@protoc_insertion_point(field_get:radar.messages.FusionData.redundant_tracks)
  return _internal_redundant_tracks();
}
inline void FusionData::_internal_set_redundant_tracks(uint32_t value) {
  
  _impl_.redundant_tracks_ = value;
}
inline void FusionData::set_redundant_tracks(uint32_t value) {
  _internal_set_redundant_tracks(value);
  // @@protoc_insertion_point(field_set:radar.messages.FusionData.redundant_tracks)
}

// uint32 unique_tracks = 9;
inline void FusionData::clear_unique_tracks() {
  _impl_.unique_tracks_ = 0u;
}
inline uint32_t FusionData::_internal_unique_tracks() const {
  return _impl_.unique_tracks_;
}
inline uint32_t FusionData::unique_tracks() const {
  // @@protoc_insertion_point(field_get:radar.messages.FusionData.unique_tracks)
  return _internal_unique_tracks();
}
inline void FusionData::_internal_set_unique_tracks(uint32_t value) {
  
  _impl_.unique_tracks_ = value;
}
inline void FusionData::set_unique_tracks(uint32_t value) {
  _internal_set_unique_tracks(value);
  // @@protoc_insertion_point(field_set:radar.messages.FusionData.unique_tracks)
}

// double position_uncertainty = 10;
inline void FusionData::clear_position_uncertainty() {
  _impl_.position_uncertainty_ = 0;
}
inline double FusionData::_internal_position_uncertainty() const {
  return _impl_.position_uncertainty_;
}
inline double FusionData::position_uncertainty() const {
  // @@protoc_insertion_point(field_get:radar.messages.FusionData.position_uncertainty)
  return _internal_position_uncertainty();
}
inline void FusionData::_internal_set_position_uncertainty(double value) {
  
  _impl_.position_uncertainty_ = value;
}
inline void FusionData::set_position_uncertainty(double value) {
  _internal_set_position_uncertainty(value);
  // @@protoc_insertion_point(field_set:radar.messages.FusionData.position_uncertainty)
}

// double velocity_uncertainty = 11;
inline void FusionData::clear_velocity_uncertainty() {
  _impl_.velocity_uncertainty_ = 0;
}
inline double FusionData::_internal_velocity_uncertainty() const {
  return _impl_.velocity_uncertainty_;
}
inline double FusionData::velocity_uncertainty() const {
  // @@protoc_insertion_point(field_get:radar.messages.FusionData.velocity_uncertainty)
  return _internal_velocity_uncertainty();
}
inline void FusionData::_internal_set_velocity_uncertainty(double value) {
  
  _impl_.velocity_uncertainty_ = value;
}
inline void FusionData::set_velocity_uncertainty(double value) {
  _internal_set_velocity_uncertainty(value);
  // @@protoc_insertion_point(field_set:radar.messages.FusionData.velocity_uncertainty)
}

// double fusion_time_ms = 12;
inline void FusionData::clear_fusion_time_ms() {
  _impl_.fusion_time_ms_ = 0;
}
inline double FusionData::_internal_fusion_time_ms() const {
  return _impl_.fusion_time_ms_;
}
inline double FusionData::fusion_time_ms() const {
  // @@protoc_insertion_point(field_get:radar.messages.FusionData.fusion_time_ms)
  return _internal_fusion_time_ms();
}
inline void FusionData::_internal_set_fusion_time_ms(double value) {
  
  _impl_.fusion_time_ms_ = value;
}
inline void FusionData::set_fusion_time_ms(double value) {
  _internal_set_fusion_time_ms(value);
  // @@protoc_insertion_point(field_set:radar.messages.FusionData.fusion_time_ms)
}

// string fusion_algorithm = 13;
inline void FusionData::clear_fusion_algorithm() {
  _impl_.fusion_algorithm_.ClearToEmpty();
}
inline const std::string& FusionData::fusion_algorithm() const {
  // @@protoc_insertion_point(field_get:radar.messages.FusionData.fusion_algorithm)
  return _internal_fusion_algorithm();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FusionData::set_fusion_algorithm(ArgT0&& arg0, ArgT... args) {
 
 _impl_.fusion_algorithm_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:radar.messages.FusionData.fusion_algorithm)
}
inline std::string* FusionData::mutable_fusion_algorithm() {
  std::string* _s = _internal_mutable_fusion_algorithm();
  // @@protoc_insertion_point(field_mutable:radar.messages.FusionData.fusion_algorithm)
  return _s;
}
inline const std::string& FusionData::_internal_fusion_algorithm() const {
  return _impl_.fusion_algorithm_.Get();
}
inline void FusionData::_internal_set_fusion_algorithm(const std::string& value) {
  
  _impl_.fusion_algorithm_.Set(value, GetArenaForAllocation());
}
inline std::string* FusionData::_internal_mutable_fusion_algorithm() {
  
  return _impl_.fusion_algorithm_.Mutable(GetArenaForAllocation());
}
inline std::string* FusionData::release_fusion_algorithm() {
  // @@protoc_insertion_point(field_release:radar.messages.FusionData.fusion_algorithm)
  return _impl_.fusion_algorithm_.Release();
}
inline void FusionData::set_allocated_fusion_algorithm(std::string* fusion_algorithm) {
  if (fusion_algorithm != nullptr) {
    
  } else {
    
  }
  _impl_.fusion_algorithm_.SetAllocated(fusion_algorithm, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.fusion_algorithm_.IsDefault()) {
    _impl_.fusion_algorithm_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:radar.messages.FusionData.fusion_algorithm)
}

// -------------------------------------------------------------------

// ThreatAssessment

// uint32 track_id = 1;
inline void ThreatAssessment::clear_track_id() {
  _impl_.track_id_ = 0u;
}
inline uint32_t ThreatAssessment::_internal_track_id() const {
  return _impl_.track_id_;
}
inline uint32_t ThreatAssessment::track_id() const {
  // @@protoc_insertion_point(field_get:radar.messages.ThreatAssessment.track_id)
  return _internal_track_id();
}
inline void ThreatAssessment::_internal_set_track_id(uint32_t value) {
  
  _impl_.track_id_ = value;
}
inline void ThreatAssessment::set_track_id(uint32_t value) {
  _internal_set_track_id(value);
  // @@protoc_insertion_point(field_set:radar.messages.ThreatAssessment.track_id)
}

// .google.protobuf.Timestamp timestamp = 2;
inline bool ThreatAssessment::_internal_has_timestamp() const {
  return this != internal_default_instance() && _impl_.timestamp_ != nullptr;
}
inline bool ThreatAssessment::has_timestamp() const {
  return _internal_has_timestamp();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& ThreatAssessment::_internal_timestamp() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.timestamp_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& ThreatAssessment::timestamp() const {
  // @@protoc_insertion_point(field_get:radar.messages.ThreatAssessment.timestamp)
  return _internal_timestamp();
}
inline void ThreatAssessment::unsafe_arena_set_allocated_timestamp(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.timestamp_);
  }
  _impl_.timestamp_ = timestamp;
  if (timestamp) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:radar.messages.ThreatAssessment.timestamp)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* ThreatAssessment::release_timestamp() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.timestamp_;
  _impl_.timestamp_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* ThreatAssessment::unsafe_arena_release_timestamp() {
  // @@protoc_insertion_point(field_release:radar.messages.ThreatAssessment.timestamp)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.timestamp_;
  _impl_.timestamp_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* ThreatAssessment::_internal_mutable_timestamp() {
  
  if (_impl_.timestamp_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.timestamp_ = p;
  }
  return _impl_.timestamp_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* ThreatAssessment::mutable_timestamp() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_timestamp();
  // @@protoc_insertion_point(field_mutable:radar.messages.ThreatAssessment.timestamp)
  return _msg;
}
inline void ThreatAssessment::set_allocated_timestamp(::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.timestamp_);
  }
  if (timestamp) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(timestamp));
    if (message_arena != submessage_arena) {
      timestamp = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, timestamp, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.timestamp_ = timestamp;
  // @@protoc_insertion_point(field_set_allocated:radar.messages.ThreatAssessment.timestamp)
}

// .radar.messages.ThreatAssessment.ThreatLevel threat_level = 3;
inline void ThreatAssessment::clear_threat_level() {
  _impl_.threat_level_ = 0;
}
inline ::radar::messages::ThreatAssessment_ThreatLevel ThreatAssessment::_internal_threat_level() const {
  return static_cast< ::radar::messages::ThreatAssessment_ThreatLevel >(_impl_.threat_level_);
}
inline ::radar::messages::ThreatAssessment_ThreatLevel ThreatAssessment::threat_level() const {
  // @@protoc_insertion_point(field_get:radar.messages.ThreatAssessment.threat_level)
  return _internal_threat_level();
}
inline void ThreatAssessment::_internal_set_threat_level(::radar::messages::ThreatAssessment_ThreatLevel value) {
  
  _impl_.threat_level_ = value;
}
inline void ThreatAssessment::set_threat_level(::radar::messages::ThreatAssessment_ThreatLevel value) {
  _internal_set_threat_level(value);
  // @@protoc_insertion_point(field_set:radar.messages.ThreatAssessment.threat_level)
}

// double threat_score = 4;
inline void ThreatAssessment::clear_threat_score() {
  _impl_.threat_score_ = 0;
}
inline double ThreatAssessment::_internal_threat_score() const {
  return _impl_.threat_score_;
}
inline double ThreatAssessment::threat_score() const {
  // @@protoc_insertion_point(field_get:radar.messages.ThreatAssessment.threat_score)
  return _internal_threat_score();
}
inline void ThreatAssessment::_internal_set_threat_score(double value) {
  
  _impl_.threat_score_ = value;
}
inline void ThreatAssessment::set_threat_score(double value) {
  _internal_set_threat_score(value);
  // @@protoc_insertion_point(field_set:radar.messages.ThreatAssessment.threat_score)
}

// double proximity_factor = 5;
inline void ThreatAssessment::clear_proximity_factor() {
  _impl_.proximity_factor_ = 0;
}
inline double ThreatAssessment::_internal_proximity_factor() const {
  return _impl_.proximity_factor_;
}
inline double ThreatAssessment::proximity_factor() const {
  // @@protoc_insertion_point(field_get:radar.messages.ThreatAssessment.proximity_factor)
  return _internal_proximity_factor();
}
inline void ThreatAssessment::_internal_set_proximity_factor(double value) {
  
  _impl_.proximity_factor_ = value;
}
inline void ThreatAssessment::set_proximity_factor(double value) {
  _internal_set_proximity_factor(value);
  // @@protoc_insertion_point(field_set:radar.messages.ThreatAssessment.proximity_factor)
}

// double velocity_factor = 6;
inline void ThreatAssessment::clear_velocity_factor() {
  _impl_.velocity_factor_ = 0;
}
inline double ThreatAssessment::_internal_velocity_factor() const {
  return _impl_.velocity_factor_;
}
inline double ThreatAssessment::velocity_factor() const {
  // @@protoc_insertion_point(field_get:radar.messages.ThreatAssessment.velocity_factor)
  return _internal_velocity_factor();
}
inline void ThreatAssessment::_internal_set_velocity_factor(double value) {
  
  _impl_.velocity_factor_ = value;
}
inline void ThreatAssessment::set_velocity_factor(double value) {
  _internal_set_velocity_factor(value);
  // @@protoc_insertion_point(field_set:radar.messages.ThreatAssessment.velocity_factor)
}

// double trajectory_factor = 7;
inline void ThreatAssessment::clear_trajectory_factor() {
  _impl_.trajectory_factor_ = 0;
}
inline double ThreatAssessment::_internal_trajectory_factor() const {
  return _impl_.trajectory_factor_;
}
inline double ThreatAssessment::trajectory_factor() const {
  // @@protoc_insertion_point(field_get:radar.messages.ThreatAssessment.trajectory_factor)
  return _internal_trajectory_factor();
}
inline void ThreatAssessment::_internal_set_trajectory_factor(double value) {
  
  _impl_.trajectory_factor_ = value;
}
inline void ThreatAssessment::set_trajectory_factor(double value) {
  _internal_set_trajectory_factor(value);
  // @@protoc_insertion_point(field_set:radar.messages.ThreatAssessment.trajectory_factor)
}

// double classification_factor = 8;
inline void ThreatAssessment::clear_classification_factor() {
  _impl_.classification_factor_ = 0;
}
inline double ThreatAssessment::_internal_classification_factor() const {
  return _impl_.classification_factor_;
}
inline double ThreatAssessment::classification_factor() const {
  // @@protoc_insertion_point(field_get:radar.messages.ThreatAssessment.classification_factor)
  return _internal_classification_factor();
}
inline void ThreatAssessment::_internal_set_classification_factor(double value) {
  
  _impl_.classification_factor_ = value;
}
inline void ThreatAssessment::set_classification_factor(double value) {
  _internal_set_classification_factor(value);
  // @@protoc_insertion_point(field_set:radar.messages.ThreatAssessment.classification_factor)
}

// .radar.messages.Point3D predicted_intercept = 9;
inline bool ThreatAssessment::_internal_has_predicted_intercept() const {
  return this != internal_default_instance() && _impl_.predicted_intercept_ != nullptr;
}
inline bool ThreatAssessment::has_predicted_intercept() const {
  return _internal_has_predicted_intercept();
}
inline const ::radar::messages::Point3D& ThreatAssessment::_internal_predicted_intercept() const {
  const ::radar::messages::Point3D* p = _impl_.predicted_intercept_;
  return p != nullptr ? *p : reinterpret_cast<const ::radar::messages::Point3D&>(
      ::radar::messages::_Point3D_default_instance_);
}
inline const ::radar::messages::Point3D& ThreatAssessment::predicted_intercept() const {
  // @@protoc_insertion_point(field_get:radar.messages.ThreatAssessment.predicted_intercept)
  return _internal_predicted_intercept();
}
inline void ThreatAssessment::unsafe_arena_set_allocated_predicted_intercept(
    ::radar::messages::Point3D* predicted_intercept) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.predicted_intercept_);
  }
  _impl_.predicted_intercept_ = predicted_intercept;
  if (predicted_intercept) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:radar.messages.ThreatAssessment.predicted_intercept)
}
inline ::radar::messages::Point3D* ThreatAssessment::release_predicted_intercept() {
  
  ::radar::messages::Point3D* temp = _impl_.predicted_intercept_;
  _impl_.predicted_intercept_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::radar::messages::Point3D* ThreatAssessment::unsafe_arena_release_predicted_intercept() {
  // @@protoc_insertion_point(field_release:radar.messages.ThreatAssessment.predicted_intercept)
  
  ::radar::messages::Point3D* temp = _impl_.predicted_intercept_;
  _impl_.predicted_intercept_ = nullptr;
  return temp;
}
inline ::radar::messages::Point3D* ThreatAssessment::_internal_mutable_predicted_intercept() {
  
  if (_impl_.predicted_intercept_ == nullptr) {
    auto* p = CreateMaybeMessage<::radar::messages::Point3D>(GetArenaForAllocation());
    _impl_.predicted_intercept_ = p;
  }
  return _impl_.predicted_intercept_;
}
inline ::radar::messages::Point3D* ThreatAssessment::mutable_predicted_intercept() {
  ::radar::messages::Point3D* _msg = _internal_mutable_predicted_intercept();
  // @@protoc_insertion_point(field_mutable:radar.messages.ThreatAssessment.predicted_intercept)
  return _msg;
}
inline void ThreatAssessment::set_allocated_predicted_intercept(::radar::messages::Point3D* predicted_intercept) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.predicted_intercept_);
  }
  if (predicted_intercept) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(predicted_intercept));
    if (message_arena != submessage_arena) {
      predicted_intercept = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, predicted_intercept, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.predicted_intercept_ = predicted_intercept;
  // @@protoc_insertion_point(field_set_allocated:radar.messages.ThreatAssessment.predicted_intercept)
}

// double time_to_intercept_seconds = 10;
inline void ThreatAssessment::clear_time_to_intercept_seconds() {
  _impl_.time_to_intercept_seconds_ = 0;
}
inline double ThreatAssessment::_internal_time_to_intercept_seconds() const {
  return _impl_.time_to_intercept_seconds_;
}
inline double ThreatAssessment::time_to_intercept_seconds() const {
  // @@protoc_insertion_point(field_get:radar.messages.ThreatAssessment.time_to_intercept_seconds)
  return _internal_time_to_intercept_seconds();
}
inline void ThreatAssessment::_internal_set_time_to_intercept_seconds(double value) {
  
  _impl_.time_to_intercept_seconds_ = value;
}
inline void ThreatAssessment::set_time_to_intercept_seconds(double value) {
  _internal_set_time_to_intercept_seconds(value);
  // @@protoc_insertion_point(field_set:radar.messages.ThreatAssessment.time_to_intercept_seconds)
}

// double intercept_probability = 11;
inline void ThreatAssessment::clear_intercept_probability() {
  _impl_.intercept_probability_ = 0;
}
inline double ThreatAssessment::_internal_intercept_probability() const {
  return _impl_.intercept_probability_;
}
inline double ThreatAssessment::intercept_probability() const {
  // @@protoc_insertion_point(field_get:radar.messages.ThreatAssessment.intercept_probability)
  return _internal_intercept_probability();
}
inline void ThreatAssessment::_internal_set_intercept_probability(double value) {
  
  _impl_.intercept_probability_ = value;
}
inline void ThreatAssessment::set_intercept_probability(double value) {
  _internal_set_intercept_probability(value);
  // @@protoc_insertion_point(field_set:radar.messages.ThreatAssessment.intercept_probability)
}

// repeated string recommended_actions = 12;
inline int ThreatAssessment::_internal_recommended_actions_size() const {
  return _impl_.recommended_actions_.size();
}
inline int ThreatAssessment::recommended_actions_size() const {
  return _internal_recommended_actions_size();
}
inline void ThreatAssessment::clear_recommended_actions() {
  _impl_.recommended_actions_.Clear();
}
inline std::string* ThreatAssessment::add_recommended_actions() {
  std::string* _s = _internal_add_recommended_actions();
  // @@protoc_insertion_point(field_add_mutable:radar.messages.ThreatAssessment.recommended_actions)
  return _s;
}
inline const std::string& ThreatAssessment::_internal_recommended_actions(int index) const {
  return _impl_.recommended_actions_.Get(index);
}
inline const std::string& ThreatAssessment::recommended_actions(int index) const {
  // @@protoc_insertion_point(field_get:radar.messages.ThreatAssessment.recommended_actions)
  return _internal_recommended_actions(index);
}
inline std::string* ThreatAssessment::mutable_recommended_actions(int index) {
  // @@protoc_insertion_point(field_mutable:radar.messages.ThreatAssessment.recommended_actions)
  return _impl_.recommended_actions_.Mutable(index);
}
inline void ThreatAssessment::set_recommended_actions(int index, const std::string& value) {
  _impl_.recommended_actions_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:radar.messages.ThreatAssessment.recommended_actions)
}
inline void ThreatAssessment::set_recommended_actions(int index, std::string&& value) {
  _impl_.recommended_actions_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:radar.messages.ThreatAssessment.recommended_actions)
}
inline void ThreatAssessment::set_recommended_actions(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.recommended_actions_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:radar.messages.ThreatAssessment.recommended_actions)
}
inline void ThreatAssessment::set_recommended_actions(int index, const char* value, size_t size) {
  _impl_.recommended_actions_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:radar.messages.ThreatAssessment.recommended_actions)
}
inline std::string* ThreatAssessment::_internal_add_recommended_actions() {
  return _impl_.recommended_actions_.Add();
}
inline void ThreatAssessment::add_recommended_actions(const std::string& value) {
  _impl_.recommended_actions_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:radar.messages.ThreatAssessment.recommended_actions)
}
inline void ThreatAssessment::add_recommended_actions(std::string&& value) {
  _impl_.recommended_actions_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:radar.messages.ThreatAssessment.recommended_actions)
}
inline void ThreatAssessment::add_recommended_actions(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.recommended_actions_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:radar.messages.ThreatAssessment.recommended_actions)
}
inline void ThreatAssessment::add_recommended_actions(const char* value, size_t size) {
  _impl_.recommended_actions_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:radar.messages.ThreatAssessment.recommended_actions)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ThreatAssessment::recommended_actions() const {
  // @@protoc_insertion_point(field_list:radar.messages.ThreatAssessment.recommended_actions)
  return _impl_.recommended_actions_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
ThreatAssessment::mutable_recommended_actions() {
  // @@protoc_insertion_point(field_mutable_list:radar.messages.ThreatAssessment.recommended_actions)
  return &_impl_.recommended_actions_;
}

// string priority = 13;
inline void ThreatAssessment::clear_priority() {
  _impl_.priority_.ClearToEmpty();
}
inline const std::string& ThreatAssessment::priority() const {
  // @@protoc_insertion_point(field_get:radar.messages.ThreatAssessment.priority)
  return _internal_priority();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ThreatAssessment::set_priority(ArgT0&& arg0, ArgT... args) {
 
 _impl_.priority_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:radar.messages.ThreatAssessment.priority)
}
inline std::string* ThreatAssessment::mutable_priority() {
  std::string* _s = _internal_mutable_priority();
  // @@protoc_insertion_point(field_mutable:radar.messages.ThreatAssessment.priority)
  return _s;
}
inline const std::string& ThreatAssessment::_internal_priority() const {
  return _impl_.priority_.Get();
}
inline void ThreatAssessment::_internal_set_priority(const std::string& value) {
  
  _impl_.priority_.Set(value, GetArenaForAllocation());
}
inline std::string* ThreatAssessment::_internal_mutable_priority() {
  
  return _impl_.priority_.Mutable(GetArenaForAllocation());
}
inline std::string* ThreatAssessment::release_priority() {
  // @@protoc_insertion_point(field_release:radar.messages.ThreatAssessment.priority)
  return _impl_.priority_.Release();
}
inline void ThreatAssessment::set_allocated_priority(std::string* priority) {
  if (priority != nullptr) {
    
  } else {
    
  }
  _impl_.priority_.SetAllocated(priority, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.priority_.IsDefault()) {
    _impl_.priority_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:radar.messages.ThreatAssessment.priority)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// SystemConfiguration

// .google.protobuf.Timestamp timestamp = 1;
inline bool SystemConfiguration::_internal_has_timestamp() const {
  return this != internal_default_instance() && _impl_.timestamp_ != nullptr;
}
inline bool SystemConfiguration::has_timestamp() const {
  return _internal_has_timestamp();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& SystemConfiguration::_internal_timestamp() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.timestamp_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& SystemConfiguration::timestamp() const {
  // @@protoc_insertion_point(field_get:radar.messages.SystemConfiguration.timestamp)
  return _internal_timestamp();
}
inline void SystemConfiguration::unsafe_arena_set_allocated_timestamp(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.timestamp_);
  }
  _impl_.timestamp_ = timestamp;
  if (timestamp) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:radar.messages.SystemConfiguration.timestamp)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* SystemConfiguration::release_timestamp() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.timestamp_;
  _impl_.timestamp_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* SystemConfiguration::unsafe_arena_release_timestamp() {
  // @@protoc_insertion_point(field_release:radar.messages.SystemConfiguration.timestamp)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.timestamp_;
  _impl_.timestamp_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* SystemConfiguration::_internal_mutable_timestamp() {
  
  if (_impl_.timestamp_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.timestamp_ = p;
  }
  return _impl_.timestamp_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* SystemConfiguration::mutable_timestamp() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_timestamp();
  // @@protoc_insertion_point(field_mutable:radar.messages.SystemConfiguration.timestamp)
  return _msg;
}
inline void SystemConfiguration::set_allocated_timestamp(::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.timestamp_);
  }
  if (timestamp) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(timestamp));
    if (message_arena != submessage_arena) {
      timestamp = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, timestamp, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.timestamp_ = timestamp;
  // @@protoc_insertion_point(field_set_allocated:radar.messages.SystemConfiguration.timestamp)
}

// string clustering_algorithm = 2;
inline void SystemConfiguration::clear_clustering_algorithm() {
  _impl_.clustering_algorithm_.ClearToEmpty();
}
inline const std::string& SystemConfiguration::clustering_algorithm() const {
  // @@protoc_insertion_point(field_get:radar.messages.SystemConfiguration.clustering_algorithm)
  return _internal_clustering_algorithm();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SystemConfiguration::set_clustering_algorithm(ArgT0&& arg0, ArgT... args) {
 
 _impl_.clustering_algorithm_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:radar.messages.SystemConfiguration.clustering_algorithm)
}
inline std::string* SystemConfiguration::mutable_clustering_algorithm() {
  std::string* _s = _internal_mutable_clustering_algorithm();
  // @@protoc_insertion_point(field_mutable:radar.messages.SystemConfiguration.clustering_algorithm)
  return _s;
}
inline const std::string& SystemConfiguration::_internal_clustering_algorithm() const {
  return _impl_.clustering_algorithm_.Get();
}
inline void SystemConfiguration::_internal_set_clustering_algorithm(const std::string& value) {
  
  _impl_.clustering_algorithm_.Set(value, GetArenaForAllocation());
}
inline std::string* SystemConfiguration::_internal_mutable_clustering_algorithm() {
  
  return _impl_.clustering_algorithm_.Mutable(GetArenaForAllocation());
}
inline std::string* SystemConfiguration::release_clustering_algorithm() {
  // @@protoc_insertion_point(field_release:radar.messages.SystemConfiguration.clustering_algorithm)
  return _impl_.clustering_algorithm_.Release();
}
inline void SystemConfiguration::set_allocated_clustering_algorithm(std::string* clustering_algorithm) {
  if (clustering_algorithm != nullptr) {
    
  } else {
    
  }
  _impl_.clustering_algorithm_.SetAllocated(clustering_algorithm, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.clustering_algorithm_.IsDefault()) {
    _impl_.clustering_algorithm_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:radar.messages.SystemConfiguration.clustering_algorithm)
}

// string association_algorithm = 3;
inline void SystemConfiguration::clear_association_algorithm() {
  _impl_.association_algorithm_.ClearToEmpty();
}
inline const std::string& SystemConfiguration::association_algorithm() const {
  // @@protoc_insertion_point(field_get:radar.messages.SystemConfiguration.association_algorithm)
  return _internal_association_algorithm();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SystemConfiguration::set_association_algorithm(ArgT0&& arg0, ArgT... args) {
 
 _impl_.association_algorithm_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:radar.messages.SystemConfiguration.association_algorithm)
}
inline std::string* SystemConfiguration::mutable_association_algorithm() {
  std::string* _s = _internal_mutable_association_algorithm();
  // @@protoc_insertion_point(field_mutable:radar.messages.SystemConfiguration.association_algorithm)
  return _s;
}
inline const std::string& SystemConfiguration::_internal_association_algorithm() const {
  return _impl_.association_algorithm_.Get();
}
inline void SystemConfiguration::_internal_set_association_algorithm(const std::string& value) {
  
  _impl_.association_algorithm_.Set(value, GetArenaForAllocation());
}
inline std::string* SystemConfiguration::_internal_mutable_association_algorithm() {
  
  return _impl_.association_algorithm_.Mutable(GetArenaForAllocation());
}
inline std::string* SystemConfiguration::release_association_algorithm() {
  // @@protoc_insertion_point(field_release:radar.messages.SystemConfiguration.association_algorithm)
  return _impl_.association_algorithm_.Release();
}
inline void SystemConfiguration::set_allocated_association_algorithm(std::string* association_algorithm) {
  if (association_algorithm != nullptr) {
    
  } else {
    
  }
  _impl_.association_algorithm_.SetAllocated(association_algorithm, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.association_algorithm_.IsDefault()) {
    _impl_.association_algorithm_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:radar.messages.SystemConfiguration.association_algorithm)
}

// string filter_algorithm = 4;
inline void SystemConfiguration::clear_filter_algorithm() {
  _impl_.filter_algorithm_.ClearToEmpty();
}
inline const std::string& SystemConfiguration::filter_algorithm() const {
  // @@protoc_insertion_point(field_get:radar.messages.SystemConfiguration.filter_algorithm)
  return _internal_filter_algorithm();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SystemConfiguration::set_filter_algorithm(ArgT0&& arg0, ArgT... args) {
 
 _impl_.filter_algorithm_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:radar.messages.SystemConfiguration.filter_algorithm)
}
inline std::string* SystemConfiguration::mutable_filter_algorithm() {
  std::string* _s = _internal_mutable_filter_algorithm();
  // @@protoc_insertion_point(field_mutable:radar.messages.SystemConfiguration.filter_algorithm)
  return _s;
}
inline const std::string& SystemConfiguration::_internal_filter_algorithm() const {
  return _impl_.filter_algorithm_.Get();
}
inline void SystemConfiguration::_internal_set_filter_algorithm(const std::string& value) {
  
  _impl_.filter_algorithm_.Set(value, GetArenaForAllocation());
}
inline std::string* SystemConfiguration::_internal_mutable_filter_algorithm() {
  
  return _impl_.filter_algorithm_.Mutable(GetArenaForAllocation());
}
inline std::string* SystemConfiguration::release_filter_algorithm() {
  // @@protoc_insertion_point(field_release:radar.messages.SystemConfiguration.filter_algorithm)
  return _impl_.filter_algorithm_.Release();
}
inline void SystemConfiguration::set_allocated_filter_algorithm(std::string* filter_algorithm) {
  if (filter_algorithm != nullptr) {
    
  } else {
    
  }
  _impl_.filter_algorithm_.SetAllocated(filter_algorithm, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.filter_algorithm_.IsDefault()) {
    _impl_.filter_algorithm_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:radar.messages.SystemConfiguration.filter_algorithm)
}

// map<string, double> clustering_params = 5;
inline int SystemConfiguration::_internal_clustering_params_size() const {
  return _impl_.clustering_params_.size();
}
inline int SystemConfiguration::clustering_params_size() const {
  return _internal_clustering_params_size();
}
inline void SystemConfiguration::clear_clustering_params() {
  _impl_.clustering_params_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >&
SystemConfiguration::_internal_clustering_params() const {
  return _impl_.clustering_params_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >&
SystemConfiguration::clustering_params() const {
  // @@protoc_insertion_point(field_map:radar.messages.SystemConfiguration.clustering_params)
  return _internal_clustering_params();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >*
SystemConfiguration::_internal_mutable_clustering_params() {
  return _impl_.clustering_params_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >*
SystemConfiguration::mutable_clustering_params() {
  // @@protoc_insertion_point(field_mutable_map:radar.messages.SystemConfiguration.clustering_params)
  return _internal_mutable_clustering_params();
}

// map<string, double> association_params = 6;
inline int SystemConfiguration::_internal_association_params_size() const {
  return _impl_.association_params_.size();
}
inline int SystemConfiguration::association_params_size() const {
  return _internal_association_params_size();
}
inline void SystemConfiguration::clear_association_params() {
  _impl_.association_params_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >&
SystemConfiguration::_internal_association_params() const {
  return _impl_.association_params_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >&
SystemConfiguration::association_params() const {
  // @@protoc_insertion_point(field_map:radar.messages.SystemConfiguration.association_params)
  return _internal_association_params();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >*
SystemConfiguration::_internal_mutable_association_params() {
  return _impl_.association_params_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >*
SystemConfiguration::mutable_association_params() {
  // @@protoc_insertion_point(field_mutable_map:radar.messages.SystemConfiguration.association_params)
  return _internal_mutable_association_params();
}

// map<string, double> filter_params = 7;
inline int SystemConfiguration::_internal_filter_params_size() const {
  return _impl_.filter_params_.size();
}
inline int SystemConfiguration::filter_params_size() const {
  return _internal_filter_params_size();
}
inline void SystemConfiguration::clear_filter_params() {
  _impl_.filter_params_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >&
SystemConfiguration::_internal_filter_params() const {
  return _impl_.filter_params_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >&
SystemConfiguration::filter_params() const {
  // @@protoc_insertion_point(field_map:radar.messages.SystemConfiguration.filter_params)
  return _internal_filter_params();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >*
SystemConfiguration::_internal_mutable_filter_params() {
  return _impl_.filter_params_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >*
SystemConfiguration::mutable_filter_params() {
  // @@protoc_insertion_point(field_mutable_map:radar.messages.SystemConfiguration.filter_params)
  return _internal_mutable_filter_params();
}

// double update_rate_hz = 8;
inline void SystemConfiguration::clear_update_rate_hz() {
  _impl_.update_rate_hz_ = 0;
}
inline double SystemConfiguration::_internal_update_rate_hz() const {
  return _impl_.update_rate_hz_;
}
inline double SystemConfiguration::update_rate_hz() const {
  // @@protoc_insertion_point(field_get:radar.messages.SystemConfiguration.update_rate_hz)
  return _internal_update_rate_hz();
}
inline void SystemConfiguration::_internal_set_update_rate_hz(double value) {
  
  _impl_.update_rate_hz_ = value;
}
inline void SystemConfiguration::set_update_rate_hz(double value) {
  _internal_set_update_rate_hz(value);
  // @@protoc_insertion_point(field_set:radar.messages.SystemConfiguration.update_rate_hz)
}

// uint32 max_tracks = 9;
inline void SystemConfiguration::clear_max_tracks() {
  _impl_.max_tracks_ = 0u;
}
inline uint32_t SystemConfiguration::_internal_max_tracks() const {
  return _impl_.max_tracks_;
}
inline uint32_t SystemConfiguration::max_tracks() const {
  // @@protoc_insertion_point(field_get:radar.messages.SystemConfiguration.max_tracks)
  return _internal_max_tracks();
}
inline void SystemConfiguration::_internal_set_max_tracks(uint32_t value) {
  
  _impl_.max_tracks_ = value;
}
inline void SystemConfiguration::set_max_tracks(uint32_t value) {
  _internal_set_max_tracks(value);
  // @@protoc_insertion_point(field_set:radar.messages.SystemConfiguration.max_tracks)
}

// double track_timeout_seconds = 10;
inline void SystemConfiguration::clear_track_timeout_seconds() {
  _impl_.track_timeout_seconds_ = 0;
}
inline double SystemConfiguration::_internal_track_timeout_seconds() const {
  return _impl_.track_timeout_seconds_;
}
inline double SystemConfiguration::track_timeout_seconds() const {
  // @@protoc_insertion_point(field_get:radar.messages.SystemConfiguration.track_timeout_seconds)
  return _internal_track_timeout_seconds();
}
inline void SystemConfiguration::_internal_set_track_timeout_seconds(double value) {
  
  _impl_.track_timeout_seconds_ = value;
}
inline void SystemConfiguration::set_track_timeout_seconds(double value) {
  _internal_set_track_timeout_seconds(value);
  // @@protoc_insertion_point(field_set:radar.messages.SystemConfiguration.track_timeout_seconds)
}

// double confirmation_threshold = 11;
inline void SystemConfiguration::clear_confirmation_threshold() {
  _impl_.confirmation_threshold_ = 0;
}
inline double SystemConfiguration::_internal_confirmation_threshold() const {
  return _impl_.confirmation_threshold_;
}
inline double SystemConfiguration::confirmation_threshold() const {
  // @@protoc_insertion_point(field_get:radar.messages.SystemConfiguration.confirmation_threshold)
  return _internal_confirmation_threshold();
}
inline void SystemConfiguration::_internal_set_confirmation_threshold(double value) {
  
  _impl_.confirmation_threshold_ = value;
}
inline void SystemConfiguration::set_confirmation_threshold(double value) {
  _internal_set_confirmation_threshold(value);
  // @@protoc_insertion_point(field_set:radar.messages.SystemConfiguration.confirmation_threshold)
}

// double deletion_threshold = 12;
inline void SystemConfiguration::clear_deletion_threshold() {
  _impl_.deletion_threshold_ = 0;
}
inline double SystemConfiguration::_internal_deletion_threshold() const {
  return _impl_.deletion_threshold_;
}
inline double SystemConfiguration::deletion_threshold() const {
  // @@protoc_insertion_point(field_get:radar.messages.SystemConfiguration.deletion_threshold)
  return _internal_deletion_threshold();
}
inline void SystemConfiguration::_internal_set_deletion_threshold(double value) {
  
  _impl_.deletion_threshold_ = value;
}
inline void SystemConfiguration::set_deletion_threshold(double value) {
  _internal_set_deletion_threshold(value);
  // @@protoc_insertion_point(field_set:radar.messages.SystemConfiguration.deletion_threshold)
}

// bool enable_hmi_output = 13;
inline void SystemConfiguration::clear_enable_hmi_output() {
  _impl_.enable_hmi_output_ = false;
}
inline bool SystemConfiguration::_internal_enable_hmi_output() const {
  return _impl_.enable_hmi_output_;
}
inline bool SystemConfiguration::enable_hmi_output() const {
  // @@protoc_insertion_point(field_get:radar.messages.SystemConfiguration.enable_hmi_output)
  return _internal_enable_hmi_output();
}
inline void SystemConfiguration::_internal_set_enable_hmi_output(bool value) {
  
  _impl_.enable_hmi_output_ = value;
}
inline void SystemConfiguration::set_enable_hmi_output(bool value) {
  _internal_set_enable_hmi_output(value);
  // @@protoc_insertion_point(field_set:radar.messages.SystemConfiguration.enable_hmi_output)
}

// bool enable_fusion_output = 14;
inline void SystemConfiguration::clear_enable_fusion_output() {
  _impl_.enable_fusion_output_ = false;
}
inline bool SystemConfiguration::_internal_enable_fusion_output() const {
  return _impl_.enable_fusion_output_;
}
inline bool SystemConfiguration::enable_fusion_output() const {
  // @@protoc_insertion_point(field_get:radar.messages.SystemConfiguration.enable_fusion_output)
  return _internal_enable_fusion_output();
}
inline void SystemConfiguration::_internal_set_enable_fusion_output(bool value) {
  
  _impl_.enable_fusion_output_ = value;
}
inline void SystemConfiguration::set_enable_fusion_output(bool value) {
  _internal_set_enable_fusion_output(value);
  // @@protoc_insertion_point(field_set:radar.messages.SystemConfiguration.enable_fusion_output)
}

// bool enable_logging = 15;
inline void SystemConfiguration::clear_enable_logging() {
  _impl_.enable_logging_ = false;
}
inline bool SystemConfiguration::_internal_enable_logging() const {
  return _impl_.enable_logging_;
}
inline bool SystemConfiguration::enable_logging() const {
  // @@protoc_insertion_point(field_get:radar.messages.SystemConfiguration.enable_logging)
  return _internal_enable_logging();
}
inline void SystemConfiguration::_internal_set_enable_logging(bool value) {
  
  _impl_.enable_logging_ = value;
}
inline void SystemConfiguration::set_enable_logging(bool value) {
  _internal_set_enable_logging(value);
  // @@protoc_insertion_point(field_set:radar.messages.SystemConfiguration.enable_logging)
}

// string log_level = 16;
inline void SystemConfiguration::clear_log_level() {
  _impl_.log_level_.ClearToEmpty();
}
inline const std::string& SystemConfiguration::log_level() const {
  // @@protoc_insertion_point(field_get:radar.messages.SystemConfiguration.log_level)
  return _internal_log_level();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SystemConfiguration::set_log_level(ArgT0&& arg0, ArgT... args) {
 
 _impl_.log_level_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:radar.messages.SystemConfiguration.log_level)
}
inline std::string* SystemConfiguration::mutable_log_level() {
  std::string* _s = _internal_mutable_log_level();
  // @@protoc_insertion_point(field_mutable:radar.messages.SystemConfiguration.log_level)
  return _s;
}
inline const std::string& SystemConfiguration::_internal_log_level() const {
  return _impl_.log_level_.Get();
}
inline void SystemConfiguration::_internal_set_log_level(const std::string& value) {
  
  _impl_.log_level_.Set(value, GetArenaForAllocation());
}
inline std::string* SystemConfiguration::_internal_mutable_log_level() {
  
  return _impl_.log_level_.Mutable(GetArenaForAllocation());
}
inline std::string* SystemConfiguration::release_log_level() {
  // @@protoc_insertion_point(field_release:radar.messages.SystemConfiguration.log_level)
  return _impl_.log_level_.Release();
}
inline void SystemConfiguration::set_allocated_log_level(std::string* log_level) {
  if (log_level != nullptr) {
    
  } else {
    
  }
  _impl_.log_level_.SetAllocated(log_level, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.log_level_.IsDefault()) {
    _impl_.log_level_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:radar.messages.SystemConfiguration.log_level)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace messages
}  // namespace radar

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::radar::messages::TrackUpdate_UpdateType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::radar::messages::TrackUpdate_UpdateType>() {
  return ::radar::messages::TrackUpdate_UpdateType_descriptor();
}
template <> struct is_proto_enum< ::radar::messages::DetectionCluster_ClusteringAlgorithm> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::radar::messages::DetectionCluster_ClusteringAlgorithm>() {
  return ::radar::messages::DetectionCluster_ClusteringAlgorithm_descriptor();
}
template <> struct is_proto_enum< ::radar::messages::Association_AssociationAlgorithm> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::radar::messages::Association_AssociationAlgorithm>() {
  return ::radar::messages::Association_AssociationAlgorithm_descriptor();
}
template <> struct is_proto_enum< ::radar::messages::ThreatAssessment_ThreatLevel> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::radar::messages::ThreatAssessment_ThreatLevel>() {
  return ::radar::messages::ThreatAssessment_ThreatLevel_descriptor();
}
template <> struct is_proto_enum< ::radar::messages::FilterType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::radar::messages::FilterType>() {
  return ::radar::messages::FilterType_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_track_5fmessages_2eproto
