// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: track_messages.proto

#include "track_messages.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

namespace radar {
namespace messages {
PROTOBUF_CONSTEXPR TrackState::TrackState(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.state_)*/{}
  , /*decltype(_impl_.covariance_)*/{}
  , /*decltype(_impl_.position_)*/nullptr
  , /*decltype(_impl_.velocity_)*/nullptr
  , /*decltype(_impl_.acceleration_)*/nullptr
  , /*decltype(_impl_.state_size_)*/0u
  , /*decltype(_impl_.motion_model_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct TrackStateDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TrackStateDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TrackStateDefaultTypeInternal() {}
  union {
    TrackState _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TrackStateDefaultTypeInternal _TrackState_default_instance_;
PROTOBUF_CONSTEXPR Track_ClassificationScoresEntry_DoNotUse::Track_ClassificationScoresEntry_DoNotUse(
    ::_pbi::ConstantInitialized) {}
struct Track_ClassificationScoresEntry_DoNotUseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Track_ClassificationScoresEntry_DoNotUseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~Track_ClassificationScoresEntry_DoNotUseDefaultTypeInternal() {}
  union {
    Track_ClassificationScoresEntry_DoNotUse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Track_ClassificationScoresEntry_DoNotUseDefaultTypeInternal _Track_ClassificationScoresEntry_DoNotUse_default_instance_;
PROTOBUF_CONSTEXPR Track_AttributesEntry_DoNotUse::Track_AttributesEntry_DoNotUse(
    ::_pbi::ConstantInitialized) {}
struct Track_AttributesEntry_DoNotUseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Track_AttributesEntry_DoNotUseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~Track_AttributesEntry_DoNotUseDefaultTypeInternal() {}
  union {
    Track_AttributesEntry_DoNotUse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Track_AttributesEntry_DoNotUseDefaultTypeInternal _Track_AttributesEntry_DoNotUse_default_instance_;
PROTOBUF_CONSTEXPR Track::Track(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.classification_scores_)*/{::_pbi::ConstantInitialized()}
  , /*decltype(_impl_.attributes_)*/{::_pbi::ConstantInitialized()}
  , /*decltype(_impl_.target_class_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.created_time_)*/nullptr
  , /*decltype(_impl_.last_update_time_)*/nullptr
  , /*decltype(_impl_.current_state_)*/nullptr
  , /*decltype(_impl_.predicted_state_)*/nullptr
  , /*decltype(_impl_.state_)*/nullptr
  , /*decltype(_impl_.id_)*/0u
  , /*decltype(_impl_.sensor_id_)*/0u
  , /*decltype(_impl_.hit_count_)*/0u
  , /*decltype(_impl_.miss_count_)*/0u
  , /*decltype(_impl_.confidence_)*/0
  , /*decltype(_impl_.coast_count_)*/0u
  , /*decltype(_impl_.filter_type_)*/0
  , /*decltype(_impl_.likelihood_)*/0
  , /*decltype(_impl_.track_quality_)*/0
  , /*decltype(_impl_.innovation_magnitude_)*/0
  , /*decltype(_impl_.mahalanobis_distance_)*/0
  , /*decltype(_impl_.speed_)*/0
  , /*decltype(_impl_.heading_)*/0
  , /*decltype(_impl_.turn_rate_)*/0
  , /*decltype(_impl_.range_)*/0
  , /*decltype(_impl_.bearing_)*/0
  , /*decltype(_impl_.elevation_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct TrackDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TrackDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TrackDefaultTypeInternal() {}
  union {
    Track _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TrackDefaultTypeInternal _Track_default_instance_;
PROTOBUF_CONSTEXPR TrackBatch::TrackBatch(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.tracks_)*/{}
  , /*decltype(_impl_.batch_timestamp_)*/nullptr
  , /*decltype(_impl_.performance_)*/nullptr
  , /*decltype(_impl_.sensor_id_)*/0u
  , /*decltype(_impl_.sequence_number_)*/0u
  , /*decltype(_impl_.processing_time_ms_)*/0
  , /*decltype(_impl_.total_tracks_)*/0u
  , /*decltype(_impl_.confirmed_tracks_)*/0u
  , /*decltype(_impl_.tentative_tracks_)*/0u
  , /*decltype(_impl_.coasting_tracks_)*/0u
  , /*decltype(_impl_.deleted_tracks_)*/0u
  , /*decltype(_impl_.total_associations_)*/0u
  , /*decltype(_impl_.association_rate_)*/0
  , /*decltype(_impl_.successful_associations_)*/0u
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct TrackBatchDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TrackBatchDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TrackBatchDefaultTypeInternal() {}
  union {
    TrackBatch _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TrackBatchDefaultTypeInternal _TrackBatch_default_instance_;
PROTOBUF_CONSTEXPR TrackUpdate_UpdateDataEntry_DoNotUse::TrackUpdate_UpdateDataEntry_DoNotUse(
    ::_pbi::ConstantInitialized) {}
struct TrackUpdate_UpdateDataEntry_DoNotUseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TrackUpdate_UpdateDataEntry_DoNotUseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TrackUpdate_UpdateDataEntry_DoNotUseDefaultTypeInternal() {}
  union {
    TrackUpdate_UpdateDataEntry_DoNotUse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TrackUpdate_UpdateDataEntry_DoNotUseDefaultTypeInternal _TrackUpdate_UpdateDataEntry_DoNotUse_default_instance_;
PROTOBUF_CONSTEXPR TrackUpdate::TrackUpdate(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.update_data_)*/{::_pbi::ConstantInitialized()}
  , /*decltype(_impl_.timestamp_)*/nullptr
  , /*decltype(_impl_.track_)*/nullptr
  , /*decltype(_impl_.track_id_)*/0u
  , /*decltype(_impl_.sensor_id_)*/0u
  , /*decltype(_impl_.update_type_)*/0
  , /*decltype(_impl_.associated_detection_id_)*/0u
  , /*decltype(_impl_.association_score_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct TrackUpdateDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TrackUpdateDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TrackUpdateDefaultTypeInternal() {}
  union {
    TrackUpdate _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TrackUpdateDefaultTypeInternal _TrackUpdate_default_instance_;
PROTOBUF_CONSTEXPR TrackHistory::TrackHistory(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.state_history_)*/{}
  , /*decltype(_impl_.timestamps_)*/{}
  , /*decltype(_impl_.associated_detections_)*/{}
  , /*decltype(_impl_.confidence_history_)*/{}
  , /*decltype(_impl_.likelihood_history_)*/{}
  , /*decltype(_impl_.track_id_)*/0u
  , /*decltype(_impl_.sensor_id_)*/0u
  , /*decltype(_impl_.average_speed_)*/0
  , /*decltype(_impl_.max_speed_)*/0
  , /*decltype(_impl_.total_distance_)*/0
  , /*decltype(_impl_.total_time_seconds_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct TrackHistoryDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TrackHistoryDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TrackHistoryDefaultTypeInternal() {}
  union {
    TrackHistory _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TrackHistoryDefaultTypeInternal _TrackHistory_default_instance_;
PROTOBUF_CONSTEXPR DetectionCluster_AlgorithmParametersEntry_DoNotUse::DetectionCluster_AlgorithmParametersEntry_DoNotUse(
    ::_pbi::ConstantInitialized) {}
struct DetectionCluster_AlgorithmParametersEntry_DoNotUseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DetectionCluster_AlgorithmParametersEntry_DoNotUseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DetectionCluster_AlgorithmParametersEntry_DoNotUseDefaultTypeInternal() {}
  union {
    DetectionCluster_AlgorithmParametersEntry_DoNotUse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DetectionCluster_AlgorithmParametersEntry_DoNotUseDefaultTypeInternal _DetectionCluster_AlgorithmParametersEntry_DoNotUse_default_instance_;
PROTOBUF_CONSTEXPR DetectionCluster::DetectionCluster(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.detections_)*/{}
  , /*decltype(_impl_.algorithm_parameters_)*/{::_pbi::ConstantInitialized()}
  , /*decltype(_impl_.centroid_)*/nullptr
  , /*decltype(_impl_.covariance_)*/nullptr
  , /*decltype(_impl_.timestamp_)*/nullptr
  , /*decltype(_impl_.id_)*/0u
  , /*decltype(_impl_.algorithm_)*/0
  , /*decltype(_impl_.cluster_radius_)*/0
  , /*decltype(_impl_.cluster_density_)*/0
  , /*decltype(_impl_.processing_time_ms_)*/0
  , /*decltype(_impl_.detection_count_)*/0u
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct DetectionClusterDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DetectionClusterDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DetectionClusterDefaultTypeInternal() {}
  union {
    DetectionCluster _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DetectionClusterDefaultTypeInternal _DetectionCluster_default_instance_;
PROTOBUF_CONSTEXPR Association::Association(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.innovation_)*/nullptr
  , /*decltype(_impl_.innovation_covariance_)*/nullptr
  , /*decltype(_impl_.track_id_)*/0u
  , /*decltype(_impl_.detection_id_)*/0u
  , /*decltype(_impl_.score_)*/0
  , /*decltype(_impl_.distance_)*/0
  , /*decltype(_impl_.is_valid_)*/false
  , /*decltype(_impl_.algorithm_)*/0
  , /*decltype(_impl_.likelihood_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct AssociationDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AssociationDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~AssociationDefaultTypeInternal() {}
  union {
    Association _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AssociationDefaultTypeInternal _Association_default_instance_;
PROTOBUF_CONSTEXPR FusionData_SensorWeightsEntry_DoNotUse::FusionData_SensorWeightsEntry_DoNotUse(
    ::_pbi::ConstantInitialized) {}
struct FusionData_SensorWeightsEntry_DoNotUseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR FusionData_SensorWeightsEntry_DoNotUseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~FusionData_SensorWeightsEntry_DoNotUseDefaultTypeInternal() {}
  union {
    FusionData_SensorWeightsEntry_DoNotUse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 FusionData_SensorWeightsEntry_DoNotUseDefaultTypeInternal _FusionData_SensorWeightsEntry_DoNotUse_default_instance_;
PROTOBUF_CONSTEXPR FusionData::FusionData(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.fused_tracks_)*/{}
  , /*decltype(_impl_.contributing_sensors_)*/{}
  , /*decltype(_impl_._contributing_sensors_cached_byte_size_)*/{0}
  , /*decltype(_impl_.sensor_weights_)*/{::_pbi::ConstantInitialized()}
  , /*decltype(_impl_.fusion_algorithm_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.timestamp_)*/nullptr
  , /*decltype(_impl_.fusion_id_)*/0u
  , /*decltype(_impl_.redundant_tracks_)*/0u
  , /*decltype(_impl_.fusion_quality_)*/0
  , /*decltype(_impl_.cross_correlation_)*/0
  , /*decltype(_impl_.position_uncertainty_)*/0
  , /*decltype(_impl_.velocity_uncertainty_)*/0
  , /*decltype(_impl_.fusion_time_ms_)*/0
  , /*decltype(_impl_.unique_tracks_)*/0u
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct FusionDataDefaultTypeInternal {
  PROTOBUF_CONSTEXPR FusionDataDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~FusionDataDefaultTypeInternal() {}
  union {
    FusionData _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 FusionDataDefaultTypeInternal _FusionData_default_instance_;
PROTOBUF_CONSTEXPR ThreatAssessment::ThreatAssessment(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.recommended_actions_)*/{}
  , /*decltype(_impl_.priority_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.timestamp_)*/nullptr
  , /*decltype(_impl_.predicted_intercept_)*/nullptr
  , /*decltype(_impl_.track_id_)*/0u
  , /*decltype(_impl_.threat_level_)*/0
  , /*decltype(_impl_.threat_score_)*/0
  , /*decltype(_impl_.proximity_factor_)*/0
  , /*decltype(_impl_.velocity_factor_)*/0
  , /*decltype(_impl_.trajectory_factor_)*/0
  , /*decltype(_impl_.classification_factor_)*/0
  , /*decltype(_impl_.time_to_intercept_seconds_)*/0
  , /*decltype(_impl_.intercept_probability_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ThreatAssessmentDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ThreatAssessmentDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ThreatAssessmentDefaultTypeInternal() {}
  union {
    ThreatAssessment _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ThreatAssessmentDefaultTypeInternal _ThreatAssessment_default_instance_;
PROTOBUF_CONSTEXPR SystemConfiguration_ClusteringParamsEntry_DoNotUse::SystemConfiguration_ClusteringParamsEntry_DoNotUse(
    ::_pbi::ConstantInitialized) {}
struct SystemConfiguration_ClusteringParamsEntry_DoNotUseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SystemConfiguration_ClusteringParamsEntry_DoNotUseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SystemConfiguration_ClusteringParamsEntry_DoNotUseDefaultTypeInternal() {}
  union {
    SystemConfiguration_ClusteringParamsEntry_DoNotUse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SystemConfiguration_ClusteringParamsEntry_DoNotUseDefaultTypeInternal _SystemConfiguration_ClusteringParamsEntry_DoNotUse_default_instance_;
PROTOBUF_CONSTEXPR SystemConfiguration_AssociationParamsEntry_DoNotUse::SystemConfiguration_AssociationParamsEntry_DoNotUse(
    ::_pbi::ConstantInitialized) {}
struct SystemConfiguration_AssociationParamsEntry_DoNotUseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SystemConfiguration_AssociationParamsEntry_DoNotUseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SystemConfiguration_AssociationParamsEntry_DoNotUseDefaultTypeInternal() {}
  union {
    SystemConfiguration_AssociationParamsEntry_DoNotUse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SystemConfiguration_AssociationParamsEntry_DoNotUseDefaultTypeInternal _SystemConfiguration_AssociationParamsEntry_DoNotUse_default_instance_;
PROTOBUF_CONSTEXPR SystemConfiguration_FilterParamsEntry_DoNotUse::SystemConfiguration_FilterParamsEntry_DoNotUse(
    ::_pbi::ConstantInitialized) {}
struct SystemConfiguration_FilterParamsEntry_DoNotUseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SystemConfiguration_FilterParamsEntry_DoNotUseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SystemConfiguration_FilterParamsEntry_DoNotUseDefaultTypeInternal() {}
  union {
    SystemConfiguration_FilterParamsEntry_DoNotUse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SystemConfiguration_FilterParamsEntry_DoNotUseDefaultTypeInternal _SystemConfiguration_FilterParamsEntry_DoNotUse_default_instance_;
PROTOBUF_CONSTEXPR SystemConfiguration::SystemConfiguration(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.clustering_params_)*/{::_pbi::ConstantInitialized()}
  , /*decltype(_impl_.association_params_)*/{::_pbi::ConstantInitialized()}
  , /*decltype(_impl_.filter_params_)*/{::_pbi::ConstantInitialized()}
  , /*decltype(_impl_.clustering_algorithm_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.association_algorithm_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.filter_algorithm_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.log_level_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.timestamp_)*/nullptr
  , /*decltype(_impl_.update_rate_hz_)*/0
  , /*decltype(_impl_.track_timeout_seconds_)*/0
  , /*decltype(_impl_.confirmation_threshold_)*/0
  , /*decltype(_impl_.deletion_threshold_)*/0
  , /*decltype(_impl_.max_tracks_)*/0u
  , /*decltype(_impl_.enable_hmi_output_)*/false
  , /*decltype(_impl_.enable_fusion_output_)*/false
  , /*decltype(_impl_.enable_logging_)*/false
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct SystemConfigurationDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SystemConfigurationDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SystemConfigurationDefaultTypeInternal() {}
  union {
    SystemConfiguration _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SystemConfigurationDefaultTypeInternal _SystemConfiguration_default_instance_;
}  // namespace messages
}  // namespace radar
static ::_pb::Metadata file_level_metadata_track_5fmessages_2eproto[18];
static const ::_pb::EnumDescriptor* file_level_enum_descriptors_track_5fmessages_2eproto[5];
static constexpr ::_pb::ServiceDescriptor const** file_level_service_descriptors_track_5fmessages_2eproto = nullptr;

const uint32_t TableStruct_track_5fmessages_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::radar::messages::TrackState, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::radar::messages::TrackState, _impl_.state_),
  PROTOBUF_FIELD_OFFSET(::radar::messages::TrackState, _impl_.covariance_),
  PROTOBUF_FIELD_OFFSET(::radar::messages::TrackState, _impl_.state_size_),
  PROTOBUF_FIELD_OFFSET(::radar::messages::TrackState, _impl_.motion_model_),
  PROTOBUF_FIELD_OFFSET(::radar::messages::TrackState, _impl_.position_),
  PROTOBUF_FIELD_OFFSET(::radar::messages::TrackState, _impl_.velocity_),
  PROTOBUF_FIELD_OFFSET(::radar::messages::TrackState, _impl_.acceleration_),
  PROTOBUF_FIELD_OFFSET(::radar::messages::Track_ClassificationScoresEntry_DoNotUse, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::radar::messages::Track_ClassificationScoresEntry_DoNotUse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::radar::messages::Track_ClassificationScoresEntry_DoNotUse, key_),
  PROTOBUF_FIELD_OFFSET(::radar::messages::Track_ClassificationScoresEntry_DoNotUse, value_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::radar::messages::Track_AttributesEntry_DoNotUse, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::radar::messages::Track_AttributesEntry_DoNotUse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::radar::messages::Track_AttributesEntry_DoNotUse, key_),
  PROTOBUF_FIELD_OFFSET(::radar::messages::Track_AttributesEntry_DoNotUse, value_),
  0,
  1,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::radar::messages::Track, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::radar::messages::Track, _impl_.id_),
  PROTOBUF_FIELD_OFFSET(::radar::messages::Track, _impl_.sensor_id_),
  PROTOBUF_FIELD_OFFSET(::radar::messages::Track, _impl_.created_time_),
  PROTOBUF_FIELD_OFFSET(::radar::messages::Track, _impl_.last_update_time_),
  PROTOBUF_FIELD_OFFSET(::radar::messages::Track, _impl_.current_state_),
  PROTOBUF_FIELD_OFFSET(::radar::messages::Track, _impl_.predicted_state_),
  PROTOBUF_FIELD_OFFSET(::radar::messages::Track, _impl_.state_),
  PROTOBUF_FIELD_OFFSET(::radar::messages::Track, _impl_.hit_count_),
  PROTOBUF_FIELD_OFFSET(::radar::messages::Track, _impl_.miss_count_),
  PROTOBUF_FIELD_OFFSET(::radar::messages::Track, _impl_.coast_count_),
  PROTOBUF_FIELD_OFFSET(::radar::messages::Track, _impl_.confidence_),
  PROTOBUF_FIELD_OFFSET(::radar::messages::Track, _impl_.likelihood_),
  PROTOBUF_FIELD_OFFSET(::radar::messages::Track, _impl_.filter_type_),
  PROTOBUF_FIELD_OFFSET(::radar::messages::Track, _impl_.target_class_),
  PROTOBUF_FIELD_OFFSET(::radar::messages::Track, _impl_.classification_scores_),
  PROTOBUF_FIELD_OFFSET(::radar::messages::Track, _impl_.track_quality_),
  PROTOBUF_FIELD_OFFSET(::radar::messages::Track, _impl_.innovation_magnitude_),
  PROTOBUF_FIELD_OFFSET(::radar::messages::Track, _impl_.mahalanobis_distance_),
  PROTOBUF_FIELD_OFFSET(::radar::messages::Track, _impl_.speed_),
  PROTOBUF_FIELD_OFFSET(::radar::messages::Track, _impl_.heading_),
  PROTOBUF_FIELD_OFFSET(::radar::messages::Track, _impl_.turn_rate_),
  PROTOBUF_FIELD_OFFSET(::radar::messages::Track, _impl_.range_),
  PROTOBUF_FIELD_OFFSET(::radar::messages::Track, _impl_.bearing_),
  PROTOBUF_FIELD_OFFSET(::radar::messages::Track, _impl_.elevation_),
  PROTOBUF_FIELD_OFFSET(::radar::messages::Track, _impl_.attributes_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::radar::messages::TrackBatch, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::radar::messages::TrackBatch, _impl_.tracks_),
  PROTOBUF_FIELD_OFFSET(::radar::messages::TrackBatch, _impl_.batch_timestamp_),
  PROTOBUF_FIELD_OFFSET(::radar::messages::TrackBatch, _impl_.sensor_id_),
  PROTOBUF_FIELD_OFFSET(::radar::messages::TrackBatch, _impl_.sequence_number_),
  PROTOBUF_FIELD_OFFSET(::radar::messages::TrackBatch, _impl_.processing_time_ms_),
  PROTOBUF_FIELD_OFFSET(::radar::messages::TrackBatch, _impl_.total_tracks_),
  PROTOBUF_FIELD_OFFSET(::radar::messages::TrackBatch, _impl_.confirmed_tracks_),
  PROTOBUF_FIELD_OFFSET(::radar::messages::TrackBatch, _impl_.tentative_tracks_),
  PROTOBUF_FIELD_OFFSET(::radar::messages::TrackBatch, _impl_.coasting_tracks_),
  PROTOBUF_FIELD_OFFSET(::radar::messages::TrackBatch, _impl_.deleted_tracks_),
  PROTOBUF_FIELD_OFFSET(::radar::messages::TrackBatch, _impl_.total_associations_),
  PROTOBUF_FIELD_OFFSET(::radar::messages::TrackBatch, _impl_.successful_associations_),
  PROTOBUF_FIELD_OFFSET(::radar::messages::TrackBatch, _impl_.association_rate_),
  PROTOBUF_FIELD_OFFSET(::radar::messages::TrackBatch, _impl_.performance_),
  PROTOBUF_FIELD_OFFSET(::radar::messages::TrackUpdate_UpdateDataEntry_DoNotUse, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::radar::messages::TrackUpdate_UpdateDataEntry_DoNotUse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::radar::messages::TrackUpdate_UpdateDataEntry_DoNotUse, key_),
  PROTOBUF_FIELD_OFFSET(::radar::messages::TrackUpdate_UpdateDataEntry_DoNotUse, value_),
  0,
  1,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::radar::messages::TrackUpdate, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::radar::messages::TrackUpdate, _impl_.track_id_),
  PROTOBUF_FIELD_OFFSET(::radar::messages::TrackUpdate, _impl_.sensor_id_),
  PROTOBUF_FIELD_OFFSET(::radar::messages::TrackUpdate, _impl_.timestamp_),
  PROTOBUF_FIELD_OFFSET(::radar::messages::TrackUpdate, _impl_.update_type_),
  PROTOBUF_FIELD_OFFSET(::radar::messages::TrackUpdate, _impl_.track_),
  PROTOBUF_FIELD_OFFSET(::radar::messages::TrackUpdate, _impl_.associated_detection_id_),
  PROTOBUF_FIELD_OFFSET(::radar::messages::TrackUpdate, _impl_.association_score_),
  PROTOBUF_FIELD_OFFSET(::radar::messages::TrackUpdate, _impl_.update_data_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::radar::messages::TrackHistory, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::radar::messages::TrackHistory, _impl_.track_id_),
  PROTOBUF_FIELD_OFFSET(::radar::messages::TrackHistory, _impl_.sensor_id_),
  PROTOBUF_FIELD_OFFSET(::radar::messages::TrackHistory, _impl_.state_history_),
  PROTOBUF_FIELD_OFFSET(::radar::messages::TrackHistory, _impl_.timestamps_),
  PROTOBUF_FIELD_OFFSET(::radar::messages::TrackHistory, _impl_.associated_detections_),
  PROTOBUF_FIELD_OFFSET(::radar::messages::TrackHistory, _impl_.average_speed_),
  PROTOBUF_FIELD_OFFSET(::radar::messages::TrackHistory, _impl_.max_speed_),
  PROTOBUF_FIELD_OFFSET(::radar::messages::TrackHistory, _impl_.total_distance_),
  PROTOBUF_FIELD_OFFSET(::radar::messages::TrackHistory, _impl_.total_time_seconds_),
  PROTOBUF_FIELD_OFFSET(::radar::messages::TrackHistory, _impl_.confidence_history_),
  PROTOBUF_FIELD_OFFSET(::radar::messages::TrackHistory, _impl_.likelihood_history_),
  PROTOBUF_FIELD_OFFSET(::radar::messages::DetectionCluster_AlgorithmParametersEntry_DoNotUse, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::radar::messages::DetectionCluster_AlgorithmParametersEntry_DoNotUse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::radar::messages::DetectionCluster_AlgorithmParametersEntry_DoNotUse, key_),
  PROTOBUF_FIELD_OFFSET(::radar::messages::DetectionCluster_AlgorithmParametersEntry_DoNotUse, value_),
  0,
  1,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::radar::messages::DetectionCluster, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::radar::messages::DetectionCluster, _impl_.id_),
  PROTOBUF_FIELD_OFFSET(::radar::messages::DetectionCluster, _impl_.detections_),
  PROTOBUF_FIELD_OFFSET(::radar::messages::DetectionCluster, _impl_.centroid_),
  PROTOBUF_FIELD_OFFSET(::radar::messages::DetectionCluster, _impl_.covariance_),
  PROTOBUF_FIELD_OFFSET(::radar::messages::DetectionCluster, _impl_.timestamp_),
  PROTOBUF_FIELD_OFFSET(::radar::messages::DetectionCluster, _impl_.algorithm_),
  PROTOBUF_FIELD_OFFSET(::radar::messages::DetectionCluster, _impl_.detection_count_),
  PROTOBUF_FIELD_OFFSET(::radar::messages::DetectionCluster, _impl_.cluster_radius_),
  PROTOBUF_FIELD_OFFSET(::radar::messages::DetectionCluster, _impl_.cluster_density_),
  PROTOBUF_FIELD_OFFSET(::radar::messages::DetectionCluster, _impl_.processing_time_ms_),
  PROTOBUF_FIELD_OFFSET(::radar::messages::DetectionCluster, _impl_.algorithm_parameters_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::radar::messages::Association, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::radar::messages::Association, _impl_.track_id_),
  PROTOBUF_FIELD_OFFSET(::radar::messages::Association, _impl_.detection_id_),
  PROTOBUF_FIELD_OFFSET(::radar::messages::Association, _impl_.score_),
  PROTOBUF_FIELD_OFFSET(::radar::messages::Association, _impl_.distance_),
  PROTOBUF_FIELD_OFFSET(::radar::messages::Association, _impl_.is_valid_),
  PROTOBUF_FIELD_OFFSET(::radar::messages::Association, _impl_.innovation_),
  PROTOBUF_FIELD_OFFSET(::radar::messages::Association, _impl_.innovation_covariance_),
  PROTOBUF_FIELD_OFFSET(::radar::messages::Association, _impl_.likelihood_),
  PROTOBUF_FIELD_OFFSET(::radar::messages::Association, _impl_.algorithm_),
  PROTOBUF_FIELD_OFFSET(::radar::messages::FusionData_SensorWeightsEntry_DoNotUse, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::radar::messages::FusionData_SensorWeightsEntry_DoNotUse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::radar::messages::FusionData_SensorWeightsEntry_DoNotUse, key_),
  PROTOBUF_FIELD_OFFSET(::radar::messages::FusionData_SensorWeightsEntry_DoNotUse, value_),
  0,
  1,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::radar::messages::FusionData, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::radar::messages::FusionData, _impl_.timestamp_),
  PROTOBUF_FIELD_OFFSET(::radar::messages::FusionData, _impl_.fusion_id_),
  PROTOBUF_FIELD_OFFSET(::radar::messages::FusionData, _impl_.fused_tracks_),
  PROTOBUF_FIELD_OFFSET(::radar::messages::FusionData, _impl_.contributing_sensors_),
  PROTOBUF_FIELD_OFFSET(::radar::messages::FusionData, _impl_.sensor_weights_),
  PROTOBUF_FIELD_OFFSET(::radar::messages::FusionData, _impl_.fusion_quality_),
  PROTOBUF_FIELD_OFFSET(::radar::messages::FusionData, _impl_.cross_correlation_),
  PROTOBUF_FIELD_OFFSET(::radar::messages::FusionData, _impl_.redundant_tracks_),
  PROTOBUF_FIELD_OFFSET(::radar::messages::FusionData, _impl_.unique_tracks_),
  PROTOBUF_FIELD_OFFSET(::radar::messages::FusionData, _impl_.position_uncertainty_),
  PROTOBUF_FIELD_OFFSET(::radar::messages::FusionData, _impl_.velocity_uncertainty_),
  PROTOBUF_FIELD_OFFSET(::radar::messages::FusionData, _impl_.fusion_time_ms_),
  PROTOBUF_FIELD_OFFSET(::radar::messages::FusionData, _impl_.fusion_algorithm_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::radar::messages::ThreatAssessment, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::radar::messages::ThreatAssessment, _impl_.track_id_),
  PROTOBUF_FIELD_OFFSET(::radar::messages::ThreatAssessment, _impl_.timestamp_),
  PROTOBUF_FIELD_OFFSET(::radar::messages::ThreatAssessment, _impl_.threat_level_),
  PROTOBUF_FIELD_OFFSET(::radar::messages::ThreatAssessment, _impl_.threat_score_),
  PROTOBUF_FIELD_OFFSET(::radar::messages::ThreatAssessment, _impl_.proximity_factor_),
  PROTOBUF_FIELD_OFFSET(::radar::messages::ThreatAssessment, _impl_.velocity_factor_),
  PROTOBUF_FIELD_OFFSET(::radar::messages::ThreatAssessment, _impl_.trajectory_factor_),
  PROTOBUF_FIELD_OFFSET(::radar::messages::ThreatAssessment, _impl_.classification_factor_),
  PROTOBUF_FIELD_OFFSET(::radar::messages::ThreatAssessment, _impl_.predicted_intercept_),
  PROTOBUF_FIELD_OFFSET(::radar::messages::ThreatAssessment, _impl_.time_to_intercept_seconds_),
  PROTOBUF_FIELD_OFFSET(::radar::messages::ThreatAssessment, _impl_.intercept_probability_),
  PROTOBUF_FIELD_OFFSET(::radar::messages::ThreatAssessment, _impl_.recommended_actions_),
  PROTOBUF_FIELD_OFFSET(::radar::messages::ThreatAssessment, _impl_.priority_),
  PROTOBUF_FIELD_OFFSET(::radar::messages::SystemConfiguration_ClusteringParamsEntry_DoNotUse, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::radar::messages::SystemConfiguration_ClusteringParamsEntry_DoNotUse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::radar::messages::SystemConfiguration_ClusteringParamsEntry_DoNotUse, key_),
  PROTOBUF_FIELD_OFFSET(::radar::messages::SystemConfiguration_ClusteringParamsEntry_DoNotUse, value_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::radar::messages::SystemConfiguration_AssociationParamsEntry_DoNotUse, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::radar::messages::SystemConfiguration_AssociationParamsEntry_DoNotUse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::radar::messages::SystemConfiguration_AssociationParamsEntry_DoNotUse, key_),
  PROTOBUF_FIELD_OFFSET(::radar::messages::SystemConfiguration_AssociationParamsEntry_DoNotUse, value_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::radar::messages::SystemConfiguration_FilterParamsEntry_DoNotUse, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::radar::messages::SystemConfiguration_FilterParamsEntry_DoNotUse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::radar::messages::SystemConfiguration_FilterParamsEntry_DoNotUse, key_),
  PROTOBUF_FIELD_OFFSET(::radar::messages::SystemConfiguration_FilterParamsEntry_DoNotUse, value_),
  0,
  1,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::radar::messages::SystemConfiguration, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::radar::messages::SystemConfiguration, _impl_.timestamp_),
  PROTOBUF_FIELD_OFFSET(::radar::messages::SystemConfiguration, _impl_.clustering_algorithm_),
  PROTOBUF_FIELD_OFFSET(::radar::messages::SystemConfiguration, _impl_.association_algorithm_),
  PROTOBUF_FIELD_OFFSET(::radar::messages::SystemConfiguration, _impl_.filter_algorithm_),
  PROTOBUF_FIELD_OFFSET(::radar::messages::SystemConfiguration, _impl_.clustering_params_),
  PROTOBUF_FIELD_OFFSET(::radar::messages::SystemConfiguration, _impl_.association_params_),
  PROTOBUF_FIELD_OFFSET(::radar::messages::SystemConfiguration, _impl_.filter_params_),
  PROTOBUF_FIELD_OFFSET(::radar::messages::SystemConfiguration, _impl_.update_rate_hz_),
  PROTOBUF_FIELD_OFFSET(::radar::messages::SystemConfiguration, _impl_.max_tracks_),
  PROTOBUF_FIELD_OFFSET(::radar::messages::SystemConfiguration, _impl_.track_timeout_seconds_),
  PROTOBUF_FIELD_OFFSET(::radar::messages::SystemConfiguration, _impl_.confirmation_threshold_),
  PROTOBUF_FIELD_OFFSET(::radar::messages::SystemConfiguration, _impl_.deletion_threshold_),
  PROTOBUF_FIELD_OFFSET(::radar::messages::SystemConfiguration, _impl_.enable_hmi_output_),
  PROTOBUF_FIELD_OFFSET(::radar::messages::SystemConfiguration, _impl_.enable_fusion_output_),
  PROTOBUF_FIELD_OFFSET(::radar::messages::SystemConfiguration, _impl_.enable_logging_),
  PROTOBUF_FIELD_OFFSET(::radar::messages::SystemConfiguration, _impl_.log_level_),
};
static const ::_pbi::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, -1, -1, sizeof(::radar::messages::TrackState)},
  { 13, 21, -1, sizeof(::radar::messages::Track_ClassificationScoresEntry_DoNotUse)},
  { 23, 31, -1, sizeof(::radar::messages::Track_AttributesEntry_DoNotUse)},
  { 33, -1, -1, sizeof(::radar::messages::Track)},
  { 64, -1, -1, sizeof(::radar::messages::TrackBatch)},
  { 84, 92, -1, sizeof(::radar::messages::TrackUpdate_UpdateDataEntry_DoNotUse)},
  { 94, -1, -1, sizeof(::radar::messages::TrackUpdate)},
  { 108, -1, -1, sizeof(::radar::messages::TrackHistory)},
  { 125, 133, -1, sizeof(::radar::messages::DetectionCluster_AlgorithmParametersEntry_DoNotUse)},
  { 135, -1, -1, sizeof(::radar::messages::DetectionCluster)},
  { 152, -1, -1, sizeof(::radar::messages::Association)},
  { 167, 175, -1, sizeof(::radar::messages::FusionData_SensorWeightsEntry_DoNotUse)},
  { 177, -1, -1, sizeof(::radar::messages::FusionData)},
  { 196, -1, -1, sizeof(::radar::messages::ThreatAssessment)},
  { 215, 223, -1, sizeof(::radar::messages::SystemConfiguration_ClusteringParamsEntry_DoNotUse)},
  { 225, 233, -1, sizeof(::radar::messages::SystemConfiguration_AssociationParamsEntry_DoNotUse)},
  { 235, 243, -1, sizeof(::radar::messages::SystemConfiguration_FilterParamsEntry_DoNotUse)},
  { 245, -1, -1, sizeof(::radar::messages::SystemConfiguration)},
};

static const ::_pb::Message* const file_default_instances[] = {
  &::radar::messages::_TrackState_default_instance_._instance,
  &::radar::messages::_Track_ClassificationScoresEntry_DoNotUse_default_instance_._instance,
  &::radar::messages::_Track_AttributesEntry_DoNotUse_default_instance_._instance,
  &::radar::messages::_Track_default_instance_._instance,
  &::radar::messages::_TrackBatch_default_instance_._instance,
  &::radar::messages::_TrackUpdate_UpdateDataEntry_DoNotUse_default_instance_._instance,
  &::radar::messages::_TrackUpdate_default_instance_._instance,
  &::radar::messages::_TrackHistory_default_instance_._instance,
  &::radar::messages::_DetectionCluster_AlgorithmParametersEntry_DoNotUse_default_instance_._instance,
  &::radar::messages::_DetectionCluster_default_instance_._instance,
  &::radar::messages::_Association_default_instance_._instance,
  &::radar::messages::_FusionData_SensorWeightsEntry_DoNotUse_default_instance_._instance,
  &::radar::messages::_FusionData_default_instance_._instance,
  &::radar::messages::_ThreatAssessment_default_instance_._instance,
  &::radar::messages::_SystemConfiguration_ClusteringParamsEntry_DoNotUse_default_instance_._instance,
  &::radar::messages::_SystemConfiguration_AssociationParamsEntry_DoNotUse_default_instance_._instance,
  &::radar::messages::_SystemConfiguration_FilterParamsEntry_DoNotUse_default_instance_._instance,
  &::radar::messages::_SystemConfiguration_default_instance_._instance,
};

const char descriptor_table_protodef_track_5fmessages_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n\024track_messages.proto\022\016radar.messages\032\037"
  "google/protobuf/timestamp.proto\032\024radar_m"
  "essages.proto\"\375\001\n\nTrackState\022\r\n\005state\030\001 "
  "\003(\001\022\022\n\ncovariance\030\002 \003(\001\022\022\n\nstate_size\030\003 "
  "\001(\r\0221\n\014motion_model\030\004 \001(\0162\033.radar.messag"
  "es.MotionModel\022)\n\010position\030\005 \001(\0132\027.radar"
  ".messages.Point3D\022*\n\010velocity\030\006 \001(\0132\030.ra"
  "dar.messages.Vector3D\022.\n\014acceleration\030\007 "
  "\001(\0132\030.radar.messages.Vector3D\"\200\007\n\005Track\022"
  "\n\n\002id\030\001 \001(\r\022\021\n\tsensor_id\030\002 \001(\r\0220\n\014create"
  "d_time\030\003 \001(\0132\032.google.protobuf.Timestamp"
  "\0224\n\020last_update_time\030\004 \001(\0132\032.google.prot"
  "obuf.Timestamp\0221\n\rcurrent_state\030\005 \001(\0132\032."
  "radar.messages.TrackState\0223\n\017predicted_s"
  "tate\030\006 \001(\0132\032.radar.messages.TrackState\022)"
  "\n\005state\030\007 \001(\0132\032.radar.messages.TrackStat"
  "e\022\021\n\thit_count\030\010 \001(\r\022\022\n\nmiss_count\030\t \001(\r"
  "\022\023\n\013coast_count\030\n \001(\r\022\022\n\nconfidence\030\013 \001("
  "\001\022\022\n\nlikelihood\030\014 \001(\001\022/\n\013filter_type\030\r \001"
  "(\0162\032.radar.messages.FilterType\022\024\n\014target"
  "_class\030\016 \001(\t\022N\n\025classification_scores\030\017 "
  "\003(\0132/.radar.messages.Track.Classificatio"
  "nScoresEntry\022\025\n\rtrack_quality\030\020 \001(\001\022\034\n\024i"
  "nnovation_magnitude\030\021 \001(\001\022\034\n\024mahalanobis"
  "_distance\030\022 \001(\001\022\r\n\005speed\030\023 \001(\001\022\017\n\007headin"
  "g\030\024 \001(\001\022\021\n\tturn_rate\030\025 \001(\001\022\r\n\005range\030\026 \001("
  "\001\022\017\n\007bearing\030\027 \001(\001\022\021\n\televation\030\030 \001(\001\0229\n"
  "\nattributes\030\031 \003(\0132%.radar.messages.Track"
  ".AttributesEntry\032;\n\031ClassificationScores"
  "Entry\022\013\n\003key\030\001 \001(\t\022\r\n\005value\030\002 \001(\001:\0028\001\0321\n"
  "\017AttributesEntry\022\013\n\003key\030\001 \001(\t\022\r\n\005value\030\002"
  " \001(\001:\0028\001\"\273\003\n\nTrackBatch\022%\n\006tracks\030\001 \003(\0132"
  "\025.radar.messages.Track\0223\n\017batch_timestam"
  "p\030\002 \001(\0132\032.google.protobuf.Timestamp\022\021\n\ts"
  "ensor_id\030\003 \001(\r\022\027\n\017sequence_number\030\004 \001(\r\022"
  "\032\n\022processing_time_ms\030\005 \001(\001\022\024\n\014total_tra"
  "cks\030\006 \001(\r\022\030\n\020confirmed_tracks\030\007 \001(\r\022\030\n\020t"
  "entative_tracks\030\010 \001(\r\022\027\n\017coasting_tracks"
  "\030\t \001(\r\022\026\n\016deleted_tracks\030\n \001(\r\022\032\n\022total_"
  "associations\030\013 \001(\r\022\037\n\027successful_associa"
  "tions\030\014 \001(\r\022\030\n\020association_rate\030\r \001(\001\0227\n"
  "\013performance\030\016 \001(\0132\".radar.messages.Perf"
  "ormanceMetrics\"\363\003\n\013TrackUpdate\022\020\n\010track_"
  "id\030\001 \001(\r\022\021\n\tsensor_id\030\002 \001(\r\022-\n\ttimestamp"
  "\030\003 \001(\0132\032.google.protobuf.Timestamp\022;\n\013up"
  "date_type\030\004 \001(\0162&.radar.messages.TrackUp"
  "date.UpdateType\022$\n\005track\030\005 \001(\0132\025.radar.m"
  "essages.Track\022\037\n\027associated_detection_id"
  "\030\006 \001(\r\022\031\n\021association_score\030\007 \001(\001\022@\n\013upd"
  "ate_data\030\010 \003(\0132+.radar.messages.TrackUpd"
  "ate.UpdateDataEntry\0321\n\017UpdateDataEntry\022\013"
  "\n\003key\030\001 \001(\t\022\r\n\005value\030\002 \001(\t:\0028\001\"|\n\nUpdate"
  "Type\022\033\n\027UPDATE_TYPE_UNSPECIFIED\020\000\022\t\n\005BIR"
  "TH\020\001\022\n\n\006UPDATE\020\002\022\013\n\007PREDICT\020\003\022\013\n\007CONFIRM"
  "\020\004\022\n\n\006DELETE\020\005\022\t\n\005MERGE\020\006\022\t\n\005SPLIT\020\007\"\346\002\n"
  "\014TrackHistory\022\020\n\010track_id\030\001 \001(\r\022\021\n\tsenso"
  "r_id\030\002 \001(\r\0221\n\rstate_history\030\003 \003(\0132\032.rada"
  "r.messages.TrackState\022.\n\ntimestamps\030\004 \003("
  "\0132\032.google.protobuf.Timestamp\0228\n\025associa"
  "ted_detections\030\005 \003(\0132\031.radar.messages.De"
  "tection\022\025\n\raverage_speed\030\006 \001(\001\022\021\n\tmax_sp"
  "eed\030\007 \001(\001\022\026\n\016total_distance\030\010 \001(\001\022\032\n\022tot"
  "al_time_seconds\030\t \001(\001\022\032\n\022confidence_hist"
  "ory\030\n \003(\001\022\032\n\022likelihood_history\030\013 \003(\001\"\227\005"
  "\n\020DetectionCluster\022\n\n\002id\030\001 \001(\r\022-\n\ndetect"
  "ions\030\002 \003(\0132\031.radar.messages.Detection\022)\n"
  "\010centroid\030\003 \001(\0132\027.radar.messages.Point3D"
  "\022,\n\ncovariance\030\004 \001(\0132\030.radar.messages.Ma"
  "trix3D\022-\n\ttimestamp\030\005 \001(\0132\032.google.proto"
  "buf.Timestamp\022G\n\talgorithm\030\006 \001(\01624.radar"
  ".messages.DetectionCluster.ClusteringAlg"
  "orithm\022\027\n\017detection_count\030\007 \001(\r\022\026\n\016clust"
  "er_radius\030\010 \001(\001\022\027\n\017cluster_density\030\t \001(\001"
  "\022\032\n\022processing_time_ms\030\n \001(\001\022W\n\024algorith"
  "m_parameters\030\013 \003(\01329.radar.messages.Dete"
  "ctionCluster.AlgorithmParametersEntry\032:\n"
  "\030AlgorithmParametersEntry\022\013\n\003key\030\001 \001(\t\022\r"
  "\n\005value\030\002 \001(\001:\0028\001\"|\n\023ClusteringAlgorithm"
  "\022$\n CLUSTERING_ALGORITHM_UNSPECIFIED\020\000\022\n"
  "\n\006DBSCAN\020\001\022\n\n\006KMEANS\020\002\022\020\n\014HIERARCHICAL\020\003"
  "\022\025\n\021CLUSTERING_CUSTOM\020\004\"\345\003\n\013Association\022"
  "\020\n\010track_id\030\001 \001(\r\022\024\n\014detection_id\030\002 \001(\r\022"
  "\r\n\005score\030\003 \001(\001\022\020\n\010distance\030\004 \001(\001\022\020\n\010is_v"
  "alid\030\005 \001(\010\022,\n\ninnovation\030\006 \001(\0132\030.radar.m"
  "essages.Vector3D\0227\n\025innovation_covarianc"
  "e\030\007 \001(\0132\030.radar.messages.Matrix3D\022\022\n\nlik"
  "elihood\030\010 \001(\001\022C\n\talgorithm\030\t \001(\01620.radar"
  ".messages.Association.AssociationAlgorit"
  "hm\"\272\001\n\024AssociationAlgorithm\022%\n!ASSOCIATI"
  "ON_ALGORITHM_UNSPECIFIED\020\000\022\024\n\020NEAREST_NE"
  "IGHBOR\020\001\022\033\n\027GLOBAL_NEAREST_NEIGHBOR\020\002\022\027\n"
  "\023JOINT_PROBABILISTIC\020\003\022\027\n\023MULTIPLE_HYPOT"
  "HESIS\020\004\022\026\n\022ASSOCIATION_CUSTOM\020\005\"\350\003\n\nFusi"
  "onData\022-\n\ttimestamp\030\001 \001(\0132\032.google.proto"
  "buf.Timestamp\022\021\n\tfusion_id\030\002 \001(\r\022+\n\014fuse"
  "d_tracks\030\003 \003(\0132\025.radar.messages.Track\022\034\n"
  "\024contributing_sensors\030\004 \003(\r\022E\n\016sensor_we"
  "ights\030\005 \003(\0132-.radar.messages.FusionData."
  "SensorWeightsEntry\022\026\n\016fusion_quality\030\006 \001"
  "(\001\022\031\n\021cross_correlation\030\007 \001(\001\022\030\n\020redunda"
  "nt_tracks\030\010 \001(\r\022\025\n\runique_tracks\030\t \001(\r\022\034"
  "\n\024position_uncertainty\030\n \001(\001\022\034\n\024velocity"
  "_uncertainty\030\013 \001(\001\022\026\n\016fusion_time_ms\030\014 \001"
  "(\001\022\030\n\020fusion_algorithm\030\r \001(\t\0324\n\022SensorWe"
  "ightsEntry\022\013\n\003key\030\001 \001(\r\022\r\n\005value\030\002 \001(\001:\002"
  "8\001\"\233\004\n\020ThreatAssessment\022\020\n\010track_id\030\001 \001("
  "\r\022-\n\ttimestamp\030\002 \001(\0132\032.google.protobuf.T"
  "imestamp\022B\n\014threat_level\030\003 \001(\0162,.radar.m"
  "essages.ThreatAssessment.ThreatLevel\022\024\n\014"
  "threat_score\030\004 \001(\001\022\030\n\020proximity_factor\030\005"
  " \001(\001\022\027\n\017velocity_factor\030\006 \001(\001\022\031\n\021traject"
  "ory_factor\030\007 \001(\001\022\035\n\025classification_facto"
  "r\030\010 \001(\001\0224\n\023predicted_intercept\030\t \001(\0132\027.r"
  "adar.messages.Point3D\022!\n\031time_to_interce"
  "pt_seconds\030\n \001(\001\022\035\n\025intercept_probabilit"
  "y\030\013 \001(\001\022\033\n\023recommended_actions\030\014 \003(\t\022\020\n\010"
  "priority\030\r \001(\t\"X\n\013ThreatLevel\022\034\n\030THREAT_"
  "LEVEL_UNSPECIFIED\020\000\022\007\n\003LOW\020\001\022\n\n\006MEDIUM\020\002"
  "\022\010\n\004HIGH\020\003\022\014\n\010CRITICAL\020\004\"\252\006\n\023SystemConfi"
  "guration\022-\n\ttimestamp\030\001 \001(\0132\032.google.pro"
  "tobuf.Timestamp\022\034\n\024clustering_algorithm\030"
  "\002 \001(\t\022\035\n\025association_algorithm\030\003 \001(\t\022\030\n\020"
  "filter_algorithm\030\004 \001(\t\022T\n\021clustering_par"
  "ams\030\005 \003(\01329.radar.messages.SystemConfigu"
  "ration.ClusteringParamsEntry\022V\n\022associat"
  "ion_params\030\006 \003(\0132:.radar.messages.System"
  "Configuration.AssociationParamsEntry\022L\n\r"
  "filter_params\030\007 \003(\01325.radar.messages.Sys"
  "temConfiguration.FilterParamsEntry\022\026\n\016up"
  "date_rate_hz\030\010 \001(\001\022\022\n\nmax_tracks\030\t \001(\r\022\035"
  "\n\025track_timeout_seconds\030\n \001(\001\022\036\n\026confirm"
  "ation_threshold\030\013 \001(\001\022\032\n\022deletion_thresh"
  "old\030\014 \001(\001\022\031\n\021enable_hmi_output\030\r \001(\010\022\034\n\024"
  "enable_fusion_output\030\016 \001(\010\022\026\n\016enable_log"
  "ging\030\017 \001(\010\022\021\n\tlog_level\030\020 \001(\t\0327\n\025Cluster"
  "ingParamsEntry\022\013\n\003key\030\001 \001(\t\022\r\n\005value\030\002 \001"
  "(\001:\0028\001\0328\n\026AssociationParamsEntry\022\013\n\003key\030"
  "\001 \001(\t\022\r\n\005value\030\002 \001(\001:\0028\001\0323\n\021FilterParams"
  "Entry\022\013\n\003key\030\001 \001(\t\022\r\n\005value\030\002 \001(\001:\0028\001*\212\001"
  "\n\nFilterType\022\033\n\027FILTER_TYPE_UNSPECIFIED\020"
  "\000\022\n\n\006KALMAN\020\001\022\023\n\017EXTENDED_KALMAN\020\002\022\024\n\020UN"
  "SCENTED_KALMAN\020\003\022\007\n\003IMM\020\004\022\014\n\010PARTICLE\020\005\022"
  "\021\n\rFILTER_CUSTOM\020\006b\006proto3"
  ;
static const ::_pbi::DescriptorTable* const descriptor_table_track_5fmessages_2eproto_deps[2] = {
  &::descriptor_table_google_2fprotobuf_2ftimestamp_2eproto,
  &::descriptor_table_radar_5fmessages_2eproto,
};
static ::_pbi::once_flag descriptor_table_track_5fmessages_2eproto_once;
const ::_pbi::DescriptorTable descriptor_table_track_5fmessages_2eproto = {
    false, false, 5706, descriptor_table_protodef_track_5fmessages_2eproto,
    "track_messages.proto",
    &descriptor_table_track_5fmessages_2eproto_once, descriptor_table_track_5fmessages_2eproto_deps, 2, 18,
    schemas, file_default_instances, TableStruct_track_5fmessages_2eproto::offsets,
    file_level_metadata_track_5fmessages_2eproto, file_level_enum_descriptors_track_5fmessages_2eproto,
    file_level_service_descriptors_track_5fmessages_2eproto,
};
PROTOBUF_ATTRIBUTE_WEAK const ::_pbi::DescriptorTable* descriptor_table_track_5fmessages_2eproto_getter() {
  return &descriptor_table_track_5fmessages_2eproto;
}

// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY2 static ::_pbi::AddDescriptorsRunner dynamic_init_dummy_track_5fmessages_2eproto(&descriptor_table_track_5fmessages_2eproto);
namespace radar {
namespace messages {
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TrackUpdate_UpdateType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_track_5fmessages_2eproto);
  return file_level_enum_descriptors_track_5fmessages_2eproto[0];
}
bool TrackUpdate_UpdateType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr TrackUpdate_UpdateType TrackUpdate::UPDATE_TYPE_UNSPECIFIED;
constexpr TrackUpdate_UpdateType TrackUpdate::BIRTH;
constexpr TrackUpdate_UpdateType TrackUpdate::UPDATE;
constexpr TrackUpdate_UpdateType TrackUpdate::PREDICT;
constexpr TrackUpdate_UpdateType TrackUpdate::CONFIRM;
constexpr TrackUpdate_UpdateType TrackUpdate::DELETE;
constexpr TrackUpdate_UpdateType TrackUpdate::MERGE;
constexpr TrackUpdate_UpdateType TrackUpdate::SPLIT;
constexpr TrackUpdate_UpdateType TrackUpdate::UpdateType_MIN;
constexpr TrackUpdate_UpdateType TrackUpdate::UpdateType_MAX;
constexpr int TrackUpdate::UpdateType_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* DetectionCluster_ClusteringAlgorithm_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_track_5fmessages_2eproto);
  return file_level_enum_descriptors_track_5fmessages_2eproto[1];
}
bool DetectionCluster_ClusteringAlgorithm_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr DetectionCluster_ClusteringAlgorithm DetectionCluster::CLUSTERING_ALGORITHM_UNSPECIFIED;
constexpr DetectionCluster_ClusteringAlgorithm DetectionCluster::DBSCAN;
constexpr DetectionCluster_ClusteringAlgorithm DetectionCluster::KMEANS;
constexpr DetectionCluster_ClusteringAlgorithm DetectionCluster::HIERARCHICAL;
constexpr DetectionCluster_ClusteringAlgorithm DetectionCluster::CLUSTERING_CUSTOM;
constexpr DetectionCluster_ClusteringAlgorithm DetectionCluster::ClusteringAlgorithm_MIN;
constexpr DetectionCluster_ClusteringAlgorithm DetectionCluster::ClusteringAlgorithm_MAX;
constexpr int DetectionCluster::ClusteringAlgorithm_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Association_AssociationAlgorithm_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_track_5fmessages_2eproto);
  return file_level_enum_descriptors_track_5fmessages_2eproto[2];
}
bool Association_AssociationAlgorithm_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr Association_AssociationAlgorithm Association::ASSOCIATION_ALGORITHM_UNSPECIFIED;
constexpr Association_AssociationAlgorithm Association::NEAREST_NEIGHBOR;
constexpr Association_AssociationAlgorithm Association::GLOBAL_NEAREST_NEIGHBOR;
constexpr Association_AssociationAlgorithm Association::JOINT_PROBABILISTIC;
constexpr Association_AssociationAlgorithm Association::MULTIPLE_HYPOTHESIS;
constexpr Association_AssociationAlgorithm Association::ASSOCIATION_CUSTOM;
constexpr Association_AssociationAlgorithm Association::AssociationAlgorithm_MIN;
constexpr Association_AssociationAlgorithm Association::AssociationAlgorithm_MAX;
constexpr int Association::AssociationAlgorithm_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ThreatAssessment_ThreatLevel_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_track_5fmessages_2eproto);
  return file_level_enum_descriptors_track_5fmessages_2eproto[3];
}
bool ThreatAssessment_ThreatLevel_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr ThreatAssessment_ThreatLevel ThreatAssessment::THREAT_LEVEL_UNSPECIFIED;
constexpr ThreatAssessment_ThreatLevel ThreatAssessment::LOW;
constexpr ThreatAssessment_ThreatLevel ThreatAssessment::MEDIUM;
constexpr ThreatAssessment_ThreatLevel ThreatAssessment::HIGH;
constexpr ThreatAssessment_ThreatLevel ThreatAssessment::CRITICAL;
constexpr ThreatAssessment_ThreatLevel ThreatAssessment::ThreatLevel_MIN;
constexpr ThreatAssessment_ThreatLevel ThreatAssessment::ThreatLevel_MAX;
constexpr int ThreatAssessment::ThreatLevel_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* FilterType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_track_5fmessages_2eproto);
  return file_level_enum_descriptors_track_5fmessages_2eproto[4];
}
bool FilterType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
      return true;
    default:
      return false;
  }
}


// ===================================================================

class TrackState::_Internal {
 public:
  static const ::radar::messages::Point3D& position(const TrackState* msg);
  static const ::radar::messages::Vector3D& velocity(const TrackState* msg);
  static const ::radar::messages::Vector3D& acceleration(const TrackState* msg);
};

const ::radar::messages::Point3D&
TrackState::_Internal::position(const TrackState* msg) {
  return *msg->_impl_.position_;
}
const ::radar::messages::Vector3D&
TrackState::_Internal::velocity(const TrackState* msg) {
  return *msg->_impl_.velocity_;
}
const ::radar::messages::Vector3D&
TrackState::_Internal::acceleration(const TrackState* msg) {
  return *msg->_impl_.acceleration_;
}
void TrackState::clear_position() {
  if (GetArenaForAllocation() == nullptr && _impl_.position_ != nullptr) {
    delete _impl_.position_;
  }
  _impl_.position_ = nullptr;
}
void TrackState::clear_velocity() {
  if (GetArenaForAllocation() == nullptr && _impl_.velocity_ != nullptr) {
    delete _impl_.velocity_;
  }
  _impl_.velocity_ = nullptr;
}
void TrackState::clear_acceleration() {
  if (GetArenaForAllocation() == nullptr && _impl_.acceleration_ != nullptr) {
    delete _impl_.acceleration_;
  }
  _impl_.acceleration_ = nullptr;
}
TrackState::TrackState(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:radar.messages.TrackState)
}
TrackState::TrackState(const TrackState& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  TrackState* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.state_){from._impl_.state_}
    , decltype(_impl_.covariance_){from._impl_.covariance_}
    , decltype(_impl_.position_){nullptr}
    , decltype(_impl_.velocity_){nullptr}
    , decltype(_impl_.acceleration_){nullptr}
    , decltype(_impl_.state_size_){}
    , decltype(_impl_.motion_model_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_position()) {
    _this->_impl_.position_ = new ::radar::messages::Point3D(*from._impl_.position_);
  }
  if (from._internal_has_velocity()) {
    _this->_impl_.velocity_ = new ::radar::messages::Vector3D(*from._impl_.velocity_);
  }
  if (from._internal_has_acceleration()) {
    _this->_impl_.acceleration_ = new ::radar::messages::Vector3D(*from._impl_.acceleration_);
  }
  ::memcpy(&_impl_.state_size_, &from._impl_.state_size_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.motion_model_) -
    reinterpret_cast<char*>(&_impl_.state_size_)) + sizeof(_impl_.motion_model_));
  // @@protoc_insertion_point(copy_constructor:radar.messages.TrackState)
}

inline void TrackState::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.state_){arena}
    , decltype(_impl_.covariance_){arena}
    , decltype(_impl_.position_){nullptr}
    , decltype(_impl_.velocity_){nullptr}
    , decltype(_impl_.acceleration_){nullptr}
    , decltype(_impl_.state_size_){0u}
    , decltype(_impl_.motion_model_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

TrackState::~TrackState() {
  // @@protoc_insertion_point(destructor:radar.messages.TrackState)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TrackState::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.state_.~RepeatedField();
  _impl_.covariance_.~RepeatedField();
  if (this != internal_default_instance()) delete _impl_.position_;
  if (this != internal_default_instance()) delete _impl_.velocity_;
  if (this != internal_default_instance()) delete _impl_.acceleration_;
}

void TrackState::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TrackState::Clear() {
// @@protoc_insertion_point(message_clear_start:radar.messages.TrackState)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.state_.Clear();
  _impl_.covariance_.Clear();
  if (GetArenaForAllocation() == nullptr && _impl_.position_ != nullptr) {
    delete _impl_.position_;
  }
  _impl_.position_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.velocity_ != nullptr) {
    delete _impl_.velocity_;
  }
  _impl_.velocity_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.acceleration_ != nullptr) {
    delete _impl_.acceleration_;
  }
  _impl_.acceleration_ = nullptr;
  ::memset(&_impl_.state_size_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.motion_model_) -
      reinterpret_cast<char*>(&_impl_.state_size_)) + sizeof(_impl_.motion_model_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TrackState::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated double state = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedDoubleParser(_internal_mutable_state(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 9) {
          _internal_add_state(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr));
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // repeated double covariance = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedDoubleParser(_internal_mutable_covariance(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 17) {
          _internal_add_covariance(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr));
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // uint32 state_size = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.state_size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .radar.messages.MotionModel motion_model = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_motion_model(static_cast<::radar::messages::MotionModel>(val));
        } else
          goto handle_unusual;
        continue;
      // .radar.messages.Point3D position = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_position(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .radar.messages.Vector3D velocity = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_velocity(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .radar.messages.Vector3D acceleration = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_acceleration(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TrackState::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:radar.messages.TrackState)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated double state = 1;
  if (this->_internal_state_size() > 0) {
    target = stream->WriteFixedPacked(1, _internal_state(), target);
  }

  // repeated double covariance = 2;
  if (this->_internal_covariance_size() > 0) {
    target = stream->WriteFixedPacked(2, _internal_covariance(), target);
  }

  // uint32 state_size = 3;
  if (this->_internal_state_size() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_state_size(), target);
  }

  // .radar.messages.MotionModel motion_model = 4;
  if (this->_internal_motion_model() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      4, this->_internal_motion_model(), target);
  }

  // .radar.messages.Point3D position = 5;
  if (this->_internal_has_position()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::position(this),
        _Internal::position(this).GetCachedSize(), target, stream);
  }

  // .radar.messages.Vector3D velocity = 6;
  if (this->_internal_has_velocity()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, _Internal::velocity(this),
        _Internal::velocity(this).GetCachedSize(), target, stream);
  }

  // .radar.messages.Vector3D acceleration = 7;
  if (this->_internal_has_acceleration()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(7, _Internal::acceleration(this),
        _Internal::acceleration(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:radar.messages.TrackState)
  return target;
}

size_t TrackState::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:radar.messages.TrackState)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated double state = 1;
  {
    unsigned int count = static_cast<unsigned int>(this->_internal_state_size());
    size_t data_size = 8UL * count;
    if (data_size > 0) {
      total_size += 1 +
        ::_pbi::WireFormatLite::Int32Size(static_cast<int32_t>(data_size));
    }
    total_size += data_size;
  }

  // repeated double covariance = 2;
  {
    unsigned int count = static_cast<unsigned int>(this->_internal_covariance_size());
    size_t data_size = 8UL * count;
    if (data_size > 0) {
      total_size += 1 +
        ::_pbi::WireFormatLite::Int32Size(static_cast<int32_t>(data_size));
    }
    total_size += data_size;
  }

  // .radar.messages.Point3D position = 5;
  if (this->_internal_has_position()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.position_);
  }

  // .radar.messages.Vector3D velocity = 6;
  if (this->_internal_has_velocity()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.velocity_);
  }

  // .radar.messages.Vector3D acceleration = 7;
  if (this->_internal_has_acceleration()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.acceleration_);
  }

  // uint32 state_size = 3;
  if (this->_internal_state_size() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_state_size());
  }

  // .radar.messages.MotionModel motion_model = 4;
  if (this->_internal_motion_model() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_motion_model());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData TrackState::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    TrackState::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*TrackState::GetClassData() const { return &_class_data_; }


void TrackState::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<TrackState*>(&to_msg);
  auto& from = static_cast<const TrackState&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:radar.messages.TrackState)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.state_.MergeFrom(from._impl_.state_);
  _this->_impl_.covariance_.MergeFrom(from._impl_.covariance_);
  if (from._internal_has_position()) {
    _this->_internal_mutable_position()->::radar::messages::Point3D::MergeFrom(
        from._internal_position());
  }
  if (from._internal_has_velocity()) {
    _this->_internal_mutable_velocity()->::radar::messages::Vector3D::MergeFrom(
        from._internal_velocity());
  }
  if (from._internal_has_acceleration()) {
    _this->_internal_mutable_acceleration()->::radar::messages::Vector3D::MergeFrom(
        from._internal_acceleration());
  }
  if (from._internal_state_size() != 0) {
    _this->_internal_set_state_size(from._internal_state_size());
  }
  if (from._internal_motion_model() != 0) {
    _this->_internal_set_motion_model(from._internal_motion_model());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void TrackState::CopyFrom(const TrackState& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:radar.messages.TrackState)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TrackState::IsInitialized() const {
  return true;
}

void TrackState::InternalSwap(TrackState* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.state_.InternalSwap(&other->_impl_.state_);
  _impl_.covariance_.InternalSwap(&other->_impl_.covariance_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TrackState, _impl_.motion_model_)
      + sizeof(TrackState::_impl_.motion_model_)
      - PROTOBUF_FIELD_OFFSET(TrackState, _impl_.position_)>(
          reinterpret_cast<char*>(&_impl_.position_),
          reinterpret_cast<char*>(&other->_impl_.position_));
}

::PROTOBUF_NAMESPACE_ID::Metadata TrackState::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_track_5fmessages_2eproto_getter, &descriptor_table_track_5fmessages_2eproto_once,
      file_level_metadata_track_5fmessages_2eproto[0]);
}

// ===================================================================

Track_ClassificationScoresEntry_DoNotUse::Track_ClassificationScoresEntry_DoNotUse() {}
Track_ClassificationScoresEntry_DoNotUse::Track_ClassificationScoresEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
    : SuperType(arena) {}
void Track_ClassificationScoresEntry_DoNotUse::MergeFrom(const Track_ClassificationScoresEntry_DoNotUse& other) {
  MergeFromInternal(other);
}
::PROTOBUF_NAMESPACE_ID::Metadata Track_ClassificationScoresEntry_DoNotUse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_track_5fmessages_2eproto_getter, &descriptor_table_track_5fmessages_2eproto_once,
      file_level_metadata_track_5fmessages_2eproto[1]);
}

// ===================================================================

Track_AttributesEntry_DoNotUse::Track_AttributesEntry_DoNotUse() {}
Track_AttributesEntry_DoNotUse::Track_AttributesEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
    : SuperType(arena) {}
void Track_AttributesEntry_DoNotUse::MergeFrom(const Track_AttributesEntry_DoNotUse& other) {
  MergeFromInternal(other);
}
::PROTOBUF_NAMESPACE_ID::Metadata Track_AttributesEntry_DoNotUse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_track_5fmessages_2eproto_getter, &descriptor_table_track_5fmessages_2eproto_once,
      file_level_metadata_track_5fmessages_2eproto[2]);
}

// ===================================================================

class Track::_Internal {
 public:
  static const ::PROTOBUF_NAMESPACE_ID::Timestamp& created_time(const Track* msg);
  static const ::PROTOBUF_NAMESPACE_ID::Timestamp& last_update_time(const Track* msg);
  static const ::radar::messages::TrackState& current_state(const Track* msg);
  static const ::radar::messages::TrackState& predicted_state(const Track* msg);
  static const ::radar::messages::TrackState& state(const Track* msg);
};

const ::PROTOBUF_NAMESPACE_ID::Timestamp&
Track::_Internal::created_time(const Track* msg) {
  return *msg->_impl_.created_time_;
}
const ::PROTOBUF_NAMESPACE_ID::Timestamp&
Track::_Internal::last_update_time(const Track* msg) {
  return *msg->_impl_.last_update_time_;
}
const ::radar::messages::TrackState&
Track::_Internal::current_state(const Track* msg) {
  return *msg->_impl_.current_state_;
}
const ::radar::messages::TrackState&
Track::_Internal::predicted_state(const Track* msg) {
  return *msg->_impl_.predicted_state_;
}
const ::radar::messages::TrackState&
Track::_Internal::state(const Track* msg) {
  return *msg->_impl_.state_;
}
void Track::clear_created_time() {
  if (GetArenaForAllocation() == nullptr && _impl_.created_time_ != nullptr) {
    delete _impl_.created_time_;
  }
  _impl_.created_time_ = nullptr;
}
void Track::clear_last_update_time() {
  if (GetArenaForAllocation() == nullptr && _impl_.last_update_time_ != nullptr) {
    delete _impl_.last_update_time_;
  }
  _impl_.last_update_time_ = nullptr;
}
Track::Track(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  if (arena != nullptr && !is_message_owned) {
    arena->OwnCustomDestructor(this, &Track::ArenaDtor);
  }
  // @@protoc_insertion_point(arena_constructor:radar.messages.Track)
}
Track::Track(const Track& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Track* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      /*decltype(_impl_.classification_scores_)*/{}
    , /*decltype(_impl_.attributes_)*/{}
    , decltype(_impl_.target_class_){}
    , decltype(_impl_.created_time_){nullptr}
    , decltype(_impl_.last_update_time_){nullptr}
    , decltype(_impl_.current_state_){nullptr}
    , decltype(_impl_.predicted_state_){nullptr}
    , decltype(_impl_.state_){nullptr}
    , decltype(_impl_.id_){}
    , decltype(_impl_.sensor_id_){}
    , decltype(_impl_.hit_count_){}
    , decltype(_impl_.miss_count_){}
    , decltype(_impl_.confidence_){}
    , decltype(_impl_.coast_count_){}
    , decltype(_impl_.filter_type_){}
    , decltype(_impl_.likelihood_){}
    , decltype(_impl_.track_quality_){}
    , decltype(_impl_.innovation_magnitude_){}
    , decltype(_impl_.mahalanobis_distance_){}
    , decltype(_impl_.speed_){}
    , decltype(_impl_.heading_){}
    , decltype(_impl_.turn_rate_){}
    , decltype(_impl_.range_){}
    , decltype(_impl_.bearing_){}
    , decltype(_impl_.elevation_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.classification_scores_.MergeFrom(from._impl_.classification_scores_);
  _this->_impl_.attributes_.MergeFrom(from._impl_.attributes_);
  _impl_.target_class_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.target_class_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_target_class().empty()) {
    _this->_impl_.target_class_.Set(from._internal_target_class(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_created_time()) {
    _this->_impl_.created_time_ = new ::PROTOBUF_NAMESPACE_ID::Timestamp(*from._impl_.created_time_);
  }
  if (from._internal_has_last_update_time()) {
    _this->_impl_.last_update_time_ = new ::PROTOBUF_NAMESPACE_ID::Timestamp(*from._impl_.last_update_time_);
  }
  if (from._internal_has_current_state()) {
    _this->_impl_.current_state_ = new ::radar::messages::TrackState(*from._impl_.current_state_);
  }
  if (from._internal_has_predicted_state()) {
    _this->_impl_.predicted_state_ = new ::radar::messages::TrackState(*from._impl_.predicted_state_);
  }
  if (from._internal_has_state()) {
    _this->_impl_.state_ = new ::radar::messages::TrackState(*from._impl_.state_);
  }
  ::memcpy(&_impl_.id_, &from._impl_.id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.elevation_) -
    reinterpret_cast<char*>(&_impl_.id_)) + sizeof(_impl_.elevation_));
  // @@protoc_insertion_point(copy_constructor:radar.messages.Track)
}

inline void Track::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      /*decltype(_impl_.classification_scores_)*/{::_pbi::ArenaInitialized(), arena}
    , /*decltype(_impl_.attributes_)*/{::_pbi::ArenaInitialized(), arena}
    , decltype(_impl_.target_class_){}
    , decltype(_impl_.created_time_){nullptr}
    , decltype(_impl_.last_update_time_){nullptr}
    , decltype(_impl_.current_state_){nullptr}
    , decltype(_impl_.predicted_state_){nullptr}
    , decltype(_impl_.state_){nullptr}
    , decltype(_impl_.id_){0u}
    , decltype(_impl_.sensor_id_){0u}
    , decltype(_impl_.hit_count_){0u}
    , decltype(_impl_.miss_count_){0u}
    , decltype(_impl_.confidence_){0}
    , decltype(_impl_.coast_count_){0u}
    , decltype(_impl_.filter_type_){0}
    , decltype(_impl_.likelihood_){0}
    , decltype(_impl_.track_quality_){0}
    , decltype(_impl_.innovation_magnitude_){0}
    , decltype(_impl_.mahalanobis_distance_){0}
    , decltype(_impl_.speed_){0}
    , decltype(_impl_.heading_){0}
    , decltype(_impl_.turn_rate_){0}
    , decltype(_impl_.range_){0}
    , decltype(_impl_.bearing_){0}
    , decltype(_impl_.elevation_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.target_class_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.target_class_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Track::~Track() {
  // @@protoc_insertion_point(destructor:radar.messages.Track)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    ArenaDtor(this);
    return;
  }
  SharedDtor();
}

inline void Track::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.classification_scores_.Destruct();
  _impl_.classification_scores_.~MapField();
  _impl_.attributes_.Destruct();
  _impl_.attributes_.~MapField();
  _impl_.target_class_.Destroy();
  if (this != internal_default_instance()) delete _impl_.created_time_;
  if (this != internal_default_instance()) delete _impl_.last_update_time_;
  if (this != internal_default_instance()) delete _impl_.current_state_;
  if (this != internal_default_instance()) delete _impl_.predicted_state_;
  if (this != internal_default_instance()) delete _impl_.state_;
}

void Track::ArenaDtor(void* object) {
  Track* _this = reinterpret_cast< Track* >(object);
  _this->_impl_.classification_scores_.Destruct();
  _this->_impl_.attributes_.Destruct();
}
void Track::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Track::Clear() {
// @@protoc_insertion_point(message_clear_start:radar.messages.Track)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.classification_scores_.Clear();
  _impl_.attributes_.Clear();
  _impl_.target_class_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && _impl_.created_time_ != nullptr) {
    delete _impl_.created_time_;
  }
  _impl_.created_time_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.last_update_time_ != nullptr) {
    delete _impl_.last_update_time_;
  }
  _impl_.last_update_time_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.current_state_ != nullptr) {
    delete _impl_.current_state_;
  }
  _impl_.current_state_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.predicted_state_ != nullptr) {
    delete _impl_.predicted_state_;
  }
  _impl_.predicted_state_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.state_ != nullptr) {
    delete _impl_.state_;
  }
  _impl_.state_ = nullptr;
  ::memset(&_impl_.id_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.elevation_) -
      reinterpret_cast<char*>(&_impl_.id_)) + sizeof(_impl_.elevation_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Track::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint32 id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 sensor_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.sensor_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .google.protobuf.Timestamp created_time = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_created_time(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .google.protobuf.Timestamp last_update_time = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_last_update_time(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .radar.messages.TrackState current_state = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_current_state(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .radar.messages.TrackState predicted_state = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_predicted_state(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .radar.messages.TrackState state = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_state(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 hit_count = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _impl_.hit_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 miss_count = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _impl_.miss_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 coast_count = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          _impl_.coast_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // double confidence = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 89)) {
          _impl_.confidence_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double likelihood = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 97)) {
          _impl_.likelihood_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // .radar.messages.FilterType filter_type = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 104)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_filter_type(static_cast<::radar::messages::FilterType>(val));
        } else
          goto handle_unusual;
        continue;
      // string target_class = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 114)) {
          auto str = _internal_mutable_target_class();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "radar.messages.Track.target_class"));
        } else
          goto handle_unusual;
        continue;
      // map<string, double> classification_scores = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 122)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(&_impl_.classification_scores_, ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<122>(ptr));
        } else
          goto handle_unusual;
        continue;
      // double track_quality = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 129)) {
          _impl_.track_quality_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double innovation_magnitude = 17;
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 137)) {
          _impl_.innovation_magnitude_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double mahalanobis_distance = 18;
      case 18:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 145)) {
          _impl_.mahalanobis_distance_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double speed = 19;
      case 19:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 153)) {
          _impl_.speed_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double heading = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 161)) {
          _impl_.heading_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double turn_rate = 21;
      case 21:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 169)) {
          _impl_.turn_rate_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double range = 22;
      case 22:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 177)) {
          _impl_.range_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double bearing = 23;
      case 23:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 185)) {
          _impl_.bearing_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double elevation = 24;
      case 24:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 193)) {
          _impl_.elevation_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // map<string, double> attributes = 25;
      case 25:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 202)) {
          ptr -= 2;
          do {
            ptr += 2;
            ptr = ctx->ParseMessage(&_impl_.attributes_, ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<202>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Track::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:radar.messages.Track)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint32 id = 1;
  if (this->_internal_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_id(), target);
  }

  // uint32 sensor_id = 2;
  if (this->_internal_sensor_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_sensor_id(), target);
  }

  // .google.protobuf.Timestamp created_time = 3;
  if (this->_internal_has_created_time()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::created_time(this),
        _Internal::created_time(this).GetCachedSize(), target, stream);
  }

  // .google.protobuf.Timestamp last_update_time = 4;
  if (this->_internal_has_last_update_time()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::last_update_time(this),
        _Internal::last_update_time(this).GetCachedSize(), target, stream);
  }

  // .radar.messages.TrackState current_state = 5;
  if (this->_internal_has_current_state()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::current_state(this),
        _Internal::current_state(this).GetCachedSize(), target, stream);
  }

  // .radar.messages.TrackState predicted_state = 6;
  if (this->_internal_has_predicted_state()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, _Internal::predicted_state(this),
        _Internal::predicted_state(this).GetCachedSize(), target, stream);
  }

  // .radar.messages.TrackState state = 7;
  if (this->_internal_has_state()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(7, _Internal::state(this),
        _Internal::state(this).GetCachedSize(), target, stream);
  }

  // uint32 hit_count = 8;
  if (this->_internal_hit_count() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(8, this->_internal_hit_count(), target);
  }

  // uint32 miss_count = 9;
  if (this->_internal_miss_count() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(9, this->_internal_miss_count(), target);
  }

  // uint32 coast_count = 10;
  if (this->_internal_coast_count() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(10, this->_internal_coast_count(), target);
  }

  // double confidence = 11;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_confidence = this->_internal_confidence();
  uint64_t raw_confidence;
  memcpy(&raw_confidence, &tmp_confidence, sizeof(tmp_confidence));
  if (raw_confidence != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(11, this->_internal_confidence(), target);
  }

  // double likelihood = 12;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_likelihood = this->_internal_likelihood();
  uint64_t raw_likelihood;
  memcpy(&raw_likelihood, &tmp_likelihood, sizeof(tmp_likelihood));
  if (raw_likelihood != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(12, this->_internal_likelihood(), target);
  }

  // .radar.messages.FilterType filter_type = 13;
  if (this->_internal_filter_type() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      13, this->_internal_filter_type(), target);
  }

  // string target_class = 14;
  if (!this->_internal_target_class().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_target_class().data(), static_cast<int>(this->_internal_target_class().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "radar.messages.Track.target_class");
    target = stream->WriteStringMaybeAliased(
        14, this->_internal_target_class(), target);
  }

  // map<string, double> classification_scores = 15;
  if (!this->_internal_classification_scores().empty()) {
    using MapType = ::_pb::Map<std::string, double>;
    using WireHelper = Track_ClassificationScoresEntry_DoNotUse::Funcs;
    const auto& map_field = this->_internal_classification_scores();
    auto check_utf8 = [](const MapType::value_type& entry) {
      (void)entry;
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        entry.first.data(), static_cast<int>(entry.first.length()),
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
        "radar.messages.Track.ClassificationScoresEntry.key");
    };

    if (stream->IsSerializationDeterministic() && map_field.size() > 1) {
      for (const auto& entry : ::_pbi::MapSorterPtr<MapType>(map_field)) {
        target = WireHelper::InternalSerialize(15, entry.first, entry.second, target, stream);
        check_utf8(entry);
      }
    } else {
      for (const auto& entry : map_field) {
        target = WireHelper::InternalSerialize(15, entry.first, entry.second, target, stream);
        check_utf8(entry);
      }
    }
  }

  // double track_quality = 16;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_track_quality = this->_internal_track_quality();
  uint64_t raw_track_quality;
  memcpy(&raw_track_quality, &tmp_track_quality, sizeof(tmp_track_quality));
  if (raw_track_quality != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(16, this->_internal_track_quality(), target);
  }

  // double innovation_magnitude = 17;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_innovation_magnitude = this->_internal_innovation_magnitude();
  uint64_t raw_innovation_magnitude;
  memcpy(&raw_innovation_magnitude, &tmp_innovation_magnitude, sizeof(tmp_innovation_magnitude));
  if (raw_innovation_magnitude != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(17, this->_internal_innovation_magnitude(), target);
  }

  // double mahalanobis_distance = 18;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_mahalanobis_distance = this->_internal_mahalanobis_distance();
  uint64_t raw_mahalanobis_distance;
  memcpy(&raw_mahalanobis_distance, &tmp_mahalanobis_distance, sizeof(tmp_mahalanobis_distance));
  if (raw_mahalanobis_distance != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(18, this->_internal_mahalanobis_distance(), target);
  }

  // double speed = 19;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_speed = this->_internal_speed();
  uint64_t raw_speed;
  memcpy(&raw_speed, &tmp_speed, sizeof(tmp_speed));
  if (raw_speed != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(19, this->_internal_speed(), target);
  }

  // double heading = 20;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_heading = this->_internal_heading();
  uint64_t raw_heading;
  memcpy(&raw_heading, &tmp_heading, sizeof(tmp_heading));
  if (raw_heading != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(20, this->_internal_heading(), target);
  }

  // double turn_rate = 21;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_turn_rate = this->_internal_turn_rate();
  uint64_t raw_turn_rate;
  memcpy(&raw_turn_rate, &tmp_turn_rate, sizeof(tmp_turn_rate));
  if (raw_turn_rate != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(21, this->_internal_turn_rate(), target);
  }

  // double range = 22;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_range = this->_internal_range();
  uint64_t raw_range;
  memcpy(&raw_range, &tmp_range, sizeof(tmp_range));
  if (raw_range != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(22, this->_internal_range(), target);
  }

  // double bearing = 23;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_bearing = this->_internal_bearing();
  uint64_t raw_bearing;
  memcpy(&raw_bearing, &tmp_bearing, sizeof(tmp_bearing));
  if (raw_bearing != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(23, this->_internal_bearing(), target);
  }

  // double elevation = 24;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_elevation = this->_internal_elevation();
  uint64_t raw_elevation;
  memcpy(&raw_elevation, &tmp_elevation, sizeof(tmp_elevation));
  if (raw_elevation != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(24, this->_internal_elevation(), target);
  }

  // map<string, double> attributes = 25;
  if (!this->_internal_attributes().empty()) {
    using MapType = ::_pb::Map<std::string, double>;
    using WireHelper = Track_AttributesEntry_DoNotUse::Funcs;
    const auto& map_field = this->_internal_attributes();
    auto check_utf8 = [](const MapType::value_type& entry) {
      (void)entry;
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        entry.first.data(), static_cast<int>(entry.first.length()),
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
        "radar.messages.Track.AttributesEntry.key");
    };

    if (stream->IsSerializationDeterministic() && map_field.size() > 1) {
      for (const auto& entry : ::_pbi::MapSorterPtr<MapType>(map_field)) {
        target = WireHelper::InternalSerialize(25, entry.first, entry.second, target, stream);
        check_utf8(entry);
      }
    } else {
      for (const auto& entry : map_field) {
        target = WireHelper::InternalSerialize(25, entry.first, entry.second, target, stream);
        check_utf8(entry);
      }
    }
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:radar.messages.Track)
  return target;
}

size_t Track::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:radar.messages.Track)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // map<string, double> classification_scores = 15;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_classification_scores_size());
  for (::PROTOBUF_NAMESPACE_ID::Map< std::string, double >::const_iterator
      it = this->_internal_classification_scores().begin();
      it != this->_internal_classification_scores().end(); ++it) {
    total_size += Track_ClassificationScoresEntry_DoNotUse::Funcs::ByteSizeLong(it->first, it->second);
  }

  // map<string, double> attributes = 25;
  total_size += 2 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_attributes_size());
  for (::PROTOBUF_NAMESPACE_ID::Map< std::string, double >::const_iterator
      it = this->_internal_attributes().begin();
      it != this->_internal_attributes().end(); ++it) {
    total_size += Track_AttributesEntry_DoNotUse::Funcs::ByteSizeLong(it->first, it->second);
  }

  // string target_class = 14;
  if (!this->_internal_target_class().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_target_class());
  }

  // .google.protobuf.Timestamp created_time = 3;
  if (this->_internal_has_created_time()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.created_time_);
  }

  // .google.protobuf.Timestamp last_update_time = 4;
  if (this->_internal_has_last_update_time()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.last_update_time_);
  }

  // .radar.messages.TrackState current_state = 5;
  if (this->_internal_has_current_state()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.current_state_);
  }

  // .radar.messages.TrackState predicted_state = 6;
  if (this->_internal_has_predicted_state()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.predicted_state_);
  }

  // .radar.messages.TrackState state = 7;
  if (this->_internal_has_state()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.state_);
  }

  // uint32 id = 1;
  if (this->_internal_id() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_id());
  }

  // uint32 sensor_id = 2;
  if (this->_internal_sensor_id() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_sensor_id());
  }

  // uint32 hit_count = 8;
  if (this->_internal_hit_count() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_hit_count());
  }

  // uint32 miss_count = 9;
  if (this->_internal_miss_count() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_miss_count());
  }

  // double confidence = 11;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_confidence = this->_internal_confidence();
  uint64_t raw_confidence;
  memcpy(&raw_confidence, &tmp_confidence, sizeof(tmp_confidence));
  if (raw_confidence != 0) {
    total_size += 1 + 8;
  }

  // uint32 coast_count = 10;
  if (this->_internal_coast_count() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_coast_count());
  }

  // .radar.messages.FilterType filter_type = 13;
  if (this->_internal_filter_type() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_filter_type());
  }

  // double likelihood = 12;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_likelihood = this->_internal_likelihood();
  uint64_t raw_likelihood;
  memcpy(&raw_likelihood, &tmp_likelihood, sizeof(tmp_likelihood));
  if (raw_likelihood != 0) {
    total_size += 1 + 8;
  }

  // double track_quality = 16;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_track_quality = this->_internal_track_quality();
  uint64_t raw_track_quality;
  memcpy(&raw_track_quality, &tmp_track_quality, sizeof(tmp_track_quality));
  if (raw_track_quality != 0) {
    total_size += 2 + 8;
  }

  // double innovation_magnitude = 17;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_innovation_magnitude = this->_internal_innovation_magnitude();
  uint64_t raw_innovation_magnitude;
  memcpy(&raw_innovation_magnitude, &tmp_innovation_magnitude, sizeof(tmp_innovation_magnitude));
  if (raw_innovation_magnitude != 0) {
    total_size += 2 + 8;
  }

  // double mahalanobis_distance = 18;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_mahalanobis_distance = this->_internal_mahalanobis_distance();
  uint64_t raw_mahalanobis_distance;
  memcpy(&raw_mahalanobis_distance, &tmp_mahalanobis_distance, sizeof(tmp_mahalanobis_distance));
  if (raw_mahalanobis_distance != 0) {
    total_size += 2 + 8;
  }

  // double speed = 19;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_speed = this->_internal_speed();
  uint64_t raw_speed;
  memcpy(&raw_speed, &tmp_speed, sizeof(tmp_speed));
  if (raw_speed != 0) {
    total_size += 2 + 8;
  }

  // double heading = 20;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_heading = this->_internal_heading();
  uint64_t raw_heading;
  memcpy(&raw_heading, &tmp_heading, sizeof(tmp_heading));
  if (raw_heading != 0) {
    total_size += 2 + 8;
  }

  // double turn_rate = 21;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_turn_rate = this->_internal_turn_rate();
  uint64_t raw_turn_rate;
  memcpy(&raw_turn_rate, &tmp_turn_rate, sizeof(tmp_turn_rate));
  if (raw_turn_rate != 0) {
    total_size += 2 + 8;
  }

  // double range = 22;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_range = this->_internal_range();
  uint64_t raw_range;
  memcpy(&raw_range, &tmp_range, sizeof(tmp_range));
  if (raw_range != 0) {
    total_size += 2 + 8;
  }

  // double bearing = 23;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_bearing = this->_internal_bearing();
  uint64_t raw_bearing;
  memcpy(&raw_bearing, &tmp_bearing, sizeof(tmp_bearing));
  if (raw_bearing != 0) {
    total_size += 2 + 8;
  }

  // double elevation = 24;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_elevation = this->_internal_elevation();
  uint64_t raw_elevation;
  memcpy(&raw_elevation, &tmp_elevation, sizeof(tmp_elevation));
  if (raw_elevation != 0) {
    total_size += 2 + 8;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Track::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Track::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Track::GetClassData() const { return &_class_data_; }


void Track::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Track*>(&to_msg);
  auto& from = static_cast<const Track&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:radar.messages.Track)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.classification_scores_.MergeFrom(from._impl_.classification_scores_);
  _this->_impl_.attributes_.MergeFrom(from._impl_.attributes_);
  if (!from._internal_target_class().empty()) {
    _this->_internal_set_target_class(from._internal_target_class());
  }
  if (from._internal_has_created_time()) {
    _this->_internal_mutable_created_time()->::PROTOBUF_NAMESPACE_ID::Timestamp::MergeFrom(
        from._internal_created_time());
  }
  if (from._internal_has_last_update_time()) {
    _this->_internal_mutable_last_update_time()->::PROTOBUF_NAMESPACE_ID::Timestamp::MergeFrom(
        from._internal_last_update_time());
  }
  if (from._internal_has_current_state()) {
    _this->_internal_mutable_current_state()->::radar::messages::TrackState::MergeFrom(
        from._internal_current_state());
  }
  if (from._internal_has_predicted_state()) {
    _this->_internal_mutable_predicted_state()->::radar::messages::TrackState::MergeFrom(
        from._internal_predicted_state());
  }
  if (from._internal_has_state()) {
    _this->_internal_mutable_state()->::radar::messages::TrackState::MergeFrom(
        from._internal_state());
  }
  if (from._internal_id() != 0) {
    _this->_internal_set_id(from._internal_id());
  }
  if (from._internal_sensor_id() != 0) {
    _this->_internal_set_sensor_id(from._internal_sensor_id());
  }
  if (from._internal_hit_count() != 0) {
    _this->_internal_set_hit_count(from._internal_hit_count());
  }
  if (from._internal_miss_count() != 0) {
    _this->_internal_set_miss_count(from._internal_miss_count());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_confidence = from._internal_confidence();
  uint64_t raw_confidence;
  memcpy(&raw_confidence, &tmp_confidence, sizeof(tmp_confidence));
  if (raw_confidence != 0) {
    _this->_internal_set_confidence(from._internal_confidence());
  }
  if (from._internal_coast_count() != 0) {
    _this->_internal_set_coast_count(from._internal_coast_count());
  }
  if (from._internal_filter_type() != 0) {
    _this->_internal_set_filter_type(from._internal_filter_type());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_likelihood = from._internal_likelihood();
  uint64_t raw_likelihood;
  memcpy(&raw_likelihood, &tmp_likelihood, sizeof(tmp_likelihood));
  if (raw_likelihood != 0) {
    _this->_internal_set_likelihood(from._internal_likelihood());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_track_quality = from._internal_track_quality();
  uint64_t raw_track_quality;
  memcpy(&raw_track_quality, &tmp_track_quality, sizeof(tmp_track_quality));
  if (raw_track_quality != 0) {
    _this->_internal_set_track_quality(from._internal_track_quality());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_innovation_magnitude = from._internal_innovation_magnitude();
  uint64_t raw_innovation_magnitude;
  memcpy(&raw_innovation_magnitude, &tmp_innovation_magnitude, sizeof(tmp_innovation_magnitude));
  if (raw_innovation_magnitude != 0) {
    _this->_internal_set_innovation_magnitude(from._internal_innovation_magnitude());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_mahalanobis_distance = from._internal_mahalanobis_distance();
  uint64_t raw_mahalanobis_distance;
  memcpy(&raw_mahalanobis_distance, &tmp_mahalanobis_distance, sizeof(tmp_mahalanobis_distance));
  if (raw_mahalanobis_distance != 0) {
    _this->_internal_set_mahalanobis_distance(from._internal_mahalanobis_distance());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_speed = from._internal_speed();
  uint64_t raw_speed;
  memcpy(&raw_speed, &tmp_speed, sizeof(tmp_speed));
  if (raw_speed != 0) {
    _this->_internal_set_speed(from._internal_speed());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_heading = from._internal_heading();
  uint64_t raw_heading;
  memcpy(&raw_heading, &tmp_heading, sizeof(tmp_heading));
  if (raw_heading != 0) {
    _this->_internal_set_heading(from._internal_heading());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_turn_rate = from._internal_turn_rate();
  uint64_t raw_turn_rate;
  memcpy(&raw_turn_rate, &tmp_turn_rate, sizeof(tmp_turn_rate));
  if (raw_turn_rate != 0) {
    _this->_internal_set_turn_rate(from._internal_turn_rate());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_range = from._internal_range();
  uint64_t raw_range;
  memcpy(&raw_range, &tmp_range, sizeof(tmp_range));
  if (raw_range != 0) {
    _this->_internal_set_range(from._internal_range());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_bearing = from._internal_bearing();
  uint64_t raw_bearing;
  memcpy(&raw_bearing, &tmp_bearing, sizeof(tmp_bearing));
  if (raw_bearing != 0) {
    _this->_internal_set_bearing(from._internal_bearing());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_elevation = from._internal_elevation();
  uint64_t raw_elevation;
  memcpy(&raw_elevation, &tmp_elevation, sizeof(tmp_elevation));
  if (raw_elevation != 0) {
    _this->_internal_set_elevation(from._internal_elevation());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Track::CopyFrom(const Track& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:radar.messages.Track)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Track::IsInitialized() const {
  return true;
}

void Track::InternalSwap(Track* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.classification_scores_.InternalSwap(&other->_impl_.classification_scores_);
  _impl_.attributes_.InternalSwap(&other->_impl_.attributes_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.target_class_, lhs_arena,
      &other->_impl_.target_class_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Track, _impl_.elevation_)
      + sizeof(Track::_impl_.elevation_)
      - PROTOBUF_FIELD_OFFSET(Track, _impl_.created_time_)>(
          reinterpret_cast<char*>(&_impl_.created_time_),
          reinterpret_cast<char*>(&other->_impl_.created_time_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Track::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_track_5fmessages_2eproto_getter, &descriptor_table_track_5fmessages_2eproto_once,
      file_level_metadata_track_5fmessages_2eproto[3]);
}

// ===================================================================

class TrackBatch::_Internal {
 public:
  static const ::PROTOBUF_NAMESPACE_ID::Timestamp& batch_timestamp(const TrackBatch* msg);
  static const ::radar::messages::PerformanceMetrics& performance(const TrackBatch* msg);
};

const ::PROTOBUF_NAMESPACE_ID::Timestamp&
TrackBatch::_Internal::batch_timestamp(const TrackBatch* msg) {
  return *msg->_impl_.batch_timestamp_;
}
const ::radar::messages::PerformanceMetrics&
TrackBatch::_Internal::performance(const TrackBatch* msg) {
  return *msg->_impl_.performance_;
}
void TrackBatch::clear_batch_timestamp() {
  if (GetArenaForAllocation() == nullptr && _impl_.batch_timestamp_ != nullptr) {
    delete _impl_.batch_timestamp_;
  }
  _impl_.batch_timestamp_ = nullptr;
}
void TrackBatch::clear_performance() {
  if (GetArenaForAllocation() == nullptr && _impl_.performance_ != nullptr) {
    delete _impl_.performance_;
  }
  _impl_.performance_ = nullptr;
}
TrackBatch::TrackBatch(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:radar.messages.TrackBatch)
}
TrackBatch::TrackBatch(const TrackBatch& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  TrackBatch* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.tracks_){from._impl_.tracks_}
    , decltype(_impl_.batch_timestamp_){nullptr}
    , decltype(_impl_.performance_){nullptr}
    , decltype(_impl_.sensor_id_){}
    , decltype(_impl_.sequence_number_){}
    , decltype(_impl_.processing_time_ms_){}
    , decltype(_impl_.total_tracks_){}
    , decltype(_impl_.confirmed_tracks_){}
    , decltype(_impl_.tentative_tracks_){}
    , decltype(_impl_.coasting_tracks_){}
    , decltype(_impl_.deleted_tracks_){}
    , decltype(_impl_.total_associations_){}
    , decltype(_impl_.association_rate_){}
    , decltype(_impl_.successful_associations_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_batch_timestamp()) {
    _this->_impl_.batch_timestamp_ = new ::PROTOBUF_NAMESPACE_ID::Timestamp(*from._impl_.batch_timestamp_);
  }
  if (from._internal_has_performance()) {
    _this->_impl_.performance_ = new ::radar::messages::PerformanceMetrics(*from._impl_.performance_);
  }
  ::memcpy(&_impl_.sensor_id_, &from._impl_.sensor_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.successful_associations_) -
    reinterpret_cast<char*>(&_impl_.sensor_id_)) + sizeof(_impl_.successful_associations_));
  // @@protoc_insertion_point(copy_constructor:radar.messages.TrackBatch)
}

inline void TrackBatch::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.tracks_){arena}
    , decltype(_impl_.batch_timestamp_){nullptr}
    , decltype(_impl_.performance_){nullptr}
    , decltype(_impl_.sensor_id_){0u}
    , decltype(_impl_.sequence_number_){0u}
    , decltype(_impl_.processing_time_ms_){0}
    , decltype(_impl_.total_tracks_){0u}
    , decltype(_impl_.confirmed_tracks_){0u}
    , decltype(_impl_.tentative_tracks_){0u}
    , decltype(_impl_.coasting_tracks_){0u}
    , decltype(_impl_.deleted_tracks_){0u}
    , decltype(_impl_.total_associations_){0u}
    , decltype(_impl_.association_rate_){0}
    , decltype(_impl_.successful_associations_){0u}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

TrackBatch::~TrackBatch() {
  // @@protoc_insertion_point(destructor:radar.messages.TrackBatch)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TrackBatch::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.tracks_.~RepeatedPtrField();
  if (this != internal_default_instance()) delete _impl_.batch_timestamp_;
  if (this != internal_default_instance()) delete _impl_.performance_;
}

void TrackBatch::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TrackBatch::Clear() {
// @@protoc_insertion_point(message_clear_start:radar.messages.TrackBatch)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.tracks_.Clear();
  if (GetArenaForAllocation() == nullptr && _impl_.batch_timestamp_ != nullptr) {
    delete _impl_.batch_timestamp_;
  }
  _impl_.batch_timestamp_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.performance_ != nullptr) {
    delete _impl_.performance_;
  }
  _impl_.performance_ = nullptr;
  ::memset(&_impl_.sensor_id_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.successful_associations_) -
      reinterpret_cast<char*>(&_impl_.sensor_id_)) + sizeof(_impl_.successful_associations_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TrackBatch::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .radar.messages.Track tracks = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_tracks(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // .google.protobuf.Timestamp batch_timestamp = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_batch_timestamp(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 sensor_id = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.sensor_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 sequence_number = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _impl_.sequence_number_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // double processing_time_ms = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 41)) {
          _impl_.processing_time_ms_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // uint32 total_tracks = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _impl_.total_tracks_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 confirmed_tracks = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _impl_.confirmed_tracks_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 tentative_tracks = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _impl_.tentative_tracks_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 coasting_tracks = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _impl_.coasting_tracks_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 deleted_tracks = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          _impl_.deleted_tracks_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 total_associations = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 88)) {
          _impl_.total_associations_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 successful_associations = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 96)) {
          _impl_.successful_associations_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // double association_rate = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 105)) {
          _impl_.association_rate_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // .radar.messages.PerformanceMetrics performance = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 114)) {
          ptr = ctx->ParseMessage(_internal_mutable_performance(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TrackBatch::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:radar.messages.TrackBatch)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .radar.messages.Track tracks = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_tracks_size()); i < n; i++) {
    const auto& repfield = this->_internal_tracks(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  // .google.protobuf.Timestamp batch_timestamp = 2;
  if (this->_internal_has_batch_timestamp()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::batch_timestamp(this),
        _Internal::batch_timestamp(this).GetCachedSize(), target, stream);
  }

  // uint32 sensor_id = 3;
  if (this->_internal_sensor_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_sensor_id(), target);
  }

  // uint32 sequence_number = 4;
  if (this->_internal_sequence_number() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_sequence_number(), target);
  }

  // double processing_time_ms = 5;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_processing_time_ms = this->_internal_processing_time_ms();
  uint64_t raw_processing_time_ms;
  memcpy(&raw_processing_time_ms, &tmp_processing_time_ms, sizeof(tmp_processing_time_ms));
  if (raw_processing_time_ms != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(5, this->_internal_processing_time_ms(), target);
  }

  // uint32 total_tracks = 6;
  if (this->_internal_total_tracks() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(6, this->_internal_total_tracks(), target);
  }

  // uint32 confirmed_tracks = 7;
  if (this->_internal_confirmed_tracks() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(7, this->_internal_confirmed_tracks(), target);
  }

  // uint32 tentative_tracks = 8;
  if (this->_internal_tentative_tracks() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(8, this->_internal_tentative_tracks(), target);
  }

  // uint32 coasting_tracks = 9;
  if (this->_internal_coasting_tracks() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(9, this->_internal_coasting_tracks(), target);
  }

  // uint32 deleted_tracks = 10;
  if (this->_internal_deleted_tracks() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(10, this->_internal_deleted_tracks(), target);
  }

  // uint32 total_associations = 11;
  if (this->_internal_total_associations() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(11, this->_internal_total_associations(), target);
  }

  // uint32 successful_associations = 12;
  if (this->_internal_successful_associations() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(12, this->_internal_successful_associations(), target);
  }

  // double association_rate = 13;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_association_rate = this->_internal_association_rate();
  uint64_t raw_association_rate;
  memcpy(&raw_association_rate, &tmp_association_rate, sizeof(tmp_association_rate));
  if (raw_association_rate != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(13, this->_internal_association_rate(), target);
  }

  // .radar.messages.PerformanceMetrics performance = 14;
  if (this->_internal_has_performance()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(14, _Internal::performance(this),
        _Internal::performance(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:radar.messages.TrackBatch)
  return target;
}

size_t TrackBatch::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:radar.messages.TrackBatch)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .radar.messages.Track tracks = 1;
  total_size += 1UL * this->_internal_tracks_size();
  for (const auto& msg : this->_impl_.tracks_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // .google.protobuf.Timestamp batch_timestamp = 2;
  if (this->_internal_has_batch_timestamp()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.batch_timestamp_);
  }

  // .radar.messages.PerformanceMetrics performance = 14;
  if (this->_internal_has_performance()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.performance_);
  }

  // uint32 sensor_id = 3;
  if (this->_internal_sensor_id() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_sensor_id());
  }

  // uint32 sequence_number = 4;
  if (this->_internal_sequence_number() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_sequence_number());
  }

  // double processing_time_ms = 5;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_processing_time_ms = this->_internal_processing_time_ms();
  uint64_t raw_processing_time_ms;
  memcpy(&raw_processing_time_ms, &tmp_processing_time_ms, sizeof(tmp_processing_time_ms));
  if (raw_processing_time_ms != 0) {
    total_size += 1 + 8;
  }

  // uint32 total_tracks = 6;
  if (this->_internal_total_tracks() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_total_tracks());
  }

  // uint32 confirmed_tracks = 7;
  if (this->_internal_confirmed_tracks() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_confirmed_tracks());
  }

  // uint32 tentative_tracks = 8;
  if (this->_internal_tentative_tracks() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_tentative_tracks());
  }

  // uint32 coasting_tracks = 9;
  if (this->_internal_coasting_tracks() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_coasting_tracks());
  }

  // uint32 deleted_tracks = 10;
  if (this->_internal_deleted_tracks() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_deleted_tracks());
  }

  // uint32 total_associations = 11;
  if (this->_internal_total_associations() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_total_associations());
  }

  // double association_rate = 13;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_association_rate = this->_internal_association_rate();
  uint64_t raw_association_rate;
  memcpy(&raw_association_rate, &tmp_association_rate, sizeof(tmp_association_rate));
  if (raw_association_rate != 0) {
    total_size += 1 + 8;
  }

  // uint32 successful_associations = 12;
  if (this->_internal_successful_associations() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_successful_associations());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData TrackBatch::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    TrackBatch::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*TrackBatch::GetClassData() const { return &_class_data_; }


void TrackBatch::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<TrackBatch*>(&to_msg);
  auto& from = static_cast<const TrackBatch&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:radar.messages.TrackBatch)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.tracks_.MergeFrom(from._impl_.tracks_);
  if (from._internal_has_batch_timestamp()) {
    _this->_internal_mutable_batch_timestamp()->::PROTOBUF_NAMESPACE_ID::Timestamp::MergeFrom(
        from._internal_batch_timestamp());
  }
  if (from._internal_has_performance()) {
    _this->_internal_mutable_performance()->::radar::messages::PerformanceMetrics::MergeFrom(
        from._internal_performance());
  }
  if (from._internal_sensor_id() != 0) {
    _this->_internal_set_sensor_id(from._internal_sensor_id());
  }
  if (from._internal_sequence_number() != 0) {
    _this->_internal_set_sequence_number(from._internal_sequence_number());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_processing_time_ms = from._internal_processing_time_ms();
  uint64_t raw_processing_time_ms;
  memcpy(&raw_processing_time_ms, &tmp_processing_time_ms, sizeof(tmp_processing_time_ms));
  if (raw_processing_time_ms != 0) {
    _this->_internal_set_processing_time_ms(from._internal_processing_time_ms());
  }
  if (from._internal_total_tracks() != 0) {
    _this->_internal_set_total_tracks(from._internal_total_tracks());
  }
  if (from._internal_confirmed_tracks() != 0) {
    _this->_internal_set_confirmed_tracks(from._internal_confirmed_tracks());
  }
  if (from._internal_tentative_tracks() != 0) {
    _this->_internal_set_tentative_tracks(from._internal_tentative_tracks());
  }
  if (from._internal_coasting_tracks() != 0) {
    _this->_internal_set_coasting_tracks(from._internal_coasting_tracks());
  }
  if (from._internal_deleted_tracks() != 0) {
    _this->_internal_set_deleted_tracks(from._internal_deleted_tracks());
  }
  if (from._internal_total_associations() != 0) {
    _this->_internal_set_total_associations(from._internal_total_associations());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_association_rate = from._internal_association_rate();
  uint64_t raw_association_rate;
  memcpy(&raw_association_rate, &tmp_association_rate, sizeof(tmp_association_rate));
  if (raw_association_rate != 0) {
    _this->_internal_set_association_rate(from._internal_association_rate());
  }
  if (from._internal_successful_associations() != 0) {
    _this->_internal_set_successful_associations(from._internal_successful_associations());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void TrackBatch::CopyFrom(const TrackBatch& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:radar.messages.TrackBatch)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TrackBatch::IsInitialized() const {
  return true;
}

void TrackBatch::InternalSwap(TrackBatch* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.tracks_.InternalSwap(&other->_impl_.tracks_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TrackBatch, _impl_.successful_associations_)
      + sizeof(TrackBatch::_impl_.successful_associations_)
      - PROTOBUF_FIELD_OFFSET(TrackBatch, _impl_.batch_timestamp_)>(
          reinterpret_cast<char*>(&_impl_.batch_timestamp_),
          reinterpret_cast<char*>(&other->_impl_.batch_timestamp_));
}

::PROTOBUF_NAMESPACE_ID::Metadata TrackBatch::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_track_5fmessages_2eproto_getter, &descriptor_table_track_5fmessages_2eproto_once,
      file_level_metadata_track_5fmessages_2eproto[4]);
}

// ===================================================================

TrackUpdate_UpdateDataEntry_DoNotUse::TrackUpdate_UpdateDataEntry_DoNotUse() {}
TrackUpdate_UpdateDataEntry_DoNotUse::TrackUpdate_UpdateDataEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
    : SuperType(arena) {}
void TrackUpdate_UpdateDataEntry_DoNotUse::MergeFrom(const TrackUpdate_UpdateDataEntry_DoNotUse& other) {
  MergeFromInternal(other);
}
::PROTOBUF_NAMESPACE_ID::Metadata TrackUpdate_UpdateDataEntry_DoNotUse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_track_5fmessages_2eproto_getter, &descriptor_table_track_5fmessages_2eproto_once,
      file_level_metadata_track_5fmessages_2eproto[5]);
}

// ===================================================================

class TrackUpdate::_Internal {
 public:
  static const ::PROTOBUF_NAMESPACE_ID::Timestamp& timestamp(const TrackUpdate* msg);
  static const ::radar::messages::Track& track(const TrackUpdate* msg);
};

const ::PROTOBUF_NAMESPACE_ID::Timestamp&
TrackUpdate::_Internal::timestamp(const TrackUpdate* msg) {
  return *msg->_impl_.timestamp_;
}
const ::radar::messages::Track&
TrackUpdate::_Internal::track(const TrackUpdate* msg) {
  return *msg->_impl_.track_;
}
void TrackUpdate::clear_timestamp() {
  if (GetArenaForAllocation() == nullptr && _impl_.timestamp_ != nullptr) {
    delete _impl_.timestamp_;
  }
  _impl_.timestamp_ = nullptr;
}
TrackUpdate::TrackUpdate(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  if (arena != nullptr && !is_message_owned) {
    arena->OwnCustomDestructor(this, &TrackUpdate::ArenaDtor);
  }
  // @@protoc_insertion_point(arena_constructor:radar.messages.TrackUpdate)
}
TrackUpdate::TrackUpdate(const TrackUpdate& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  TrackUpdate* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      /*decltype(_impl_.update_data_)*/{}
    , decltype(_impl_.timestamp_){nullptr}
    , decltype(_impl_.track_){nullptr}
    , decltype(_impl_.track_id_){}
    , decltype(_impl_.sensor_id_){}
    , decltype(_impl_.update_type_){}
    , decltype(_impl_.associated_detection_id_){}
    , decltype(_impl_.association_score_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.update_data_.MergeFrom(from._impl_.update_data_);
  if (from._internal_has_timestamp()) {
    _this->_impl_.timestamp_ = new ::PROTOBUF_NAMESPACE_ID::Timestamp(*from._impl_.timestamp_);
  }
  if (from._internal_has_track()) {
    _this->_impl_.track_ = new ::radar::messages::Track(*from._impl_.track_);
  }
  ::memcpy(&_impl_.track_id_, &from._impl_.track_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.association_score_) -
    reinterpret_cast<char*>(&_impl_.track_id_)) + sizeof(_impl_.association_score_));
  // @@protoc_insertion_point(copy_constructor:radar.messages.TrackUpdate)
}

inline void TrackUpdate::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      /*decltype(_impl_.update_data_)*/{::_pbi::ArenaInitialized(), arena}
    , decltype(_impl_.timestamp_){nullptr}
    , decltype(_impl_.track_){nullptr}
    , decltype(_impl_.track_id_){0u}
    , decltype(_impl_.sensor_id_){0u}
    , decltype(_impl_.update_type_){0}
    , decltype(_impl_.associated_detection_id_){0u}
    , decltype(_impl_.association_score_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

TrackUpdate::~TrackUpdate() {
  // @@protoc_insertion_point(destructor:radar.messages.TrackUpdate)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    ArenaDtor(this);
    return;
  }
  SharedDtor();
}

inline void TrackUpdate::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.update_data_.Destruct();
  _impl_.update_data_.~MapField();
  if (this != internal_default_instance()) delete _impl_.timestamp_;
  if (this != internal_default_instance()) delete _impl_.track_;
}

void TrackUpdate::ArenaDtor(void* object) {
  TrackUpdate* _this = reinterpret_cast< TrackUpdate* >(object);
  _this->_impl_.update_data_.Destruct();
}
void TrackUpdate::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TrackUpdate::Clear() {
// @@protoc_insertion_point(message_clear_start:radar.messages.TrackUpdate)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.update_data_.Clear();
  if (GetArenaForAllocation() == nullptr && _impl_.timestamp_ != nullptr) {
    delete _impl_.timestamp_;
  }
  _impl_.timestamp_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.track_ != nullptr) {
    delete _impl_.track_;
  }
  _impl_.track_ = nullptr;
  ::memset(&_impl_.track_id_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.association_score_) -
      reinterpret_cast<char*>(&_impl_.track_id_)) + sizeof(_impl_.association_score_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TrackUpdate::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint32 track_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.track_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 sensor_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.sensor_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .google.protobuf.Timestamp timestamp = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_timestamp(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .radar.messages.TrackUpdate.UpdateType update_type = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_update_type(static_cast<::radar::messages::TrackUpdate_UpdateType>(val));
        } else
          goto handle_unusual;
        continue;
      // .radar.messages.Track track = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_track(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 associated_detection_id = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _impl_.associated_detection_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // double association_score = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 57)) {
          _impl_.association_score_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // map<string, string> update_data = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(&_impl_.update_data_, ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<66>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TrackUpdate::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:radar.messages.TrackUpdate)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint32 track_id = 1;
  if (this->_internal_track_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_track_id(), target);
  }

  // uint32 sensor_id = 2;
  if (this->_internal_sensor_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_sensor_id(), target);
  }

  // .google.protobuf.Timestamp timestamp = 3;
  if (this->_internal_has_timestamp()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::timestamp(this),
        _Internal::timestamp(this).GetCachedSize(), target, stream);
  }

  // .radar.messages.TrackUpdate.UpdateType update_type = 4;
  if (this->_internal_update_type() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      4, this->_internal_update_type(), target);
  }

  // .radar.messages.Track track = 5;
  if (this->_internal_has_track()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::track(this),
        _Internal::track(this).GetCachedSize(), target, stream);
  }

  // uint32 associated_detection_id = 6;
  if (this->_internal_associated_detection_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(6, this->_internal_associated_detection_id(), target);
  }

  // double association_score = 7;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_association_score = this->_internal_association_score();
  uint64_t raw_association_score;
  memcpy(&raw_association_score, &tmp_association_score, sizeof(tmp_association_score));
  if (raw_association_score != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(7, this->_internal_association_score(), target);
  }

  // map<string, string> update_data = 8;
  if (!this->_internal_update_data().empty()) {
    using MapType = ::_pb::Map<std::string, std::string>;
    using WireHelper = TrackUpdate_UpdateDataEntry_DoNotUse::Funcs;
    const auto& map_field = this->_internal_update_data();
    auto check_utf8 = [](const MapType::value_type& entry) {
      (void)entry;
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        entry.first.data(), static_cast<int>(entry.first.length()),
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
        "radar.messages.TrackUpdate.UpdateDataEntry.key");
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        entry.second.data(), static_cast<int>(entry.second.length()),
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
        "radar.messages.TrackUpdate.UpdateDataEntry.value");
    };

    if (stream->IsSerializationDeterministic() && map_field.size() > 1) {
      for (const auto& entry : ::_pbi::MapSorterPtr<MapType>(map_field)) {
        target = WireHelper::InternalSerialize(8, entry.first, entry.second, target, stream);
        check_utf8(entry);
      }
    } else {
      for (const auto& entry : map_field) {
        target = WireHelper::InternalSerialize(8, entry.first, entry.second, target, stream);
        check_utf8(entry);
      }
    }
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:radar.messages.TrackUpdate)
  return target;
}

size_t TrackUpdate::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:radar.messages.TrackUpdate)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // map<string, string> update_data = 8;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_update_data_size());
  for (::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >::const_iterator
      it = this->_internal_update_data().begin();
      it != this->_internal_update_data().end(); ++it) {
    total_size += TrackUpdate_UpdateDataEntry_DoNotUse::Funcs::ByteSizeLong(it->first, it->second);
  }

  // .google.protobuf.Timestamp timestamp = 3;
  if (this->_internal_has_timestamp()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.timestamp_);
  }

  // .radar.messages.Track track = 5;
  if (this->_internal_has_track()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.track_);
  }

  // uint32 track_id = 1;
  if (this->_internal_track_id() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_track_id());
  }

  // uint32 sensor_id = 2;
  if (this->_internal_sensor_id() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_sensor_id());
  }

  // .radar.messages.TrackUpdate.UpdateType update_type = 4;
  if (this->_internal_update_type() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_update_type());
  }

  // uint32 associated_detection_id = 6;
  if (this->_internal_associated_detection_id() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_associated_detection_id());
  }

  // double association_score = 7;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_association_score = this->_internal_association_score();
  uint64_t raw_association_score;
  memcpy(&raw_association_score, &tmp_association_score, sizeof(tmp_association_score));
  if (raw_association_score != 0) {
    total_size += 1 + 8;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData TrackUpdate::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    TrackUpdate::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*TrackUpdate::GetClassData() const { return &_class_data_; }


void TrackUpdate::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<TrackUpdate*>(&to_msg);
  auto& from = static_cast<const TrackUpdate&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:radar.messages.TrackUpdate)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.update_data_.MergeFrom(from._impl_.update_data_);
  if (from._internal_has_timestamp()) {
    _this->_internal_mutable_timestamp()->::PROTOBUF_NAMESPACE_ID::Timestamp::MergeFrom(
        from._internal_timestamp());
  }
  if (from._internal_has_track()) {
    _this->_internal_mutable_track()->::radar::messages::Track::MergeFrom(
        from._internal_track());
  }
  if (from._internal_track_id() != 0) {
    _this->_internal_set_track_id(from._internal_track_id());
  }
  if (from._internal_sensor_id() != 0) {
    _this->_internal_set_sensor_id(from._internal_sensor_id());
  }
  if (from._internal_update_type() != 0) {
    _this->_internal_set_update_type(from._internal_update_type());
  }
  if (from._internal_associated_detection_id() != 0) {
    _this->_internal_set_associated_detection_id(from._internal_associated_detection_id());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_association_score = from._internal_association_score();
  uint64_t raw_association_score;
  memcpy(&raw_association_score, &tmp_association_score, sizeof(tmp_association_score));
  if (raw_association_score != 0) {
    _this->_internal_set_association_score(from._internal_association_score());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void TrackUpdate::CopyFrom(const TrackUpdate& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:radar.messages.TrackUpdate)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TrackUpdate::IsInitialized() const {
  return true;
}

void TrackUpdate::InternalSwap(TrackUpdate* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.update_data_.InternalSwap(&other->_impl_.update_data_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TrackUpdate, _impl_.association_score_)
      + sizeof(TrackUpdate::_impl_.association_score_)
      - PROTOBUF_FIELD_OFFSET(TrackUpdate, _impl_.timestamp_)>(
          reinterpret_cast<char*>(&_impl_.timestamp_),
          reinterpret_cast<char*>(&other->_impl_.timestamp_));
}

::PROTOBUF_NAMESPACE_ID::Metadata TrackUpdate::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_track_5fmessages_2eproto_getter, &descriptor_table_track_5fmessages_2eproto_once,
      file_level_metadata_track_5fmessages_2eproto[6]);
}

// ===================================================================

class TrackHistory::_Internal {
 public:
};

void TrackHistory::clear_timestamps() {
  _impl_.timestamps_.Clear();
}
void TrackHistory::clear_associated_detections() {
  _impl_.associated_detections_.Clear();
}
TrackHistory::TrackHistory(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:radar.messages.TrackHistory)
}
TrackHistory::TrackHistory(const TrackHistory& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  TrackHistory* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.state_history_){from._impl_.state_history_}
    , decltype(_impl_.timestamps_){from._impl_.timestamps_}
    , decltype(_impl_.associated_detections_){from._impl_.associated_detections_}
    , decltype(_impl_.confidence_history_){from._impl_.confidence_history_}
    , decltype(_impl_.likelihood_history_){from._impl_.likelihood_history_}
    , decltype(_impl_.track_id_){}
    , decltype(_impl_.sensor_id_){}
    , decltype(_impl_.average_speed_){}
    , decltype(_impl_.max_speed_){}
    , decltype(_impl_.total_distance_){}
    , decltype(_impl_.total_time_seconds_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.track_id_, &from._impl_.track_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.total_time_seconds_) -
    reinterpret_cast<char*>(&_impl_.track_id_)) + sizeof(_impl_.total_time_seconds_));
  // @@protoc_insertion_point(copy_constructor:radar.messages.TrackHistory)
}

inline void TrackHistory::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.state_history_){arena}
    , decltype(_impl_.timestamps_){arena}
    , decltype(_impl_.associated_detections_){arena}
    , decltype(_impl_.confidence_history_){arena}
    , decltype(_impl_.likelihood_history_){arena}
    , decltype(_impl_.track_id_){0u}
    , decltype(_impl_.sensor_id_){0u}
    , decltype(_impl_.average_speed_){0}
    , decltype(_impl_.max_speed_){0}
    , decltype(_impl_.total_distance_){0}
    , decltype(_impl_.total_time_seconds_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

TrackHistory::~TrackHistory() {
  // @@protoc_insertion_point(destructor:radar.messages.TrackHistory)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TrackHistory::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.state_history_.~RepeatedPtrField();
  _impl_.timestamps_.~RepeatedPtrField();
  _impl_.associated_detections_.~RepeatedPtrField();
  _impl_.confidence_history_.~RepeatedField();
  _impl_.likelihood_history_.~RepeatedField();
}

void TrackHistory::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TrackHistory::Clear() {
// @@protoc_insertion_point(message_clear_start:radar.messages.TrackHistory)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.state_history_.Clear();
  _impl_.timestamps_.Clear();
  _impl_.associated_detections_.Clear();
  _impl_.confidence_history_.Clear();
  _impl_.likelihood_history_.Clear();
  ::memset(&_impl_.track_id_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.total_time_seconds_) -
      reinterpret_cast<char*>(&_impl_.track_id_)) + sizeof(_impl_.total_time_seconds_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TrackHistory::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint32 track_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.track_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 sensor_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.sensor_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .radar.messages.TrackState state_history = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_state_history(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .google.protobuf.Timestamp timestamps = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_timestamps(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .radar.messages.Detection associated_detections = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_associated_detections(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<42>(ptr));
        } else
          goto handle_unusual;
        continue;
      // double average_speed = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 49)) {
          _impl_.average_speed_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double max_speed = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 57)) {
          _impl_.max_speed_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double total_distance = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 65)) {
          _impl_.total_distance_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double total_time_seconds = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 73)) {
          _impl_.total_time_seconds_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // repeated double confidence_history = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedDoubleParser(_internal_mutable_confidence_history(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 81) {
          _internal_add_confidence_history(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr));
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // repeated double likelihood_history = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedDoubleParser(_internal_mutable_likelihood_history(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 89) {
          _internal_add_likelihood_history(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr));
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TrackHistory::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:radar.messages.TrackHistory)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint32 track_id = 1;
  if (this->_internal_track_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_track_id(), target);
  }

  // uint32 sensor_id = 2;
  if (this->_internal_sensor_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_sensor_id(), target);
  }

  // repeated .radar.messages.TrackState state_history = 3;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_state_history_size()); i < n; i++) {
    const auto& repfield = this->_internal_state_history(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .google.protobuf.Timestamp timestamps = 4;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_timestamps_size()); i < n; i++) {
    const auto& repfield = this->_internal_timestamps(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(4, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .radar.messages.Detection associated_detections = 5;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_associated_detections_size()); i < n; i++) {
    const auto& repfield = this->_internal_associated_detections(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(5, repfield, repfield.GetCachedSize(), target, stream);
  }

  // double average_speed = 6;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_average_speed = this->_internal_average_speed();
  uint64_t raw_average_speed;
  memcpy(&raw_average_speed, &tmp_average_speed, sizeof(tmp_average_speed));
  if (raw_average_speed != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(6, this->_internal_average_speed(), target);
  }

  // double max_speed = 7;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_max_speed = this->_internal_max_speed();
  uint64_t raw_max_speed;
  memcpy(&raw_max_speed, &tmp_max_speed, sizeof(tmp_max_speed));
  if (raw_max_speed != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(7, this->_internal_max_speed(), target);
  }

  // double total_distance = 8;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_total_distance = this->_internal_total_distance();
  uint64_t raw_total_distance;
  memcpy(&raw_total_distance, &tmp_total_distance, sizeof(tmp_total_distance));
  if (raw_total_distance != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(8, this->_internal_total_distance(), target);
  }

  // double total_time_seconds = 9;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_total_time_seconds = this->_internal_total_time_seconds();
  uint64_t raw_total_time_seconds;
  memcpy(&raw_total_time_seconds, &tmp_total_time_seconds, sizeof(tmp_total_time_seconds));
  if (raw_total_time_seconds != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(9, this->_internal_total_time_seconds(), target);
  }

  // repeated double confidence_history = 10;
  if (this->_internal_confidence_history_size() > 0) {
    target = stream->WriteFixedPacked(10, _internal_confidence_history(), target);
  }

  // repeated double likelihood_history = 11;
  if (this->_internal_likelihood_history_size() > 0) {
    target = stream->WriteFixedPacked(11, _internal_likelihood_history(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:radar.messages.TrackHistory)
  return target;
}

size_t TrackHistory::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:radar.messages.TrackHistory)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .radar.messages.TrackState state_history = 3;
  total_size += 1UL * this->_internal_state_history_size();
  for (const auto& msg : this->_impl_.state_history_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .google.protobuf.Timestamp timestamps = 4;
  total_size += 1UL * this->_internal_timestamps_size();
  for (const auto& msg : this->_impl_.timestamps_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .radar.messages.Detection associated_detections = 5;
  total_size += 1UL * this->_internal_associated_detections_size();
  for (const auto& msg : this->_impl_.associated_detections_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated double confidence_history = 10;
  {
    unsigned int count = static_cast<unsigned int>(this->_internal_confidence_history_size());
    size_t data_size = 8UL * count;
    if (data_size > 0) {
      total_size += 1 +
        ::_pbi::WireFormatLite::Int32Size(static_cast<int32_t>(data_size));
    }
    total_size += data_size;
  }

  // repeated double likelihood_history = 11;
  {
    unsigned int count = static_cast<unsigned int>(this->_internal_likelihood_history_size());
    size_t data_size = 8UL * count;
    if (data_size > 0) {
      total_size += 1 +
        ::_pbi::WireFormatLite::Int32Size(static_cast<int32_t>(data_size));
    }
    total_size += data_size;
  }

  // uint32 track_id = 1;
  if (this->_internal_track_id() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_track_id());
  }

  // uint32 sensor_id = 2;
  if (this->_internal_sensor_id() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_sensor_id());
  }

  // double average_speed = 6;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_average_speed = this->_internal_average_speed();
  uint64_t raw_average_speed;
  memcpy(&raw_average_speed, &tmp_average_speed, sizeof(tmp_average_speed));
  if (raw_average_speed != 0) {
    total_size += 1 + 8;
  }

  // double max_speed = 7;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_max_speed = this->_internal_max_speed();
  uint64_t raw_max_speed;
  memcpy(&raw_max_speed, &tmp_max_speed, sizeof(tmp_max_speed));
  if (raw_max_speed != 0) {
    total_size += 1 + 8;
  }

  // double total_distance = 8;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_total_distance = this->_internal_total_distance();
  uint64_t raw_total_distance;
  memcpy(&raw_total_distance, &tmp_total_distance, sizeof(tmp_total_distance));
  if (raw_total_distance != 0) {
    total_size += 1 + 8;
  }

  // double total_time_seconds = 9;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_total_time_seconds = this->_internal_total_time_seconds();
  uint64_t raw_total_time_seconds;
  memcpy(&raw_total_time_seconds, &tmp_total_time_seconds, sizeof(tmp_total_time_seconds));
  if (raw_total_time_seconds != 0) {
    total_size += 1 + 8;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData TrackHistory::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    TrackHistory::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*TrackHistory::GetClassData() const { return &_class_data_; }


void TrackHistory::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<TrackHistory*>(&to_msg);
  auto& from = static_cast<const TrackHistory&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:radar.messages.TrackHistory)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.state_history_.MergeFrom(from._impl_.state_history_);
  _this->_impl_.timestamps_.MergeFrom(from._impl_.timestamps_);
  _this->_impl_.associated_detections_.MergeFrom(from._impl_.associated_detections_);
  _this->_impl_.confidence_history_.MergeFrom(from._impl_.confidence_history_);
  _this->_impl_.likelihood_history_.MergeFrom(from._impl_.likelihood_history_);
  if (from._internal_track_id() != 0) {
    _this->_internal_set_track_id(from._internal_track_id());
  }
  if (from._internal_sensor_id() != 0) {
    _this->_internal_set_sensor_id(from._internal_sensor_id());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_average_speed = from._internal_average_speed();
  uint64_t raw_average_speed;
  memcpy(&raw_average_speed, &tmp_average_speed, sizeof(tmp_average_speed));
  if (raw_average_speed != 0) {
    _this->_internal_set_average_speed(from._internal_average_speed());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_max_speed = from._internal_max_speed();
  uint64_t raw_max_speed;
  memcpy(&raw_max_speed, &tmp_max_speed, sizeof(tmp_max_speed));
  if (raw_max_speed != 0) {
    _this->_internal_set_max_speed(from._internal_max_speed());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_total_distance = from._internal_total_distance();
  uint64_t raw_total_distance;
  memcpy(&raw_total_distance, &tmp_total_distance, sizeof(tmp_total_distance));
  if (raw_total_distance != 0) {
    _this->_internal_set_total_distance(from._internal_total_distance());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_total_time_seconds = from._internal_total_time_seconds();
  uint64_t raw_total_time_seconds;
  memcpy(&raw_total_time_seconds, &tmp_total_time_seconds, sizeof(tmp_total_time_seconds));
  if (raw_total_time_seconds != 0) {
    _this->_internal_set_total_time_seconds(from._internal_total_time_seconds());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void TrackHistory::CopyFrom(const TrackHistory& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:radar.messages.TrackHistory)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TrackHistory::IsInitialized() const {
  return true;
}

void TrackHistory::InternalSwap(TrackHistory* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.state_history_.InternalSwap(&other->_impl_.state_history_);
  _impl_.timestamps_.InternalSwap(&other->_impl_.timestamps_);
  _impl_.associated_detections_.InternalSwap(&other->_impl_.associated_detections_);
  _impl_.confidence_history_.InternalSwap(&other->_impl_.confidence_history_);
  _impl_.likelihood_history_.InternalSwap(&other->_impl_.likelihood_history_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TrackHistory, _impl_.total_time_seconds_)
      + sizeof(TrackHistory::_impl_.total_time_seconds_)
      - PROTOBUF_FIELD_OFFSET(TrackHistory, _impl_.track_id_)>(
          reinterpret_cast<char*>(&_impl_.track_id_),
          reinterpret_cast<char*>(&other->_impl_.track_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata TrackHistory::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_track_5fmessages_2eproto_getter, &descriptor_table_track_5fmessages_2eproto_once,
      file_level_metadata_track_5fmessages_2eproto[7]);
}

// ===================================================================

DetectionCluster_AlgorithmParametersEntry_DoNotUse::DetectionCluster_AlgorithmParametersEntry_DoNotUse() {}
DetectionCluster_AlgorithmParametersEntry_DoNotUse::DetectionCluster_AlgorithmParametersEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
    : SuperType(arena) {}
void DetectionCluster_AlgorithmParametersEntry_DoNotUse::MergeFrom(const DetectionCluster_AlgorithmParametersEntry_DoNotUse& other) {
  MergeFromInternal(other);
}
::PROTOBUF_NAMESPACE_ID::Metadata DetectionCluster_AlgorithmParametersEntry_DoNotUse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_track_5fmessages_2eproto_getter, &descriptor_table_track_5fmessages_2eproto_once,
      file_level_metadata_track_5fmessages_2eproto[8]);
}

// ===================================================================

class DetectionCluster::_Internal {
 public:
  static const ::radar::messages::Point3D& centroid(const DetectionCluster* msg);
  static const ::radar::messages::Matrix3D& covariance(const DetectionCluster* msg);
  static const ::PROTOBUF_NAMESPACE_ID::Timestamp& timestamp(const DetectionCluster* msg);
};

const ::radar::messages::Point3D&
DetectionCluster::_Internal::centroid(const DetectionCluster* msg) {
  return *msg->_impl_.centroid_;
}
const ::radar::messages::Matrix3D&
DetectionCluster::_Internal::covariance(const DetectionCluster* msg) {
  return *msg->_impl_.covariance_;
}
const ::PROTOBUF_NAMESPACE_ID::Timestamp&
DetectionCluster::_Internal::timestamp(const DetectionCluster* msg) {
  return *msg->_impl_.timestamp_;
}
void DetectionCluster::clear_detections() {
  _impl_.detections_.Clear();
}
void DetectionCluster::clear_centroid() {
  if (GetArenaForAllocation() == nullptr && _impl_.centroid_ != nullptr) {
    delete _impl_.centroid_;
  }
  _impl_.centroid_ = nullptr;
}
void DetectionCluster::clear_covariance() {
  if (GetArenaForAllocation() == nullptr && _impl_.covariance_ != nullptr) {
    delete _impl_.covariance_;
  }
  _impl_.covariance_ = nullptr;
}
void DetectionCluster::clear_timestamp() {
  if (GetArenaForAllocation() == nullptr && _impl_.timestamp_ != nullptr) {
    delete _impl_.timestamp_;
  }
  _impl_.timestamp_ = nullptr;
}
DetectionCluster::DetectionCluster(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  if (arena != nullptr && !is_message_owned) {
    arena->OwnCustomDestructor(this, &DetectionCluster::ArenaDtor);
  }
  // @@protoc_insertion_point(arena_constructor:radar.messages.DetectionCluster)
}
DetectionCluster::DetectionCluster(const DetectionCluster& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  DetectionCluster* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.detections_){from._impl_.detections_}
    , /*decltype(_impl_.algorithm_parameters_)*/{}
    , decltype(_impl_.centroid_){nullptr}
    , decltype(_impl_.covariance_){nullptr}
    , decltype(_impl_.timestamp_){nullptr}
    , decltype(_impl_.id_){}
    , decltype(_impl_.algorithm_){}
    , decltype(_impl_.cluster_radius_){}
    , decltype(_impl_.cluster_density_){}
    , decltype(_impl_.processing_time_ms_){}
    , decltype(_impl_.detection_count_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.algorithm_parameters_.MergeFrom(from._impl_.algorithm_parameters_);
  if (from._internal_has_centroid()) {
    _this->_impl_.centroid_ = new ::radar::messages::Point3D(*from._impl_.centroid_);
  }
  if (from._internal_has_covariance()) {
    _this->_impl_.covariance_ = new ::radar::messages::Matrix3D(*from._impl_.covariance_);
  }
  if (from._internal_has_timestamp()) {
    _this->_impl_.timestamp_ = new ::PROTOBUF_NAMESPACE_ID::Timestamp(*from._impl_.timestamp_);
  }
  ::memcpy(&_impl_.id_, &from._impl_.id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.detection_count_) -
    reinterpret_cast<char*>(&_impl_.id_)) + sizeof(_impl_.detection_count_));
  // @@protoc_insertion_point(copy_constructor:radar.messages.DetectionCluster)
}

inline void DetectionCluster::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.detections_){arena}
    , /*decltype(_impl_.algorithm_parameters_)*/{::_pbi::ArenaInitialized(), arena}
    , decltype(_impl_.centroid_){nullptr}
    , decltype(_impl_.covariance_){nullptr}
    , decltype(_impl_.timestamp_){nullptr}
    , decltype(_impl_.id_){0u}
    , decltype(_impl_.algorithm_){0}
    , decltype(_impl_.cluster_radius_){0}
    , decltype(_impl_.cluster_density_){0}
    , decltype(_impl_.processing_time_ms_){0}
    , decltype(_impl_.detection_count_){0u}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

DetectionCluster::~DetectionCluster() {
  // @@protoc_insertion_point(destructor:radar.messages.DetectionCluster)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    ArenaDtor(this);
    return;
  }
  SharedDtor();
}

inline void DetectionCluster::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.detections_.~RepeatedPtrField();
  _impl_.algorithm_parameters_.Destruct();
  _impl_.algorithm_parameters_.~MapField();
  if (this != internal_default_instance()) delete _impl_.centroid_;
  if (this != internal_default_instance()) delete _impl_.covariance_;
  if (this != internal_default_instance()) delete _impl_.timestamp_;
}

void DetectionCluster::ArenaDtor(void* object) {
  DetectionCluster* _this = reinterpret_cast< DetectionCluster* >(object);
  _this->_impl_.algorithm_parameters_.Destruct();
}
void DetectionCluster::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DetectionCluster::Clear() {
// @@protoc_insertion_point(message_clear_start:radar.messages.DetectionCluster)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.detections_.Clear();
  _impl_.algorithm_parameters_.Clear();
  if (GetArenaForAllocation() == nullptr && _impl_.centroid_ != nullptr) {
    delete _impl_.centroid_;
  }
  _impl_.centroid_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.covariance_ != nullptr) {
    delete _impl_.covariance_;
  }
  _impl_.covariance_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.timestamp_ != nullptr) {
    delete _impl_.timestamp_;
  }
  _impl_.timestamp_ = nullptr;
  ::memset(&_impl_.id_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.detection_count_) -
      reinterpret_cast<char*>(&_impl_.id_)) + sizeof(_impl_.detection_count_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* DetectionCluster::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint32 id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .radar.messages.Detection detections = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_detections(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      // .radar.messages.Point3D centroid = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_centroid(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .radar.messages.Matrix3D covariance = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_covariance(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .google.protobuf.Timestamp timestamp = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_timestamp(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .radar.messages.DetectionCluster.ClusteringAlgorithm algorithm = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_algorithm(static_cast<::radar::messages::DetectionCluster_ClusteringAlgorithm>(val));
        } else
          goto handle_unusual;
        continue;
      // uint32 detection_count = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _impl_.detection_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // double cluster_radius = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 65)) {
          _impl_.cluster_radius_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double cluster_density = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 73)) {
          _impl_.cluster_density_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double processing_time_ms = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 81)) {
          _impl_.processing_time_ms_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // map<string, double> algorithm_parameters = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(&_impl_.algorithm_parameters_, ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<90>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DetectionCluster::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:radar.messages.DetectionCluster)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint32 id = 1;
  if (this->_internal_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_id(), target);
  }

  // repeated .radar.messages.Detection detections = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_detections_size()); i < n; i++) {
    const auto& repfield = this->_internal_detections(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  // .radar.messages.Point3D centroid = 3;
  if (this->_internal_has_centroid()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::centroid(this),
        _Internal::centroid(this).GetCachedSize(), target, stream);
  }

  // .radar.messages.Matrix3D covariance = 4;
  if (this->_internal_has_covariance()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::covariance(this),
        _Internal::covariance(this).GetCachedSize(), target, stream);
  }

  // .google.protobuf.Timestamp timestamp = 5;
  if (this->_internal_has_timestamp()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::timestamp(this),
        _Internal::timestamp(this).GetCachedSize(), target, stream);
  }

  // .radar.messages.DetectionCluster.ClusteringAlgorithm algorithm = 6;
  if (this->_internal_algorithm() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      6, this->_internal_algorithm(), target);
  }

  // uint32 detection_count = 7;
  if (this->_internal_detection_count() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(7, this->_internal_detection_count(), target);
  }

  // double cluster_radius = 8;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_cluster_radius = this->_internal_cluster_radius();
  uint64_t raw_cluster_radius;
  memcpy(&raw_cluster_radius, &tmp_cluster_radius, sizeof(tmp_cluster_radius));
  if (raw_cluster_radius != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(8, this->_internal_cluster_radius(), target);
  }

  // double cluster_density = 9;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_cluster_density = this->_internal_cluster_density();
  uint64_t raw_cluster_density;
  memcpy(&raw_cluster_density, &tmp_cluster_density, sizeof(tmp_cluster_density));
  if (raw_cluster_density != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(9, this->_internal_cluster_density(), target);
  }

  // double processing_time_ms = 10;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_processing_time_ms = this->_internal_processing_time_ms();
  uint64_t raw_processing_time_ms;
  memcpy(&raw_processing_time_ms, &tmp_processing_time_ms, sizeof(tmp_processing_time_ms));
  if (raw_processing_time_ms != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(10, this->_internal_processing_time_ms(), target);
  }

  // map<string, double> algorithm_parameters = 11;
  if (!this->_internal_algorithm_parameters().empty()) {
    using MapType = ::_pb::Map<std::string, double>;
    using WireHelper = DetectionCluster_AlgorithmParametersEntry_DoNotUse::Funcs;
    const auto& map_field = this->_internal_algorithm_parameters();
    auto check_utf8 = [](const MapType::value_type& entry) {
      (void)entry;
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        entry.first.data(), static_cast<int>(entry.first.length()),
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
        "radar.messages.DetectionCluster.AlgorithmParametersEntry.key");
    };

    if (stream->IsSerializationDeterministic() && map_field.size() > 1) {
      for (const auto& entry : ::_pbi::MapSorterPtr<MapType>(map_field)) {
        target = WireHelper::InternalSerialize(11, entry.first, entry.second, target, stream);
        check_utf8(entry);
      }
    } else {
      for (const auto& entry : map_field) {
        target = WireHelper::InternalSerialize(11, entry.first, entry.second, target, stream);
        check_utf8(entry);
      }
    }
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:radar.messages.DetectionCluster)
  return target;
}

size_t DetectionCluster::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:radar.messages.DetectionCluster)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .radar.messages.Detection detections = 2;
  total_size += 1UL * this->_internal_detections_size();
  for (const auto& msg : this->_impl_.detections_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // map<string, double> algorithm_parameters = 11;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_algorithm_parameters_size());
  for (::PROTOBUF_NAMESPACE_ID::Map< std::string, double >::const_iterator
      it = this->_internal_algorithm_parameters().begin();
      it != this->_internal_algorithm_parameters().end(); ++it) {
    total_size += DetectionCluster_AlgorithmParametersEntry_DoNotUse::Funcs::ByteSizeLong(it->first, it->second);
  }

  // .radar.messages.Point3D centroid = 3;
  if (this->_internal_has_centroid()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.centroid_);
  }

  // .radar.messages.Matrix3D covariance = 4;
  if (this->_internal_has_covariance()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.covariance_);
  }

  // .google.protobuf.Timestamp timestamp = 5;
  if (this->_internal_has_timestamp()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.timestamp_);
  }

  // uint32 id = 1;
  if (this->_internal_id() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_id());
  }

  // .radar.messages.DetectionCluster.ClusteringAlgorithm algorithm = 6;
  if (this->_internal_algorithm() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_algorithm());
  }

  // double cluster_radius = 8;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_cluster_radius = this->_internal_cluster_radius();
  uint64_t raw_cluster_radius;
  memcpy(&raw_cluster_radius, &tmp_cluster_radius, sizeof(tmp_cluster_radius));
  if (raw_cluster_radius != 0) {
    total_size += 1 + 8;
  }

  // double cluster_density = 9;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_cluster_density = this->_internal_cluster_density();
  uint64_t raw_cluster_density;
  memcpy(&raw_cluster_density, &tmp_cluster_density, sizeof(tmp_cluster_density));
  if (raw_cluster_density != 0) {
    total_size += 1 + 8;
  }

  // double processing_time_ms = 10;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_processing_time_ms = this->_internal_processing_time_ms();
  uint64_t raw_processing_time_ms;
  memcpy(&raw_processing_time_ms, &tmp_processing_time_ms, sizeof(tmp_processing_time_ms));
  if (raw_processing_time_ms != 0) {
    total_size += 1 + 8;
  }

  // uint32 detection_count = 7;
  if (this->_internal_detection_count() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_detection_count());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData DetectionCluster::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    DetectionCluster::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*DetectionCluster::GetClassData() const { return &_class_data_; }


void DetectionCluster::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<DetectionCluster*>(&to_msg);
  auto& from = static_cast<const DetectionCluster&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:radar.messages.DetectionCluster)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.detections_.MergeFrom(from._impl_.detections_);
  _this->_impl_.algorithm_parameters_.MergeFrom(from._impl_.algorithm_parameters_);
  if (from._internal_has_centroid()) {
    _this->_internal_mutable_centroid()->::radar::messages::Point3D::MergeFrom(
        from._internal_centroid());
  }
  if (from._internal_has_covariance()) {
    _this->_internal_mutable_covariance()->::radar::messages::Matrix3D::MergeFrom(
        from._internal_covariance());
  }
  if (from._internal_has_timestamp()) {
    _this->_internal_mutable_timestamp()->::PROTOBUF_NAMESPACE_ID::Timestamp::MergeFrom(
        from._internal_timestamp());
  }
  if (from._internal_id() != 0) {
    _this->_internal_set_id(from._internal_id());
  }
  if (from._internal_algorithm() != 0) {
    _this->_internal_set_algorithm(from._internal_algorithm());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_cluster_radius = from._internal_cluster_radius();
  uint64_t raw_cluster_radius;
  memcpy(&raw_cluster_radius, &tmp_cluster_radius, sizeof(tmp_cluster_radius));
  if (raw_cluster_radius != 0) {
    _this->_internal_set_cluster_radius(from._internal_cluster_radius());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_cluster_density = from._internal_cluster_density();
  uint64_t raw_cluster_density;
  memcpy(&raw_cluster_density, &tmp_cluster_density, sizeof(tmp_cluster_density));
  if (raw_cluster_density != 0) {
    _this->_internal_set_cluster_density(from._internal_cluster_density());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_processing_time_ms = from._internal_processing_time_ms();
  uint64_t raw_processing_time_ms;
  memcpy(&raw_processing_time_ms, &tmp_processing_time_ms, sizeof(tmp_processing_time_ms));
  if (raw_processing_time_ms != 0) {
    _this->_internal_set_processing_time_ms(from._internal_processing_time_ms());
  }
  if (from._internal_detection_count() != 0) {
    _this->_internal_set_detection_count(from._internal_detection_count());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void DetectionCluster::CopyFrom(const DetectionCluster& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:radar.messages.DetectionCluster)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DetectionCluster::IsInitialized() const {
  return true;
}

void DetectionCluster::InternalSwap(DetectionCluster* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.detections_.InternalSwap(&other->_impl_.detections_);
  _impl_.algorithm_parameters_.InternalSwap(&other->_impl_.algorithm_parameters_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(DetectionCluster, _impl_.detection_count_)
      + sizeof(DetectionCluster::_impl_.detection_count_)
      - PROTOBUF_FIELD_OFFSET(DetectionCluster, _impl_.centroid_)>(
          reinterpret_cast<char*>(&_impl_.centroid_),
          reinterpret_cast<char*>(&other->_impl_.centroid_));
}

::PROTOBUF_NAMESPACE_ID::Metadata DetectionCluster::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_track_5fmessages_2eproto_getter, &descriptor_table_track_5fmessages_2eproto_once,
      file_level_metadata_track_5fmessages_2eproto[9]);
}

// ===================================================================

class Association::_Internal {
 public:
  static const ::radar::messages::Vector3D& innovation(const Association* msg);
  static const ::radar::messages::Matrix3D& innovation_covariance(const Association* msg);
};

const ::radar::messages::Vector3D&
Association::_Internal::innovation(const Association* msg) {
  return *msg->_impl_.innovation_;
}
const ::radar::messages::Matrix3D&
Association::_Internal::innovation_covariance(const Association* msg) {
  return *msg->_impl_.innovation_covariance_;
}
void Association::clear_innovation() {
  if (GetArenaForAllocation() == nullptr && _impl_.innovation_ != nullptr) {
    delete _impl_.innovation_;
  }
  _impl_.innovation_ = nullptr;
}
void Association::clear_innovation_covariance() {
  if (GetArenaForAllocation() == nullptr && _impl_.innovation_covariance_ != nullptr) {
    delete _impl_.innovation_covariance_;
  }
  _impl_.innovation_covariance_ = nullptr;
}
Association::Association(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:radar.messages.Association)
}
Association::Association(const Association& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Association* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.innovation_){nullptr}
    , decltype(_impl_.innovation_covariance_){nullptr}
    , decltype(_impl_.track_id_){}
    , decltype(_impl_.detection_id_){}
    , decltype(_impl_.score_){}
    , decltype(_impl_.distance_){}
    , decltype(_impl_.is_valid_){}
    , decltype(_impl_.algorithm_){}
    , decltype(_impl_.likelihood_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_innovation()) {
    _this->_impl_.innovation_ = new ::radar::messages::Vector3D(*from._impl_.innovation_);
  }
  if (from._internal_has_innovation_covariance()) {
    _this->_impl_.innovation_covariance_ = new ::radar::messages::Matrix3D(*from._impl_.innovation_covariance_);
  }
  ::memcpy(&_impl_.track_id_, &from._impl_.track_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.likelihood_) -
    reinterpret_cast<char*>(&_impl_.track_id_)) + sizeof(_impl_.likelihood_));
  // @@protoc_insertion_point(copy_constructor:radar.messages.Association)
}

inline void Association::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.innovation_){nullptr}
    , decltype(_impl_.innovation_covariance_){nullptr}
    , decltype(_impl_.track_id_){0u}
    , decltype(_impl_.detection_id_){0u}
    , decltype(_impl_.score_){0}
    , decltype(_impl_.distance_){0}
    , decltype(_impl_.is_valid_){false}
    , decltype(_impl_.algorithm_){0}
    , decltype(_impl_.likelihood_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

Association::~Association() {
  // @@protoc_insertion_point(destructor:radar.messages.Association)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Association::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.innovation_;
  if (this != internal_default_instance()) delete _impl_.innovation_covariance_;
}

void Association::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Association::Clear() {
// @@protoc_insertion_point(message_clear_start:radar.messages.Association)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.innovation_ != nullptr) {
    delete _impl_.innovation_;
  }
  _impl_.innovation_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.innovation_covariance_ != nullptr) {
    delete _impl_.innovation_covariance_;
  }
  _impl_.innovation_covariance_ = nullptr;
  ::memset(&_impl_.track_id_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.likelihood_) -
      reinterpret_cast<char*>(&_impl_.track_id_)) + sizeof(_impl_.likelihood_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Association::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint32 track_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.track_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 detection_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.detection_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // double score = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 25)) {
          _impl_.score_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double distance = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 33)) {
          _impl_.distance_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // bool is_valid = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _impl_.is_valid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .radar.messages.Vector3D innovation = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_innovation(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .radar.messages.Matrix3D innovation_covariance = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_innovation_covariance(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // double likelihood = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 65)) {
          _impl_.likelihood_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // .radar.messages.Association.AssociationAlgorithm algorithm = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_algorithm(static_cast<::radar::messages::Association_AssociationAlgorithm>(val));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Association::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:radar.messages.Association)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint32 track_id = 1;
  if (this->_internal_track_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_track_id(), target);
  }

  // uint32 detection_id = 2;
  if (this->_internal_detection_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_detection_id(), target);
  }

  // double score = 3;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_score = this->_internal_score();
  uint64_t raw_score;
  memcpy(&raw_score, &tmp_score, sizeof(tmp_score));
  if (raw_score != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(3, this->_internal_score(), target);
  }

  // double distance = 4;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_distance = this->_internal_distance();
  uint64_t raw_distance;
  memcpy(&raw_distance, &tmp_distance, sizeof(tmp_distance));
  if (raw_distance != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(4, this->_internal_distance(), target);
  }

  // bool is_valid = 5;
  if (this->_internal_is_valid() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(5, this->_internal_is_valid(), target);
  }

  // .radar.messages.Vector3D innovation = 6;
  if (this->_internal_has_innovation()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, _Internal::innovation(this),
        _Internal::innovation(this).GetCachedSize(), target, stream);
  }

  // .radar.messages.Matrix3D innovation_covariance = 7;
  if (this->_internal_has_innovation_covariance()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(7, _Internal::innovation_covariance(this),
        _Internal::innovation_covariance(this).GetCachedSize(), target, stream);
  }

  // double likelihood = 8;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_likelihood = this->_internal_likelihood();
  uint64_t raw_likelihood;
  memcpy(&raw_likelihood, &tmp_likelihood, sizeof(tmp_likelihood));
  if (raw_likelihood != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(8, this->_internal_likelihood(), target);
  }

  // .radar.messages.Association.AssociationAlgorithm algorithm = 9;
  if (this->_internal_algorithm() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      9, this->_internal_algorithm(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:radar.messages.Association)
  return target;
}

size_t Association::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:radar.messages.Association)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .radar.messages.Vector3D innovation = 6;
  if (this->_internal_has_innovation()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.innovation_);
  }

  // .radar.messages.Matrix3D innovation_covariance = 7;
  if (this->_internal_has_innovation_covariance()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.innovation_covariance_);
  }

  // uint32 track_id = 1;
  if (this->_internal_track_id() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_track_id());
  }

  // uint32 detection_id = 2;
  if (this->_internal_detection_id() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_detection_id());
  }

  // double score = 3;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_score = this->_internal_score();
  uint64_t raw_score;
  memcpy(&raw_score, &tmp_score, sizeof(tmp_score));
  if (raw_score != 0) {
    total_size += 1 + 8;
  }

  // double distance = 4;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_distance = this->_internal_distance();
  uint64_t raw_distance;
  memcpy(&raw_distance, &tmp_distance, sizeof(tmp_distance));
  if (raw_distance != 0) {
    total_size += 1 + 8;
  }

  // bool is_valid = 5;
  if (this->_internal_is_valid() != 0) {
    total_size += 1 + 1;
  }

  // .radar.messages.Association.AssociationAlgorithm algorithm = 9;
  if (this->_internal_algorithm() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_algorithm());
  }

  // double likelihood = 8;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_likelihood = this->_internal_likelihood();
  uint64_t raw_likelihood;
  memcpy(&raw_likelihood, &tmp_likelihood, sizeof(tmp_likelihood));
  if (raw_likelihood != 0) {
    total_size += 1 + 8;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Association::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Association::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Association::GetClassData() const { return &_class_data_; }


void Association::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Association*>(&to_msg);
  auto& from = static_cast<const Association&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:radar.messages.Association)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_innovation()) {
    _this->_internal_mutable_innovation()->::radar::messages::Vector3D::MergeFrom(
        from._internal_innovation());
  }
  if (from._internal_has_innovation_covariance()) {
    _this->_internal_mutable_innovation_covariance()->::radar::messages::Matrix3D::MergeFrom(
        from._internal_innovation_covariance());
  }
  if (from._internal_track_id() != 0) {
    _this->_internal_set_track_id(from._internal_track_id());
  }
  if (from._internal_detection_id() != 0) {
    _this->_internal_set_detection_id(from._internal_detection_id());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_score = from._internal_score();
  uint64_t raw_score;
  memcpy(&raw_score, &tmp_score, sizeof(tmp_score));
  if (raw_score != 0) {
    _this->_internal_set_score(from._internal_score());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_distance = from._internal_distance();
  uint64_t raw_distance;
  memcpy(&raw_distance, &tmp_distance, sizeof(tmp_distance));
  if (raw_distance != 0) {
    _this->_internal_set_distance(from._internal_distance());
  }
  if (from._internal_is_valid() != 0) {
    _this->_internal_set_is_valid(from._internal_is_valid());
  }
  if (from._internal_algorithm() != 0) {
    _this->_internal_set_algorithm(from._internal_algorithm());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_likelihood = from._internal_likelihood();
  uint64_t raw_likelihood;
  memcpy(&raw_likelihood, &tmp_likelihood, sizeof(tmp_likelihood));
  if (raw_likelihood != 0) {
    _this->_internal_set_likelihood(from._internal_likelihood());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Association::CopyFrom(const Association& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:radar.messages.Association)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Association::IsInitialized() const {
  return true;
}

void Association::InternalSwap(Association* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Association, _impl_.likelihood_)
      + sizeof(Association::_impl_.likelihood_)
      - PROTOBUF_FIELD_OFFSET(Association, _impl_.innovation_)>(
          reinterpret_cast<char*>(&_impl_.innovation_),
          reinterpret_cast<char*>(&other->_impl_.innovation_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Association::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_track_5fmessages_2eproto_getter, &descriptor_table_track_5fmessages_2eproto_once,
      file_level_metadata_track_5fmessages_2eproto[10]);
}

// ===================================================================

FusionData_SensorWeightsEntry_DoNotUse::FusionData_SensorWeightsEntry_DoNotUse() {}
FusionData_SensorWeightsEntry_DoNotUse::FusionData_SensorWeightsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
    : SuperType(arena) {}
void FusionData_SensorWeightsEntry_DoNotUse::MergeFrom(const FusionData_SensorWeightsEntry_DoNotUse& other) {
  MergeFromInternal(other);
}
::PROTOBUF_NAMESPACE_ID::Metadata FusionData_SensorWeightsEntry_DoNotUse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_track_5fmessages_2eproto_getter, &descriptor_table_track_5fmessages_2eproto_once,
      file_level_metadata_track_5fmessages_2eproto[11]);
}

// ===================================================================

class FusionData::_Internal {
 public:
  static const ::PROTOBUF_NAMESPACE_ID::Timestamp& timestamp(const FusionData* msg);
};

const ::PROTOBUF_NAMESPACE_ID::Timestamp&
FusionData::_Internal::timestamp(const FusionData* msg) {
  return *msg->_impl_.timestamp_;
}
void FusionData::clear_timestamp() {
  if (GetArenaForAllocation() == nullptr && _impl_.timestamp_ != nullptr) {
    delete _impl_.timestamp_;
  }
  _impl_.timestamp_ = nullptr;
}
FusionData::FusionData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  if (arena != nullptr && !is_message_owned) {
    arena->OwnCustomDestructor(this, &FusionData::ArenaDtor);
  }
  // @@protoc_insertion_point(arena_constructor:radar.messages.FusionData)
}
FusionData::FusionData(const FusionData& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  FusionData* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.fused_tracks_){from._impl_.fused_tracks_}
    , decltype(_impl_.contributing_sensors_){from._impl_.contributing_sensors_}
    , /*decltype(_impl_._contributing_sensors_cached_byte_size_)*/{0}
    , /*decltype(_impl_.sensor_weights_)*/{}
    , decltype(_impl_.fusion_algorithm_){}
    , decltype(_impl_.timestamp_){nullptr}
    , decltype(_impl_.fusion_id_){}
    , decltype(_impl_.redundant_tracks_){}
    , decltype(_impl_.fusion_quality_){}
    , decltype(_impl_.cross_correlation_){}
    , decltype(_impl_.position_uncertainty_){}
    , decltype(_impl_.velocity_uncertainty_){}
    , decltype(_impl_.fusion_time_ms_){}
    , decltype(_impl_.unique_tracks_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.sensor_weights_.MergeFrom(from._impl_.sensor_weights_);
  _impl_.fusion_algorithm_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.fusion_algorithm_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_fusion_algorithm().empty()) {
    _this->_impl_.fusion_algorithm_.Set(from._internal_fusion_algorithm(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_timestamp()) {
    _this->_impl_.timestamp_ = new ::PROTOBUF_NAMESPACE_ID::Timestamp(*from._impl_.timestamp_);
  }
  ::memcpy(&_impl_.fusion_id_, &from._impl_.fusion_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.unique_tracks_) -
    reinterpret_cast<char*>(&_impl_.fusion_id_)) + sizeof(_impl_.unique_tracks_));
  // @@protoc_insertion_point(copy_constructor:radar.messages.FusionData)
}

inline void FusionData::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.fused_tracks_){arena}
    , decltype(_impl_.contributing_sensors_){arena}
    , /*decltype(_impl_._contributing_sensors_cached_byte_size_)*/{0}
    , /*decltype(_impl_.sensor_weights_)*/{::_pbi::ArenaInitialized(), arena}
    , decltype(_impl_.fusion_algorithm_){}
    , decltype(_impl_.timestamp_){nullptr}
    , decltype(_impl_.fusion_id_){0u}
    , decltype(_impl_.redundant_tracks_){0u}
    , decltype(_impl_.fusion_quality_){0}
    , decltype(_impl_.cross_correlation_){0}
    , decltype(_impl_.position_uncertainty_){0}
    , decltype(_impl_.velocity_uncertainty_){0}
    , decltype(_impl_.fusion_time_ms_){0}
    , decltype(_impl_.unique_tracks_){0u}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.fusion_algorithm_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.fusion_algorithm_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

FusionData::~FusionData() {
  // @@protoc_insertion_point(destructor:radar.messages.FusionData)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    ArenaDtor(this);
    return;
  }
  SharedDtor();
}

inline void FusionData::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.fused_tracks_.~RepeatedPtrField();
  _impl_.contributing_sensors_.~RepeatedField();
  _impl_.sensor_weights_.Destruct();
  _impl_.sensor_weights_.~MapField();
  _impl_.fusion_algorithm_.Destroy();
  if (this != internal_default_instance()) delete _impl_.timestamp_;
}

void FusionData::ArenaDtor(void* object) {
  FusionData* _this = reinterpret_cast< FusionData* >(object);
  _this->_impl_.sensor_weights_.Destruct();
}
void FusionData::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void FusionData::Clear() {
// @@protoc_insertion_point(message_clear_start:radar.messages.FusionData)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.fused_tracks_.Clear();
  _impl_.contributing_sensors_.Clear();
  _impl_.sensor_weights_.Clear();
  _impl_.fusion_algorithm_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && _impl_.timestamp_ != nullptr) {
    delete _impl_.timestamp_;
  }
  _impl_.timestamp_ = nullptr;
  ::memset(&_impl_.fusion_id_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.unique_tracks_) -
      reinterpret_cast<char*>(&_impl_.fusion_id_)) + sizeof(_impl_.unique_tracks_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* FusionData::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .google.protobuf.Timestamp timestamp = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_timestamp(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 fusion_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.fusion_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .radar.messages.Track fused_tracks = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_fused_tracks(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated uint32 contributing_sensors = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt32Parser(_internal_mutable_contributing_sensors(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 32) {
          _internal_add_contributing_sensors(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // map<uint32, double> sensor_weights = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(&_impl_.sensor_weights_, ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<42>(ptr));
        } else
          goto handle_unusual;
        continue;
      // double fusion_quality = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 49)) {
          _impl_.fusion_quality_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double cross_correlation = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 57)) {
          _impl_.cross_correlation_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // uint32 redundant_tracks = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _impl_.redundant_tracks_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 unique_tracks = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _impl_.unique_tracks_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // double position_uncertainty = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 81)) {
          _impl_.position_uncertainty_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double velocity_uncertainty = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 89)) {
          _impl_.velocity_uncertainty_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double fusion_time_ms = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 97)) {
          _impl_.fusion_time_ms_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // string fusion_algorithm = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 106)) {
          auto str = _internal_mutable_fusion_algorithm();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "radar.messages.FusionData.fusion_algorithm"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* FusionData::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:radar.messages.FusionData)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .google.protobuf.Timestamp timestamp = 1;
  if (this->_internal_has_timestamp()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::timestamp(this),
        _Internal::timestamp(this).GetCachedSize(), target, stream);
  }

  // uint32 fusion_id = 2;
  if (this->_internal_fusion_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_fusion_id(), target);
  }

  // repeated .radar.messages.Track fused_tracks = 3;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_fused_tracks_size()); i < n; i++) {
    const auto& repfield = this->_internal_fused_tracks(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated uint32 contributing_sensors = 4;
  {
    int byte_size = _impl_._contributing_sensors_cached_byte_size_.load(std::memory_order_relaxed);
    if (byte_size > 0) {
      target = stream->WriteUInt32Packed(
          4, _internal_contributing_sensors(), byte_size, target);
    }
  }

  // map<uint32, double> sensor_weights = 5;
  if (!this->_internal_sensor_weights().empty()) {
    using MapType = ::_pb::Map<uint32_t, double>;
    using WireHelper = FusionData_SensorWeightsEntry_DoNotUse::Funcs;
    const auto& map_field = this->_internal_sensor_weights();

    if (stream->IsSerializationDeterministic() && map_field.size() > 1) {
      for (const auto& entry : ::_pbi::MapSorterFlat<MapType>(map_field)) {
        target = WireHelper::InternalSerialize(5, entry.first, entry.second, target, stream);
      }
    } else {
      for (const auto& entry : map_field) {
        target = WireHelper::InternalSerialize(5, entry.first, entry.second, target, stream);
      }
    }
  }

  // double fusion_quality = 6;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_fusion_quality = this->_internal_fusion_quality();
  uint64_t raw_fusion_quality;
  memcpy(&raw_fusion_quality, &tmp_fusion_quality, sizeof(tmp_fusion_quality));
  if (raw_fusion_quality != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(6, this->_internal_fusion_quality(), target);
  }

  // double cross_correlation = 7;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_cross_correlation = this->_internal_cross_correlation();
  uint64_t raw_cross_correlation;
  memcpy(&raw_cross_correlation, &tmp_cross_correlation, sizeof(tmp_cross_correlation));
  if (raw_cross_correlation != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(7, this->_internal_cross_correlation(), target);
  }

  // uint32 redundant_tracks = 8;
  if (this->_internal_redundant_tracks() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(8, this->_internal_redundant_tracks(), target);
  }

  // uint32 unique_tracks = 9;
  if (this->_internal_unique_tracks() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(9, this->_internal_unique_tracks(), target);
  }

  // double position_uncertainty = 10;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_position_uncertainty = this->_internal_position_uncertainty();
  uint64_t raw_position_uncertainty;
  memcpy(&raw_position_uncertainty, &tmp_position_uncertainty, sizeof(tmp_position_uncertainty));
  if (raw_position_uncertainty != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(10, this->_internal_position_uncertainty(), target);
  }

  // double velocity_uncertainty = 11;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_velocity_uncertainty = this->_internal_velocity_uncertainty();
  uint64_t raw_velocity_uncertainty;
  memcpy(&raw_velocity_uncertainty, &tmp_velocity_uncertainty, sizeof(tmp_velocity_uncertainty));
  if (raw_velocity_uncertainty != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(11, this->_internal_velocity_uncertainty(), target);
  }

  // double fusion_time_ms = 12;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_fusion_time_ms = this->_internal_fusion_time_ms();
  uint64_t raw_fusion_time_ms;
  memcpy(&raw_fusion_time_ms, &tmp_fusion_time_ms, sizeof(tmp_fusion_time_ms));
  if (raw_fusion_time_ms != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(12, this->_internal_fusion_time_ms(), target);
  }

  // string fusion_algorithm = 13;
  if (!this->_internal_fusion_algorithm().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_fusion_algorithm().data(), static_cast<int>(this->_internal_fusion_algorithm().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "radar.messages.FusionData.fusion_algorithm");
    target = stream->WriteStringMaybeAliased(
        13, this->_internal_fusion_algorithm(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:radar.messages.FusionData)
  return target;
}

size_t FusionData::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:radar.messages.FusionData)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .radar.messages.Track fused_tracks = 3;
  total_size += 1UL * this->_internal_fused_tracks_size();
  for (const auto& msg : this->_impl_.fused_tracks_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated uint32 contributing_sensors = 4;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      UInt32Size(this->_impl_.contributing_sensors_);
    if (data_size > 0) {
      total_size += 1 +
        ::_pbi::WireFormatLite::Int32Size(static_cast<int32_t>(data_size));
    }
    int cached_size = ::_pbi::ToCachedSize(data_size);
    _impl_._contributing_sensors_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  // map<uint32, double> sensor_weights = 5;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_sensor_weights_size());
  for (::PROTOBUF_NAMESPACE_ID::Map< uint32_t, double >::const_iterator
      it = this->_internal_sensor_weights().begin();
      it != this->_internal_sensor_weights().end(); ++it) {
    total_size += FusionData_SensorWeightsEntry_DoNotUse::Funcs::ByteSizeLong(it->first, it->second);
  }

  // string fusion_algorithm = 13;
  if (!this->_internal_fusion_algorithm().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_fusion_algorithm());
  }

  // .google.protobuf.Timestamp timestamp = 1;
  if (this->_internal_has_timestamp()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.timestamp_);
  }

  // uint32 fusion_id = 2;
  if (this->_internal_fusion_id() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_fusion_id());
  }

  // uint32 redundant_tracks = 8;
  if (this->_internal_redundant_tracks() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_redundant_tracks());
  }

  // double fusion_quality = 6;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_fusion_quality = this->_internal_fusion_quality();
  uint64_t raw_fusion_quality;
  memcpy(&raw_fusion_quality, &tmp_fusion_quality, sizeof(tmp_fusion_quality));
  if (raw_fusion_quality != 0) {
    total_size += 1 + 8;
  }

  // double cross_correlation = 7;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_cross_correlation = this->_internal_cross_correlation();
  uint64_t raw_cross_correlation;
  memcpy(&raw_cross_correlation, &tmp_cross_correlation, sizeof(tmp_cross_correlation));
  if (raw_cross_correlation != 0) {
    total_size += 1 + 8;
  }

  // double position_uncertainty = 10;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_position_uncertainty = this->_internal_position_uncertainty();
  uint64_t raw_position_uncertainty;
  memcpy(&raw_position_uncertainty, &tmp_position_uncertainty, sizeof(tmp_position_uncertainty));
  if (raw_position_uncertainty != 0) {
    total_size += 1 + 8;
  }

  // double velocity_uncertainty = 11;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_velocity_uncertainty = this->_internal_velocity_uncertainty();
  uint64_t raw_velocity_uncertainty;
  memcpy(&raw_velocity_uncertainty, &tmp_velocity_uncertainty, sizeof(tmp_velocity_uncertainty));
  if (raw_velocity_uncertainty != 0) {
    total_size += 1 + 8;
  }

  // double fusion_time_ms = 12;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_fusion_time_ms = this->_internal_fusion_time_ms();
  uint64_t raw_fusion_time_ms;
  memcpy(&raw_fusion_time_ms, &tmp_fusion_time_ms, sizeof(tmp_fusion_time_ms));
  if (raw_fusion_time_ms != 0) {
    total_size += 1 + 8;
  }

  // uint32 unique_tracks = 9;
  if (this->_internal_unique_tracks() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_unique_tracks());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData FusionData::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    FusionData::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*FusionData::GetClassData() const { return &_class_data_; }


void FusionData::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<FusionData*>(&to_msg);
  auto& from = static_cast<const FusionData&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:radar.messages.FusionData)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.fused_tracks_.MergeFrom(from._impl_.fused_tracks_);
  _this->_impl_.contributing_sensors_.MergeFrom(from._impl_.contributing_sensors_);
  _this->_impl_.sensor_weights_.MergeFrom(from._impl_.sensor_weights_);
  if (!from._internal_fusion_algorithm().empty()) {
    _this->_internal_set_fusion_algorithm(from._internal_fusion_algorithm());
  }
  if (from._internal_has_timestamp()) {
    _this->_internal_mutable_timestamp()->::PROTOBUF_NAMESPACE_ID::Timestamp::MergeFrom(
        from._internal_timestamp());
  }
  if (from._internal_fusion_id() != 0) {
    _this->_internal_set_fusion_id(from._internal_fusion_id());
  }
  if (from._internal_redundant_tracks() != 0) {
    _this->_internal_set_redundant_tracks(from._internal_redundant_tracks());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_fusion_quality = from._internal_fusion_quality();
  uint64_t raw_fusion_quality;
  memcpy(&raw_fusion_quality, &tmp_fusion_quality, sizeof(tmp_fusion_quality));
  if (raw_fusion_quality != 0) {
    _this->_internal_set_fusion_quality(from._internal_fusion_quality());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_cross_correlation = from._internal_cross_correlation();
  uint64_t raw_cross_correlation;
  memcpy(&raw_cross_correlation, &tmp_cross_correlation, sizeof(tmp_cross_correlation));
  if (raw_cross_correlation != 0) {
    _this->_internal_set_cross_correlation(from._internal_cross_correlation());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_position_uncertainty = from._internal_position_uncertainty();
  uint64_t raw_position_uncertainty;
  memcpy(&raw_position_uncertainty, &tmp_position_uncertainty, sizeof(tmp_position_uncertainty));
  if (raw_position_uncertainty != 0) {
    _this->_internal_set_position_uncertainty(from._internal_position_uncertainty());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_velocity_uncertainty = from._internal_velocity_uncertainty();
  uint64_t raw_velocity_uncertainty;
  memcpy(&raw_velocity_uncertainty, &tmp_velocity_uncertainty, sizeof(tmp_velocity_uncertainty));
  if (raw_velocity_uncertainty != 0) {
    _this->_internal_set_velocity_uncertainty(from._internal_velocity_uncertainty());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_fusion_time_ms = from._internal_fusion_time_ms();
  uint64_t raw_fusion_time_ms;
  memcpy(&raw_fusion_time_ms, &tmp_fusion_time_ms, sizeof(tmp_fusion_time_ms));
  if (raw_fusion_time_ms != 0) {
    _this->_internal_set_fusion_time_ms(from._internal_fusion_time_ms());
  }
  if (from._internal_unique_tracks() != 0) {
    _this->_internal_set_unique_tracks(from._internal_unique_tracks());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void FusionData::CopyFrom(const FusionData& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:radar.messages.FusionData)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FusionData::IsInitialized() const {
  return true;
}

void FusionData::InternalSwap(FusionData* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.fused_tracks_.InternalSwap(&other->_impl_.fused_tracks_);
  _impl_.contributing_sensors_.InternalSwap(&other->_impl_.contributing_sensors_);
  _impl_.sensor_weights_.InternalSwap(&other->_impl_.sensor_weights_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.fusion_algorithm_, lhs_arena,
      &other->_impl_.fusion_algorithm_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(FusionData, _impl_.unique_tracks_)
      + sizeof(FusionData::_impl_.unique_tracks_)
      - PROTOBUF_FIELD_OFFSET(FusionData, _impl_.timestamp_)>(
          reinterpret_cast<char*>(&_impl_.timestamp_),
          reinterpret_cast<char*>(&other->_impl_.timestamp_));
}

::PROTOBUF_NAMESPACE_ID::Metadata FusionData::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_track_5fmessages_2eproto_getter, &descriptor_table_track_5fmessages_2eproto_once,
      file_level_metadata_track_5fmessages_2eproto[12]);
}

// ===================================================================

class ThreatAssessment::_Internal {
 public:
  static const ::PROTOBUF_NAMESPACE_ID::Timestamp& timestamp(const ThreatAssessment* msg);
  static const ::radar::messages::Point3D& predicted_intercept(const ThreatAssessment* msg);
};

const ::PROTOBUF_NAMESPACE_ID::Timestamp&
ThreatAssessment::_Internal::timestamp(const ThreatAssessment* msg) {
  return *msg->_impl_.timestamp_;
}
const ::radar::messages::Point3D&
ThreatAssessment::_Internal::predicted_intercept(const ThreatAssessment* msg) {
  return *msg->_impl_.predicted_intercept_;
}
void ThreatAssessment::clear_timestamp() {
  if (GetArenaForAllocation() == nullptr && _impl_.timestamp_ != nullptr) {
    delete _impl_.timestamp_;
  }
  _impl_.timestamp_ = nullptr;
}
void ThreatAssessment::clear_predicted_intercept() {
  if (GetArenaForAllocation() == nullptr && _impl_.predicted_intercept_ != nullptr) {
    delete _impl_.predicted_intercept_;
  }
  _impl_.predicted_intercept_ = nullptr;
}
ThreatAssessment::ThreatAssessment(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:radar.messages.ThreatAssessment)
}
ThreatAssessment::ThreatAssessment(const ThreatAssessment& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ThreatAssessment* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.recommended_actions_){from._impl_.recommended_actions_}
    , decltype(_impl_.priority_){}
    , decltype(_impl_.timestamp_){nullptr}
    , decltype(_impl_.predicted_intercept_){nullptr}
    , decltype(_impl_.track_id_){}
    , decltype(_impl_.threat_level_){}
    , decltype(_impl_.threat_score_){}
    , decltype(_impl_.proximity_factor_){}
    , decltype(_impl_.velocity_factor_){}
    , decltype(_impl_.trajectory_factor_){}
    , decltype(_impl_.classification_factor_){}
    , decltype(_impl_.time_to_intercept_seconds_){}
    , decltype(_impl_.intercept_probability_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.priority_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.priority_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_priority().empty()) {
    _this->_impl_.priority_.Set(from._internal_priority(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_timestamp()) {
    _this->_impl_.timestamp_ = new ::PROTOBUF_NAMESPACE_ID::Timestamp(*from._impl_.timestamp_);
  }
  if (from._internal_has_predicted_intercept()) {
    _this->_impl_.predicted_intercept_ = new ::radar::messages::Point3D(*from._impl_.predicted_intercept_);
  }
  ::memcpy(&_impl_.track_id_, &from._impl_.track_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.intercept_probability_) -
    reinterpret_cast<char*>(&_impl_.track_id_)) + sizeof(_impl_.intercept_probability_));
  // @@protoc_insertion_point(copy_constructor:radar.messages.ThreatAssessment)
}

inline void ThreatAssessment::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.recommended_actions_){arena}
    , decltype(_impl_.priority_){}
    , decltype(_impl_.timestamp_){nullptr}
    , decltype(_impl_.predicted_intercept_){nullptr}
    , decltype(_impl_.track_id_){0u}
    , decltype(_impl_.threat_level_){0}
    , decltype(_impl_.threat_score_){0}
    , decltype(_impl_.proximity_factor_){0}
    , decltype(_impl_.velocity_factor_){0}
    , decltype(_impl_.trajectory_factor_){0}
    , decltype(_impl_.classification_factor_){0}
    , decltype(_impl_.time_to_intercept_seconds_){0}
    , decltype(_impl_.intercept_probability_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.priority_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.priority_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ThreatAssessment::~ThreatAssessment() {
  // @@protoc_insertion_point(destructor:radar.messages.ThreatAssessment)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ThreatAssessment::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.recommended_actions_.~RepeatedPtrField();
  _impl_.priority_.Destroy();
  if (this != internal_default_instance()) delete _impl_.timestamp_;
  if (this != internal_default_instance()) delete _impl_.predicted_intercept_;
}

void ThreatAssessment::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ThreatAssessment::Clear() {
// @@protoc_insertion_point(message_clear_start:radar.messages.ThreatAssessment)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.recommended_actions_.Clear();
  _impl_.priority_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && _impl_.timestamp_ != nullptr) {
    delete _impl_.timestamp_;
  }
  _impl_.timestamp_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.predicted_intercept_ != nullptr) {
    delete _impl_.predicted_intercept_;
  }
  _impl_.predicted_intercept_ = nullptr;
  ::memset(&_impl_.track_id_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.intercept_probability_) -
      reinterpret_cast<char*>(&_impl_.track_id_)) + sizeof(_impl_.intercept_probability_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ThreatAssessment::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint32 track_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.track_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .google.protobuf.Timestamp timestamp = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_timestamp(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .radar.messages.ThreatAssessment.ThreatLevel threat_level = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_threat_level(static_cast<::radar::messages::ThreatAssessment_ThreatLevel>(val));
        } else
          goto handle_unusual;
        continue;
      // double threat_score = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 33)) {
          _impl_.threat_score_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double proximity_factor = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 41)) {
          _impl_.proximity_factor_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double velocity_factor = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 49)) {
          _impl_.velocity_factor_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double trajectory_factor = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 57)) {
          _impl_.trajectory_factor_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double classification_factor = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 65)) {
          _impl_.classification_factor_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // .radar.messages.Point3D predicted_intercept = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          ptr = ctx->ParseMessage(_internal_mutable_predicted_intercept(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // double time_to_intercept_seconds = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 81)) {
          _impl_.time_to_intercept_seconds_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double intercept_probability = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 89)) {
          _impl_.intercept_probability_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // repeated string recommended_actions = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 98)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_recommended_actions();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            CHK_(::_pbi::VerifyUTF8(str, "radar.messages.ThreatAssessment.recommended_actions"));
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<98>(ptr));
        } else
          goto handle_unusual;
        continue;
      // string priority = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 106)) {
          auto str = _internal_mutable_priority();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "radar.messages.ThreatAssessment.priority"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ThreatAssessment::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:radar.messages.ThreatAssessment)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint32 track_id = 1;
  if (this->_internal_track_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_track_id(), target);
  }

  // .google.protobuf.Timestamp timestamp = 2;
  if (this->_internal_has_timestamp()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::timestamp(this),
        _Internal::timestamp(this).GetCachedSize(), target, stream);
  }

  // .radar.messages.ThreatAssessment.ThreatLevel threat_level = 3;
  if (this->_internal_threat_level() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      3, this->_internal_threat_level(), target);
  }

  // double threat_score = 4;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_threat_score = this->_internal_threat_score();
  uint64_t raw_threat_score;
  memcpy(&raw_threat_score, &tmp_threat_score, sizeof(tmp_threat_score));
  if (raw_threat_score != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(4, this->_internal_threat_score(), target);
  }

  // double proximity_factor = 5;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_proximity_factor = this->_internal_proximity_factor();
  uint64_t raw_proximity_factor;
  memcpy(&raw_proximity_factor, &tmp_proximity_factor, sizeof(tmp_proximity_factor));
  if (raw_proximity_factor != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(5, this->_internal_proximity_factor(), target);
  }

  // double velocity_factor = 6;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_velocity_factor = this->_internal_velocity_factor();
  uint64_t raw_velocity_factor;
  memcpy(&raw_velocity_factor, &tmp_velocity_factor, sizeof(tmp_velocity_factor));
  if (raw_velocity_factor != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(6, this->_internal_velocity_factor(), target);
  }

  // double trajectory_factor = 7;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_trajectory_factor = this->_internal_trajectory_factor();
  uint64_t raw_trajectory_factor;
  memcpy(&raw_trajectory_factor, &tmp_trajectory_factor, sizeof(tmp_trajectory_factor));
  if (raw_trajectory_factor != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(7, this->_internal_trajectory_factor(), target);
  }

  // double classification_factor = 8;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_classification_factor = this->_internal_classification_factor();
  uint64_t raw_classification_factor;
  memcpy(&raw_classification_factor, &tmp_classification_factor, sizeof(tmp_classification_factor));
  if (raw_classification_factor != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(8, this->_internal_classification_factor(), target);
  }

  // .radar.messages.Point3D predicted_intercept = 9;
  if (this->_internal_has_predicted_intercept()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(9, _Internal::predicted_intercept(this),
        _Internal::predicted_intercept(this).GetCachedSize(), target, stream);
  }

  // double time_to_intercept_seconds = 10;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_time_to_intercept_seconds = this->_internal_time_to_intercept_seconds();
  uint64_t raw_time_to_intercept_seconds;
  memcpy(&raw_time_to_intercept_seconds, &tmp_time_to_intercept_seconds, sizeof(tmp_time_to_intercept_seconds));
  if (raw_time_to_intercept_seconds != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(10, this->_internal_time_to_intercept_seconds(), target);
  }

  // double intercept_probability = 11;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_intercept_probability = this->_internal_intercept_probability();
  uint64_t raw_intercept_probability;
  memcpy(&raw_intercept_probability, &tmp_intercept_probability, sizeof(tmp_intercept_probability));
  if (raw_intercept_probability != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(11, this->_internal_intercept_probability(), target);
  }

  // repeated string recommended_actions = 12;
  for (int i = 0, n = this->_internal_recommended_actions_size(); i < n; i++) {
    const auto& s = this->_internal_recommended_actions(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "radar.messages.ThreatAssessment.recommended_actions");
    target = stream->WriteString(12, s, target);
  }

  // string priority = 13;
  if (!this->_internal_priority().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_priority().data(), static_cast<int>(this->_internal_priority().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "radar.messages.ThreatAssessment.priority");
    target = stream->WriteStringMaybeAliased(
        13, this->_internal_priority(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:radar.messages.ThreatAssessment)
  return target;
}

size_t ThreatAssessment::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:radar.messages.ThreatAssessment)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string recommended_actions = 12;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.recommended_actions_.size());
  for (int i = 0, n = _impl_.recommended_actions_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      _impl_.recommended_actions_.Get(i));
  }

  // string priority = 13;
  if (!this->_internal_priority().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_priority());
  }

  // .google.protobuf.Timestamp timestamp = 2;
  if (this->_internal_has_timestamp()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.timestamp_);
  }

  // .radar.messages.Point3D predicted_intercept = 9;
  if (this->_internal_has_predicted_intercept()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.predicted_intercept_);
  }

  // uint32 track_id = 1;
  if (this->_internal_track_id() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_track_id());
  }

  // .radar.messages.ThreatAssessment.ThreatLevel threat_level = 3;
  if (this->_internal_threat_level() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_threat_level());
  }

  // double threat_score = 4;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_threat_score = this->_internal_threat_score();
  uint64_t raw_threat_score;
  memcpy(&raw_threat_score, &tmp_threat_score, sizeof(tmp_threat_score));
  if (raw_threat_score != 0) {
    total_size += 1 + 8;
  }

  // double proximity_factor = 5;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_proximity_factor = this->_internal_proximity_factor();
  uint64_t raw_proximity_factor;
  memcpy(&raw_proximity_factor, &tmp_proximity_factor, sizeof(tmp_proximity_factor));
  if (raw_proximity_factor != 0) {
    total_size += 1 + 8;
  }

  // double velocity_factor = 6;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_velocity_factor = this->_internal_velocity_factor();
  uint64_t raw_velocity_factor;
  memcpy(&raw_velocity_factor, &tmp_velocity_factor, sizeof(tmp_velocity_factor));
  if (raw_velocity_factor != 0) {
    total_size += 1 + 8;
  }

  // double trajectory_factor = 7;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_trajectory_factor = this->_internal_trajectory_factor();
  uint64_t raw_trajectory_factor;
  memcpy(&raw_trajectory_factor, &tmp_trajectory_factor, sizeof(tmp_trajectory_factor));
  if (raw_trajectory_factor != 0) {
    total_size += 1 + 8;
  }

  // double classification_factor = 8;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_classification_factor = this->_internal_classification_factor();
  uint64_t raw_classification_factor;
  memcpy(&raw_classification_factor, &tmp_classification_factor, sizeof(tmp_classification_factor));
  if (raw_classification_factor != 0) {
    total_size += 1 + 8;
  }

  // double time_to_intercept_seconds = 10;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_time_to_intercept_seconds = this->_internal_time_to_intercept_seconds();
  uint64_t raw_time_to_intercept_seconds;
  memcpy(&raw_time_to_intercept_seconds, &tmp_time_to_intercept_seconds, sizeof(tmp_time_to_intercept_seconds));
  if (raw_time_to_intercept_seconds != 0) {
    total_size += 1 + 8;
  }

  // double intercept_probability = 11;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_intercept_probability = this->_internal_intercept_probability();
  uint64_t raw_intercept_probability;
  memcpy(&raw_intercept_probability, &tmp_intercept_probability, sizeof(tmp_intercept_probability));
  if (raw_intercept_probability != 0) {
    total_size += 1 + 8;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ThreatAssessment::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ThreatAssessment::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ThreatAssessment::GetClassData() const { return &_class_data_; }


void ThreatAssessment::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ThreatAssessment*>(&to_msg);
  auto& from = static_cast<const ThreatAssessment&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:radar.messages.ThreatAssessment)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.recommended_actions_.MergeFrom(from._impl_.recommended_actions_);
  if (!from._internal_priority().empty()) {
    _this->_internal_set_priority(from._internal_priority());
  }
  if (from._internal_has_timestamp()) {
    _this->_internal_mutable_timestamp()->::PROTOBUF_NAMESPACE_ID::Timestamp::MergeFrom(
        from._internal_timestamp());
  }
  if (from._internal_has_predicted_intercept()) {
    _this->_internal_mutable_predicted_intercept()->::radar::messages::Point3D::MergeFrom(
        from._internal_predicted_intercept());
  }
  if (from._internal_track_id() != 0) {
    _this->_internal_set_track_id(from._internal_track_id());
  }
  if (from._internal_threat_level() != 0) {
    _this->_internal_set_threat_level(from._internal_threat_level());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_threat_score = from._internal_threat_score();
  uint64_t raw_threat_score;
  memcpy(&raw_threat_score, &tmp_threat_score, sizeof(tmp_threat_score));
  if (raw_threat_score != 0) {
    _this->_internal_set_threat_score(from._internal_threat_score());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_proximity_factor = from._internal_proximity_factor();
  uint64_t raw_proximity_factor;
  memcpy(&raw_proximity_factor, &tmp_proximity_factor, sizeof(tmp_proximity_factor));
  if (raw_proximity_factor != 0) {
    _this->_internal_set_proximity_factor(from._internal_proximity_factor());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_velocity_factor = from._internal_velocity_factor();
  uint64_t raw_velocity_factor;
  memcpy(&raw_velocity_factor, &tmp_velocity_factor, sizeof(tmp_velocity_factor));
  if (raw_velocity_factor != 0) {
    _this->_internal_set_velocity_factor(from._internal_velocity_factor());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_trajectory_factor = from._internal_trajectory_factor();
  uint64_t raw_trajectory_factor;
  memcpy(&raw_trajectory_factor, &tmp_trajectory_factor, sizeof(tmp_trajectory_factor));
  if (raw_trajectory_factor != 0) {
    _this->_internal_set_trajectory_factor(from._internal_trajectory_factor());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_classification_factor = from._internal_classification_factor();
  uint64_t raw_classification_factor;
  memcpy(&raw_classification_factor, &tmp_classification_factor, sizeof(tmp_classification_factor));
  if (raw_classification_factor != 0) {
    _this->_internal_set_classification_factor(from._internal_classification_factor());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_time_to_intercept_seconds = from._internal_time_to_intercept_seconds();
  uint64_t raw_time_to_intercept_seconds;
  memcpy(&raw_time_to_intercept_seconds, &tmp_time_to_intercept_seconds, sizeof(tmp_time_to_intercept_seconds));
  if (raw_time_to_intercept_seconds != 0) {
    _this->_internal_set_time_to_intercept_seconds(from._internal_time_to_intercept_seconds());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_intercept_probability = from._internal_intercept_probability();
  uint64_t raw_intercept_probability;
  memcpy(&raw_intercept_probability, &tmp_intercept_probability, sizeof(tmp_intercept_probability));
  if (raw_intercept_probability != 0) {
    _this->_internal_set_intercept_probability(from._internal_intercept_probability());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ThreatAssessment::CopyFrom(const ThreatAssessment& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:radar.messages.ThreatAssessment)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ThreatAssessment::IsInitialized() const {
  return true;
}

void ThreatAssessment::InternalSwap(ThreatAssessment* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.recommended_actions_.InternalSwap(&other->_impl_.recommended_actions_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.priority_, lhs_arena,
      &other->_impl_.priority_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ThreatAssessment, _impl_.intercept_probability_)
      + sizeof(ThreatAssessment::_impl_.intercept_probability_)
      - PROTOBUF_FIELD_OFFSET(ThreatAssessment, _impl_.timestamp_)>(
          reinterpret_cast<char*>(&_impl_.timestamp_),
          reinterpret_cast<char*>(&other->_impl_.timestamp_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ThreatAssessment::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_track_5fmessages_2eproto_getter, &descriptor_table_track_5fmessages_2eproto_once,
      file_level_metadata_track_5fmessages_2eproto[13]);
}

// ===================================================================

SystemConfiguration_ClusteringParamsEntry_DoNotUse::SystemConfiguration_ClusteringParamsEntry_DoNotUse() {}
SystemConfiguration_ClusteringParamsEntry_DoNotUse::SystemConfiguration_ClusteringParamsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
    : SuperType(arena) {}
void SystemConfiguration_ClusteringParamsEntry_DoNotUse::MergeFrom(const SystemConfiguration_ClusteringParamsEntry_DoNotUse& other) {
  MergeFromInternal(other);
}
::PROTOBUF_NAMESPACE_ID::Metadata SystemConfiguration_ClusteringParamsEntry_DoNotUse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_track_5fmessages_2eproto_getter, &descriptor_table_track_5fmessages_2eproto_once,
      file_level_metadata_track_5fmessages_2eproto[14]);
}

// ===================================================================

SystemConfiguration_AssociationParamsEntry_DoNotUse::SystemConfiguration_AssociationParamsEntry_DoNotUse() {}
SystemConfiguration_AssociationParamsEntry_DoNotUse::SystemConfiguration_AssociationParamsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
    : SuperType(arena) {}
void SystemConfiguration_AssociationParamsEntry_DoNotUse::MergeFrom(const SystemConfiguration_AssociationParamsEntry_DoNotUse& other) {
  MergeFromInternal(other);
}
::PROTOBUF_NAMESPACE_ID::Metadata SystemConfiguration_AssociationParamsEntry_DoNotUse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_track_5fmessages_2eproto_getter, &descriptor_table_track_5fmessages_2eproto_once,
      file_level_metadata_track_5fmessages_2eproto[15]);
}

// ===================================================================

SystemConfiguration_FilterParamsEntry_DoNotUse::SystemConfiguration_FilterParamsEntry_DoNotUse() {}
SystemConfiguration_FilterParamsEntry_DoNotUse::SystemConfiguration_FilterParamsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
    : SuperType(arena) {}
void SystemConfiguration_FilterParamsEntry_DoNotUse::MergeFrom(const SystemConfiguration_FilterParamsEntry_DoNotUse& other) {
  MergeFromInternal(other);
}
::PROTOBUF_NAMESPACE_ID::Metadata SystemConfiguration_FilterParamsEntry_DoNotUse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_track_5fmessages_2eproto_getter, &descriptor_table_track_5fmessages_2eproto_once,
      file_level_metadata_track_5fmessages_2eproto[16]);
}

// ===================================================================

class SystemConfiguration::_Internal {
 public:
  static const ::PROTOBUF_NAMESPACE_ID::Timestamp& timestamp(const SystemConfiguration* msg);
};

const ::PROTOBUF_NAMESPACE_ID::Timestamp&
SystemConfiguration::_Internal::timestamp(const SystemConfiguration* msg) {
  return *msg->_impl_.timestamp_;
}
void SystemConfiguration::clear_timestamp() {
  if (GetArenaForAllocation() == nullptr && _impl_.timestamp_ != nullptr) {
    delete _impl_.timestamp_;
  }
  _impl_.timestamp_ = nullptr;
}
SystemConfiguration::SystemConfiguration(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  if (arena != nullptr && !is_message_owned) {
    arena->OwnCustomDestructor(this, &SystemConfiguration::ArenaDtor);
  }
  // @@protoc_insertion_point(arena_constructor:radar.messages.SystemConfiguration)
}
SystemConfiguration::SystemConfiguration(const SystemConfiguration& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SystemConfiguration* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      /*decltype(_impl_.clustering_params_)*/{}
    , /*decltype(_impl_.association_params_)*/{}
    , /*decltype(_impl_.filter_params_)*/{}
    , decltype(_impl_.clustering_algorithm_){}
    , decltype(_impl_.association_algorithm_){}
    , decltype(_impl_.filter_algorithm_){}
    , decltype(_impl_.log_level_){}
    , decltype(_impl_.timestamp_){nullptr}
    , decltype(_impl_.update_rate_hz_){}
    , decltype(_impl_.track_timeout_seconds_){}
    , decltype(_impl_.confirmation_threshold_){}
    , decltype(_impl_.deletion_threshold_){}
    , decltype(_impl_.max_tracks_){}
    , decltype(_impl_.enable_hmi_output_){}
    , decltype(_impl_.enable_fusion_output_){}
    , decltype(_impl_.enable_logging_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.clustering_params_.MergeFrom(from._impl_.clustering_params_);
  _this->_impl_.association_params_.MergeFrom(from._impl_.association_params_);
  _this->_impl_.filter_params_.MergeFrom(from._impl_.filter_params_);
  _impl_.clustering_algorithm_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.clustering_algorithm_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_clustering_algorithm().empty()) {
    _this->_impl_.clustering_algorithm_.Set(from._internal_clustering_algorithm(), 
      _this->GetArenaForAllocation());
  }
  _impl_.association_algorithm_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.association_algorithm_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_association_algorithm().empty()) {
    _this->_impl_.association_algorithm_.Set(from._internal_association_algorithm(), 
      _this->GetArenaForAllocation());
  }
  _impl_.filter_algorithm_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.filter_algorithm_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_filter_algorithm().empty()) {
    _this->_impl_.filter_algorithm_.Set(from._internal_filter_algorithm(), 
      _this->GetArenaForAllocation());
  }
  _impl_.log_level_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.log_level_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_log_level().empty()) {
    _this->_impl_.log_level_.Set(from._internal_log_level(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_timestamp()) {
    _this->_impl_.timestamp_ = new ::PROTOBUF_NAMESPACE_ID::Timestamp(*from._impl_.timestamp_);
  }
  ::memcpy(&_impl_.update_rate_hz_, &from._impl_.update_rate_hz_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.enable_logging_) -
    reinterpret_cast<char*>(&_impl_.update_rate_hz_)) + sizeof(_impl_.enable_logging_));
  // @@protoc_insertion_point(copy_constructor:radar.messages.SystemConfiguration)
}

inline void SystemConfiguration::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      /*decltype(_impl_.clustering_params_)*/{::_pbi::ArenaInitialized(), arena}
    , /*decltype(_impl_.association_params_)*/{::_pbi::ArenaInitialized(), arena}
    , /*decltype(_impl_.filter_params_)*/{::_pbi::ArenaInitialized(), arena}
    , decltype(_impl_.clustering_algorithm_){}
    , decltype(_impl_.association_algorithm_){}
    , decltype(_impl_.filter_algorithm_){}
    , decltype(_impl_.log_level_){}
    , decltype(_impl_.timestamp_){nullptr}
    , decltype(_impl_.update_rate_hz_){0}
    , decltype(_impl_.track_timeout_seconds_){0}
    , decltype(_impl_.confirmation_threshold_){0}
    , decltype(_impl_.deletion_threshold_){0}
    , decltype(_impl_.max_tracks_){0u}
    , decltype(_impl_.enable_hmi_output_){false}
    , decltype(_impl_.enable_fusion_output_){false}
    , decltype(_impl_.enable_logging_){false}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.clustering_algorithm_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.clustering_algorithm_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.association_algorithm_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.association_algorithm_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.filter_algorithm_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.filter_algorithm_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.log_level_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.log_level_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

SystemConfiguration::~SystemConfiguration() {
  // @@protoc_insertion_point(destructor:radar.messages.SystemConfiguration)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    ArenaDtor(this);
    return;
  }
  SharedDtor();
}

inline void SystemConfiguration::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.clustering_params_.Destruct();
  _impl_.clustering_params_.~MapField();
  _impl_.association_params_.Destruct();
  _impl_.association_params_.~MapField();
  _impl_.filter_params_.Destruct();
  _impl_.filter_params_.~MapField();
  _impl_.clustering_algorithm_.Destroy();
  _impl_.association_algorithm_.Destroy();
  _impl_.filter_algorithm_.Destroy();
  _impl_.log_level_.Destroy();
  if (this != internal_default_instance()) delete _impl_.timestamp_;
}

void SystemConfiguration::ArenaDtor(void* object) {
  SystemConfiguration* _this = reinterpret_cast< SystemConfiguration* >(object);
  _this->_impl_.clustering_params_.Destruct();
  _this->_impl_.association_params_.Destruct();
  _this->_impl_.filter_params_.Destruct();
}
void SystemConfiguration::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SystemConfiguration::Clear() {
// @@protoc_insertion_point(message_clear_start:radar.messages.SystemConfiguration)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.clustering_params_.Clear();
  _impl_.association_params_.Clear();
  _impl_.filter_params_.Clear();
  _impl_.clustering_algorithm_.ClearToEmpty();
  _impl_.association_algorithm_.ClearToEmpty();
  _impl_.filter_algorithm_.ClearToEmpty();
  _impl_.log_level_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && _impl_.timestamp_ != nullptr) {
    delete _impl_.timestamp_;
  }
  _impl_.timestamp_ = nullptr;
  ::memset(&_impl_.update_rate_hz_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.enable_logging_) -
      reinterpret_cast<char*>(&_impl_.update_rate_hz_)) + sizeof(_impl_.enable_logging_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SystemConfiguration::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .google.protobuf.Timestamp timestamp = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_timestamp(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string clustering_algorithm = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_clustering_algorithm();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "radar.messages.SystemConfiguration.clustering_algorithm"));
        } else
          goto handle_unusual;
        continue;
      // string association_algorithm = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_association_algorithm();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "radar.messages.SystemConfiguration.association_algorithm"));
        } else
          goto handle_unusual;
        continue;
      // string filter_algorithm = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_filter_algorithm();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "radar.messages.SystemConfiguration.filter_algorithm"));
        } else
          goto handle_unusual;
        continue;
      // map<string, double> clustering_params = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(&_impl_.clustering_params_, ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<42>(ptr));
        } else
          goto handle_unusual;
        continue;
      // map<string, double> association_params = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(&_impl_.association_params_, ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<50>(ptr));
        } else
          goto handle_unusual;
        continue;
      // map<string, double> filter_params = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(&_impl_.filter_params_, ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<58>(ptr));
        } else
          goto handle_unusual;
        continue;
      // double update_rate_hz = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 65)) {
          _impl_.update_rate_hz_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // uint32 max_tracks = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _impl_.max_tracks_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // double track_timeout_seconds = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 81)) {
          _impl_.track_timeout_seconds_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double confirmation_threshold = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 89)) {
          _impl_.confirmation_threshold_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double deletion_threshold = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 97)) {
          _impl_.deletion_threshold_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // bool enable_hmi_output = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 104)) {
          _impl_.enable_hmi_output_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool enable_fusion_output = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 112)) {
          _impl_.enable_fusion_output_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool enable_logging = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 120)) {
          _impl_.enable_logging_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string log_level = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 130)) {
          auto str = _internal_mutable_log_level();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "radar.messages.SystemConfiguration.log_level"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SystemConfiguration::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:radar.messages.SystemConfiguration)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .google.protobuf.Timestamp timestamp = 1;
  if (this->_internal_has_timestamp()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::timestamp(this),
        _Internal::timestamp(this).GetCachedSize(), target, stream);
  }

  // string clustering_algorithm = 2;
  if (!this->_internal_clustering_algorithm().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_clustering_algorithm().data(), static_cast<int>(this->_internal_clustering_algorithm().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "radar.messages.SystemConfiguration.clustering_algorithm");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_clustering_algorithm(), target);
  }

  // string association_algorithm = 3;
  if (!this->_internal_association_algorithm().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_association_algorithm().data(), static_cast<int>(this->_internal_association_algorithm().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "radar.messages.SystemConfiguration.association_algorithm");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_association_algorithm(), target);
  }

  // string filter_algorithm = 4;
  if (!this->_internal_filter_algorithm().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_filter_algorithm().data(), static_cast<int>(this->_internal_filter_algorithm().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "radar.messages.SystemConfiguration.filter_algorithm");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_filter_algorithm(), target);
  }

  // map<string, double> clustering_params = 5;
  if (!this->_internal_clustering_params().empty()) {
    using MapType = ::_pb::Map<std::string, double>;
    using WireHelper = SystemConfiguration_ClusteringParamsEntry_DoNotUse::Funcs;
    const auto& map_field = this->_internal_clustering_params();
    auto check_utf8 = [](const MapType::value_type& entry) {
      (void)entry;
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        entry.first.data(), static_cast<int>(entry.first.length()),
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
        "radar.messages.SystemConfiguration.ClusteringParamsEntry.key");
    };

    if (stream->IsSerializationDeterministic() && map_field.size() > 1) {
      for (const auto& entry : ::_pbi::MapSorterPtr<MapType>(map_field)) {
        target = WireHelper::InternalSerialize(5, entry.first, entry.second, target, stream);
        check_utf8(entry);
      }
    } else {
      for (const auto& entry : map_field) {
        target = WireHelper::InternalSerialize(5, entry.first, entry.second, target, stream);
        check_utf8(entry);
      }
    }
  }

  // map<string, double> association_params = 6;
  if (!this->_internal_association_params().empty()) {
    using MapType = ::_pb::Map<std::string, double>;
    using WireHelper = SystemConfiguration_AssociationParamsEntry_DoNotUse::Funcs;
    const auto& map_field = this->_internal_association_params();
    auto check_utf8 = [](const MapType::value_type& entry) {
      (void)entry;
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        entry.first.data(), static_cast<int>(entry.first.length()),
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
        "radar.messages.SystemConfiguration.AssociationParamsEntry.key");
    };

    if (stream->IsSerializationDeterministic() && map_field.size() > 1) {
      for (const auto& entry : ::_pbi::MapSorterPtr<MapType>(map_field)) {
        target = WireHelper::InternalSerialize(6, entry.first, entry.second, target, stream);
        check_utf8(entry);
      }
    } else {
      for (const auto& entry : map_field) {
        target = WireHelper::InternalSerialize(6, entry.first, entry.second, target, stream);
        check_utf8(entry);
      }
    }
  }

  // map<string, double> filter_params = 7;
  if (!this->_internal_filter_params().empty()) {
    using MapType = ::_pb::Map<std::string, double>;
    using WireHelper = SystemConfiguration_FilterParamsEntry_DoNotUse::Funcs;
    const auto& map_field = this->_internal_filter_params();
    auto check_utf8 = [](const MapType::value_type& entry) {
      (void)entry;
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        entry.first.data(), static_cast<int>(entry.first.length()),
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
        "radar.messages.SystemConfiguration.FilterParamsEntry.key");
    };

    if (stream->IsSerializationDeterministic() && map_field.size() > 1) {
      for (const auto& entry : ::_pbi::MapSorterPtr<MapType>(map_field)) {
        target = WireHelper::InternalSerialize(7, entry.first, entry.second, target, stream);
        check_utf8(entry);
      }
    } else {
      for (const auto& entry : map_field) {
        target = WireHelper::InternalSerialize(7, entry.first, entry.second, target, stream);
        check_utf8(entry);
      }
    }
  }

  // double update_rate_hz = 8;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_update_rate_hz = this->_internal_update_rate_hz();
  uint64_t raw_update_rate_hz;
  memcpy(&raw_update_rate_hz, &tmp_update_rate_hz, sizeof(tmp_update_rate_hz));
  if (raw_update_rate_hz != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(8, this->_internal_update_rate_hz(), target);
  }

  // uint32 max_tracks = 9;
  if (this->_internal_max_tracks() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(9, this->_internal_max_tracks(), target);
  }

  // double track_timeout_seconds = 10;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_track_timeout_seconds = this->_internal_track_timeout_seconds();
  uint64_t raw_track_timeout_seconds;
  memcpy(&raw_track_timeout_seconds, &tmp_track_timeout_seconds, sizeof(tmp_track_timeout_seconds));
  if (raw_track_timeout_seconds != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(10, this->_internal_track_timeout_seconds(), target);
  }

  // double confirmation_threshold = 11;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_confirmation_threshold = this->_internal_confirmation_threshold();
  uint64_t raw_confirmation_threshold;
  memcpy(&raw_confirmation_threshold, &tmp_confirmation_threshold, sizeof(tmp_confirmation_threshold));
  if (raw_confirmation_threshold != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(11, this->_internal_confirmation_threshold(), target);
  }

  // double deletion_threshold = 12;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_deletion_threshold = this->_internal_deletion_threshold();
  uint64_t raw_deletion_threshold;
  memcpy(&raw_deletion_threshold, &tmp_deletion_threshold, sizeof(tmp_deletion_threshold));
  if (raw_deletion_threshold != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(12, this->_internal_deletion_threshold(), target);
  }

  // bool enable_hmi_output = 13;
  if (this->_internal_enable_hmi_output() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(13, this->_internal_enable_hmi_output(), target);
  }

  // bool enable_fusion_output = 14;
  if (this->_internal_enable_fusion_output() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(14, this->_internal_enable_fusion_output(), target);
  }

  // bool enable_logging = 15;
  if (this->_internal_enable_logging() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(15, this->_internal_enable_logging(), target);
  }

  // string log_level = 16;
  if (!this->_internal_log_level().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_log_level().data(), static_cast<int>(this->_internal_log_level().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "radar.messages.SystemConfiguration.log_level");
    target = stream->WriteStringMaybeAliased(
        16, this->_internal_log_level(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:radar.messages.SystemConfiguration)
  return target;
}

size_t SystemConfiguration::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:radar.messages.SystemConfiguration)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // map<string, double> clustering_params = 5;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_clustering_params_size());
  for (::PROTOBUF_NAMESPACE_ID::Map< std::string, double >::const_iterator
      it = this->_internal_clustering_params().begin();
      it != this->_internal_clustering_params().end(); ++it) {
    total_size += SystemConfiguration_ClusteringParamsEntry_DoNotUse::Funcs::ByteSizeLong(it->first, it->second);
  }

  // map<string, double> association_params = 6;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_association_params_size());
  for (::PROTOBUF_NAMESPACE_ID::Map< std::string, double >::const_iterator
      it = this->_internal_association_params().begin();
      it != this->_internal_association_params().end(); ++it) {
    total_size += SystemConfiguration_AssociationParamsEntry_DoNotUse::Funcs::ByteSizeLong(it->first, it->second);
  }

  // map<string, double> filter_params = 7;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_filter_params_size());
  for (::PROTOBUF_NAMESPACE_ID::Map< std::string, double >::const_iterator
      it = this->_internal_filter_params().begin();
      it != this->_internal_filter_params().end(); ++it) {
    total_size += SystemConfiguration_FilterParamsEntry_DoNotUse::Funcs::ByteSizeLong(it->first, it->second);
  }

  // string clustering_algorithm = 2;
  if (!this->_internal_clustering_algorithm().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_clustering_algorithm());
  }

  // string association_algorithm = 3;
  if (!this->_internal_association_algorithm().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_association_algorithm());
  }

  // string filter_algorithm = 4;
  if (!this->_internal_filter_algorithm().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_filter_algorithm());
  }

  // string log_level = 16;
  if (!this->_internal_log_level().empty()) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_log_level());
  }

  // .google.protobuf.Timestamp timestamp = 1;
  if (this->_internal_has_timestamp()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.timestamp_);
  }

  // double update_rate_hz = 8;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_update_rate_hz = this->_internal_update_rate_hz();
  uint64_t raw_update_rate_hz;
  memcpy(&raw_update_rate_hz, &tmp_update_rate_hz, sizeof(tmp_update_rate_hz));
  if (raw_update_rate_hz != 0) {
    total_size += 1 + 8;
  }

  // double track_timeout_seconds = 10;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_track_timeout_seconds = this->_internal_track_timeout_seconds();
  uint64_t raw_track_timeout_seconds;
  memcpy(&raw_track_timeout_seconds, &tmp_track_timeout_seconds, sizeof(tmp_track_timeout_seconds));
  if (raw_track_timeout_seconds != 0) {
    total_size += 1 + 8;
  }

  // double confirmation_threshold = 11;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_confirmation_threshold = this->_internal_confirmation_threshold();
  uint64_t raw_confirmation_threshold;
  memcpy(&raw_confirmation_threshold, &tmp_confirmation_threshold, sizeof(tmp_confirmation_threshold));
  if (raw_confirmation_threshold != 0) {
    total_size += 1 + 8;
  }

  // double deletion_threshold = 12;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_deletion_threshold = this->_internal_deletion_threshold();
  uint64_t raw_deletion_threshold;
  memcpy(&raw_deletion_threshold, &tmp_deletion_threshold, sizeof(tmp_deletion_threshold));
  if (raw_deletion_threshold != 0) {
    total_size += 1 + 8;
  }

  // uint32 max_tracks = 9;
  if (this->_internal_max_tracks() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_max_tracks());
  }

  // bool enable_hmi_output = 13;
  if (this->_internal_enable_hmi_output() != 0) {
    total_size += 1 + 1;
  }

  // bool enable_fusion_output = 14;
  if (this->_internal_enable_fusion_output() != 0) {
    total_size += 1 + 1;
  }

  // bool enable_logging = 15;
  if (this->_internal_enable_logging() != 0) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SystemConfiguration::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SystemConfiguration::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SystemConfiguration::GetClassData() const { return &_class_data_; }


void SystemConfiguration::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SystemConfiguration*>(&to_msg);
  auto& from = static_cast<const SystemConfiguration&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:radar.messages.SystemConfiguration)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.clustering_params_.MergeFrom(from._impl_.clustering_params_);
  _this->_impl_.association_params_.MergeFrom(from._impl_.association_params_);
  _this->_impl_.filter_params_.MergeFrom(from._impl_.filter_params_);
  if (!from._internal_clustering_algorithm().empty()) {
    _this->_internal_set_clustering_algorithm(from._internal_clustering_algorithm());
  }
  if (!from._internal_association_algorithm().empty()) {
    _this->_internal_set_association_algorithm(from._internal_association_algorithm());
  }
  if (!from._internal_filter_algorithm().empty()) {
    _this->_internal_set_filter_algorithm(from._internal_filter_algorithm());
  }
  if (!from._internal_log_level().empty()) {
    _this->_internal_set_log_level(from._internal_log_level());
  }
  if (from._internal_has_timestamp()) {
    _this->_internal_mutable_timestamp()->::PROTOBUF_NAMESPACE_ID::Timestamp::MergeFrom(
        from._internal_timestamp());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_update_rate_hz = from._internal_update_rate_hz();
  uint64_t raw_update_rate_hz;
  memcpy(&raw_update_rate_hz, &tmp_update_rate_hz, sizeof(tmp_update_rate_hz));
  if (raw_update_rate_hz != 0) {
    _this->_internal_set_update_rate_hz(from._internal_update_rate_hz());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_track_timeout_seconds = from._internal_track_timeout_seconds();
  uint64_t raw_track_timeout_seconds;
  memcpy(&raw_track_timeout_seconds, &tmp_track_timeout_seconds, sizeof(tmp_track_timeout_seconds));
  if (raw_track_timeout_seconds != 0) {
    _this->_internal_set_track_timeout_seconds(from._internal_track_timeout_seconds());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_confirmation_threshold = from._internal_confirmation_threshold();
  uint64_t raw_confirmation_threshold;
  memcpy(&raw_confirmation_threshold, &tmp_confirmation_threshold, sizeof(tmp_confirmation_threshold));
  if (raw_confirmation_threshold != 0) {
    _this->_internal_set_confirmation_threshold(from._internal_confirmation_threshold());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_deletion_threshold = from._internal_deletion_threshold();
  uint64_t raw_deletion_threshold;
  memcpy(&raw_deletion_threshold, &tmp_deletion_threshold, sizeof(tmp_deletion_threshold));
  if (raw_deletion_threshold != 0) {
    _this->_internal_set_deletion_threshold(from._internal_deletion_threshold());
  }
  if (from._internal_max_tracks() != 0) {
    _this->_internal_set_max_tracks(from._internal_max_tracks());
  }
  if (from._internal_enable_hmi_output() != 0) {
    _this->_internal_set_enable_hmi_output(from._internal_enable_hmi_output());
  }
  if (from._internal_enable_fusion_output() != 0) {
    _this->_internal_set_enable_fusion_output(from._internal_enable_fusion_output());
  }
  if (from._internal_enable_logging() != 0) {
    _this->_internal_set_enable_logging(from._internal_enable_logging());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SystemConfiguration::CopyFrom(const SystemConfiguration& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:radar.messages.SystemConfiguration)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SystemConfiguration::IsInitialized() const {
  return true;
}

void SystemConfiguration::InternalSwap(SystemConfiguration* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.clustering_params_.InternalSwap(&other->_impl_.clustering_params_);
  _impl_.association_params_.InternalSwap(&other->_impl_.association_params_);
  _impl_.filter_params_.InternalSwap(&other->_impl_.filter_params_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.clustering_algorithm_, lhs_arena,
      &other->_impl_.clustering_algorithm_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.association_algorithm_, lhs_arena,
      &other->_impl_.association_algorithm_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.filter_algorithm_, lhs_arena,
      &other->_impl_.filter_algorithm_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.log_level_, lhs_arena,
      &other->_impl_.log_level_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SystemConfiguration, _impl_.enable_logging_)
      + sizeof(SystemConfiguration::_impl_.enable_logging_)
      - PROTOBUF_FIELD_OFFSET(SystemConfiguration, _impl_.timestamp_)>(
          reinterpret_cast<char*>(&_impl_.timestamp_),
          reinterpret_cast<char*>(&other->_impl_.timestamp_));
}

::PROTOBUF_NAMESPACE_ID::Metadata SystemConfiguration::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_track_5fmessages_2eproto_getter, &descriptor_table_track_5fmessages_2eproto_once,
      file_level_metadata_track_5fmessages_2eproto[17]);
}

// @@protoc_insertion_point(namespace_scope)
}  // namespace messages
}  // namespace radar
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::radar::messages::TrackState*
Arena::CreateMaybeMessage< ::radar::messages::TrackState >(Arena* arena) {
  return Arena::CreateMessageInternal< ::radar::messages::TrackState >(arena);
}
template<> PROTOBUF_NOINLINE ::radar::messages::Track_ClassificationScoresEntry_DoNotUse*
Arena::CreateMaybeMessage< ::radar::messages::Track_ClassificationScoresEntry_DoNotUse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::radar::messages::Track_ClassificationScoresEntry_DoNotUse >(arena);
}
template<> PROTOBUF_NOINLINE ::radar::messages::Track_AttributesEntry_DoNotUse*
Arena::CreateMaybeMessage< ::radar::messages::Track_AttributesEntry_DoNotUse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::radar::messages::Track_AttributesEntry_DoNotUse >(arena);
}
template<> PROTOBUF_NOINLINE ::radar::messages::Track*
Arena::CreateMaybeMessage< ::radar::messages::Track >(Arena* arena) {
  return Arena::CreateMessageInternal< ::radar::messages::Track >(arena);
}
template<> PROTOBUF_NOINLINE ::radar::messages::TrackBatch*
Arena::CreateMaybeMessage< ::radar::messages::TrackBatch >(Arena* arena) {
  return Arena::CreateMessageInternal< ::radar::messages::TrackBatch >(arena);
}
template<> PROTOBUF_NOINLINE ::radar::messages::TrackUpdate_UpdateDataEntry_DoNotUse*
Arena::CreateMaybeMessage< ::radar::messages::TrackUpdate_UpdateDataEntry_DoNotUse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::radar::messages::TrackUpdate_UpdateDataEntry_DoNotUse >(arena);
}
template<> PROTOBUF_NOINLINE ::radar::messages::TrackUpdate*
Arena::CreateMaybeMessage< ::radar::messages::TrackUpdate >(Arena* arena) {
  return Arena::CreateMessageInternal< ::radar::messages::TrackUpdate >(arena);
}
template<> PROTOBUF_NOINLINE ::radar::messages::TrackHistory*
Arena::CreateMaybeMessage< ::radar::messages::TrackHistory >(Arena* arena) {
  return Arena::CreateMessageInternal< ::radar::messages::TrackHistory >(arena);
}
template<> PROTOBUF_NOINLINE ::radar::messages::DetectionCluster_AlgorithmParametersEntry_DoNotUse*
Arena::CreateMaybeMessage< ::radar::messages::DetectionCluster_AlgorithmParametersEntry_DoNotUse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::radar::messages::DetectionCluster_AlgorithmParametersEntry_DoNotUse >(arena);
}
template<> PROTOBUF_NOINLINE ::radar::messages::DetectionCluster*
Arena::CreateMaybeMessage< ::radar::messages::DetectionCluster >(Arena* arena) {
  return Arena::CreateMessageInternal< ::radar::messages::DetectionCluster >(arena);
}
template<> PROTOBUF_NOINLINE ::radar::messages::Association*
Arena::CreateMaybeMessage< ::radar::messages::Association >(Arena* arena) {
  return Arena::CreateMessageInternal< ::radar::messages::Association >(arena);
}
template<> PROTOBUF_NOINLINE ::radar::messages::FusionData_SensorWeightsEntry_DoNotUse*
Arena::CreateMaybeMessage< ::radar::messages::FusionData_SensorWeightsEntry_DoNotUse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::radar::messages::FusionData_SensorWeightsEntry_DoNotUse >(arena);
}
template<> PROTOBUF_NOINLINE ::radar::messages::FusionData*
Arena::CreateMaybeMessage< ::radar::messages::FusionData >(Arena* arena) {
  return Arena::CreateMessageInternal< ::radar::messages::FusionData >(arena);
}
template<> PROTOBUF_NOINLINE ::radar::messages::ThreatAssessment*
Arena::CreateMaybeMessage< ::radar::messages::ThreatAssessment >(Arena* arena) {
  return Arena::CreateMessageInternal< ::radar::messages::ThreatAssessment >(arena);
}
template<> PROTOBUF_NOINLINE ::radar::messages::SystemConfiguration_ClusteringParamsEntry_DoNotUse*
Arena::CreateMaybeMessage< ::radar::messages::SystemConfiguration_ClusteringParamsEntry_DoNotUse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::radar::messages::SystemConfiguration_ClusteringParamsEntry_DoNotUse >(arena);
}
template<> PROTOBUF_NOINLINE ::radar::messages::SystemConfiguration_AssociationParamsEntry_DoNotUse*
Arena::CreateMaybeMessage< ::radar::messages::SystemConfiguration_AssociationParamsEntry_DoNotUse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::radar::messages::SystemConfiguration_AssociationParamsEntry_DoNotUse >(arena);
}
template<> PROTOBUF_NOINLINE ::radar::messages::SystemConfiguration_FilterParamsEntry_DoNotUse*
Arena::CreateMaybeMessage< ::radar::messages::SystemConfiguration_FilterParamsEntry_DoNotUse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::radar::messages::SystemConfiguration_FilterParamsEntry_DoNotUse >(arena);
}
template<> PROTOBUF_NOINLINE ::radar::messages::SystemConfiguration*
Arena::CreateMaybeMessage< ::radar::messages::SystemConfiguration >(Arena* arena) {
  return Arena::CreateMessageInternal< ::radar::messages::SystemConfiguration >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
